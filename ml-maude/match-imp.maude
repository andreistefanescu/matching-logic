in match-hp


mod IMP is inc HP .
  subsort PVar < KProper .
  subsort Int++ < KResult .

  eq  [| K |] = [| 0,0,<config>
                            <k> K </k>
                            <env> .Env </env>
                            <heap> .Heap </heap>
                            <form> TrueFormula </form>
                            <menv> .MatchEnv </menv>
                            <newSym> 0 </newSym>
                            <newImpl> 0 </newImpl>
                </config> |] .

  eq <k> X ~> K </k> <env> X |-> I ;; Env </env> = <k> I ~> K </k> <env> X |-> I ;; Env </env> .

  op _+_ : K K -> KProper [prec 33 gather(e E)] .  ops ([]+_) (_+[]) : K -> K .
  eq <k> Kp + K ~> Rest </k> = <k> Kp ~> [] + K ~> Rest </k> .
  eq <k> V1 ~> [] + K ~> Rest </k> = <k> V1 + K ~> Rest </k> .
  eq <k> V1 + Kp ~> Rest </k> = <k> Kp ~> V1 + [] ~> Rest </k> .
  eq <k> V2 ~> V1 + [] ~> Rest </k> = <k> V1 + V2 ~> Rest </k> .
  eq I1 + I2 = I1 +Int I2 .

  op _-_ : K K -> KProper [prec 33 gather(e E)] .  ops ([]-_) (_-[]) : K -> K .
  eq <k> Kp - K ~> Rest </k> = <k> Kp ~> [] - K ~> Rest </k> .
  eq <k> V1 ~> [] - K ~> Rest </k> = <k> V1 - K ~> Rest </k> .
  eq <k> V1 - Kp ~> Rest </k> = <k> Kp ~> V1 - [] ~> Rest </k> .
  eq <k> V2 ~> V1 - [] ~> Rest </k> = <k> V1 - V2 ~> Rest </k> .
---  eq I1 - I2 = #(_-_(I1,I2)) .
  eq I1 - I2 = I1 +Int (-Int I2) .

  op _>_ : K K -> KProper [prec 35] .  ops ([]>_) (_>[]) : K -> K .
  eq <k> Kp > K ~> Rest </k> = <k> Kp ~> [] > K ~> Rest </k> .
  eq <k> V1 ~> [] > K ~> Rest </k> = <k> V1 > K ~> Rest </k> .
  eq <k> V1 > Kp ~> Rest </k> = <k> Kp ~> V1 > [] ~> Rest </k> .
  eq <k> V2 ~> V1 > [] ~> Rest </k> = <k> V1 > V2 ~> Rest </k> .
  eq I1 > I2 = ?(I1 >Int I2) .

  op _==_ : K K -> KProper [prec 35] .  ops ([]==_) (_==[]) : K -> K .
  eq <k> Kp == K ~> Rest </k> = <k> Kp ~> [] == K ~> Rest </k> .
  eq <k> V1 ~> [] == K ~> Rest </k> = <k> V1 == K ~> Rest </k> .
  eq <k> V1 == Kp ~> Rest </k> = <k> Kp ~> V1 == [] ~> Rest </k> .
  eq <k> V2 ~> V1 == [] ~> Rest </k> = <k> V1 == V2 ~> Rest </k> .
  eq I1 == I2 = ?(I1 =Int= I2) .

  op _!=_ : K K -> KProper [prec 35] .  eq K1 != K2 = !(K1 == K2) .
  op !_ : K -> KProper [prec 5] .  eq ! K = if(K) 0 else 1 .
  op _&&_ : K K -> KProper [gather(e E) prec 55] .  eq K1 && K2 = if(K1) K2 else 0 .
  op _||_ : K K -> KProper [gather(e E) prec 59] .  eq K1 || K2 = if(K1) 1 else K2 .

  op *_ : K -> KProper [prec 10] .  op *[] : -> K .
  eq <k> * Kp ~> Rest </k> = <k> Kp ~> *[] ~> Rest </k> .
  eq <k> V ~> *[] ~> Rest </k> = <k> * V ~> Rest </k> .
  eq <k> * I ~> Rest </k> <heap> I |-> J : T ** H </heap> = <k> J ~> Rest </k> <heap> I |-> J : T ** H </heap> .
  eq <k> * I ~> Rest </k> <heap> H </heap> = <k> derive(I) ~> * I ~> Rest </k> <heap> H </heap> [owise] .

  op _=_ : K K -> KProper [prec 40] .
  op _=@ : K -> K .
  op *@=_ : K -> K .
  eq <k> * Kp = K ~> Rest </k> = <k> Kp ~> *@= K ~> Rest </k> .
  eq <k> V ~> *@= K ~> Rest </k> = <k> * V = K ~> Rest </k> .
  eq <k> K = Kp ~> Rest </k> = <k> Kp ~> K =@ ~> Rest </k> .
  eq <k> V ~> K =@ ~> Rest </k> = <k> K = V ~> Rest </k> .

  eq <k> X = I ~> Rest </k> <env> Env </env> = <k> Rest </k> <env> Env[X <- I] </env> .
  eq <k> * I = J ~> Rest </k> <heap> I |-> J' : T ** H </heap> = <k> Rest </k> <heap> I |-> J : T ** H </heap> .
  eq <k> * I = J ~> Rest </k> <heap> H </heap> = <k> derive(I) ~> * I = J ~> Rest </k> <heap> H </heap> [owise] .

  op NULL : -> KProper .  eq NULL = 0 .
  op __ : K K -> K [assoc prec 100] .  eq K1 K2 = (K1 ~> K2) .
  op _; : K -> K [prec 99] .  eq K ; = K .
  op {} : -> K .  eq {} = .K .
  op {_} : K -> K .  eq {K} = K .
  op if__ : K K -> KProper [prec 93] .  eq if (K) K1 = if (K) K1 else .K .

  op alloc_ : List{LocType} -> KProper [prec 0] .
  eq <k> alloc(LocTypeList) ~> Rest </k> <heap> H </heap> <newSym> N </newSym>
  = <k> ?Int(N) ~> Rest </k> <heap> ?Int(N) |-> LocTypeList ** H </heap> <newSym> N +Int 1 </newSym> .
  eq <heap> I |-> (T, LocTypeList) ** H </heap> <newSym> N </newSym>
  = <heap> I |-> ?Int(N) : T ** (I + 1) |-> LocTypeList ** H </heap> <newSym> N +Int 1 </newSym> .
  eq <heap> I |-> (.empty).List{LocType} ** H </heap> = <heap> H </heap> .

  op free_ : K -> K .  op free([]) : -> K .
  eq <k> free(Kp) ~> Rest </k> = <k> Kp ~> free([]) ~> Rest </k> .
  eq <k> V ~> free([]) ~> Rest </k> = <k> free(V) ~> Rest </k> .
  eq <k> free(I) ~> Rest </k> <heap> (I +Int I') |-> J : T ** H </heap>
  = <k> free(I) ~> Rest </k> <heap> H </heap> .
  eq <k> free(I) ~> Rest </k> <heap> I |-> J : T ** H </heap>
  = <k> free(I) ~> Rest </k> <heap> H </heap> .
  eq <k> free(I) ~> Rest </k> <heap> H </heap> = <k> Rest </k> <heap> H </heap> [owise] .

  op if`(_`)_else_ : K K K -> KProper [prec 95] .  op if`([]`)_else_ : K K -> K .
  eq <k> (if(Kp) K1 else K2) ~> Rest </k> = <k> Kp ~> (if([]) K1 else K2) ~> Rest </k> .
  eq <k> V ~> (if([]) K1 else K2) ~> Rest </k> = <k> if(V) K1 else K2 ~> Rest </k> .
--- ceq if(# I) K1 else K2 = K1 if I =/= 0 .
---  eq if(# 0) K1 else K2 = K2 .
  rl <config> <k> (if(I) K1 else K2) ~> Rest </k> <form> Phi </form> Cfg </config>
  => <config> <k> K1 ~> Rest </k> <form> Phi /\ ~(I === 0) </form> Cfg </config>
     <config> <k> K2 ~> Rest </k> <form> Phi /\ I === 0 </form> Cfg </config> .

  op while__ : K K -> K .
---  eq <k> while(K1)K2 ~> Rest </k> = <k> (if(K1){K2 ; while(K1)K2} else .K) ~> Rest </k> .
  eq <config> <k> invariant Cfg ~> while(K1)K2 ~> Rest </k> Cfg' </config>
   = <config> <k> assert Cfg ~> if(K1)(K2 ~> assert Cfg) else Rest </k> Cfg' </config> .

  ops invariant_ assume_ assert_ : Set{ConfigItem} -> K [prec 99 strat(0) format(r! +++i i---)] .

  eq <config> <k> assume <config> <form> Phi </form> Cfg </config> CFGs ~> Rest </k> <form> Phi' </form> <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg' </config>
   = <config> <k> Rest </k> <form> Phi /\ Phi' </form>[get!Subst(MatchEnv)] <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg[get!Subst(MatchEnv)] <newSym> 0 </newSym> </config>
     <config> <k> assume CFGs ~> Rest </k> <form> Phi' </form> <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg' </config> .
  eq <config> <k> assume .empty ~> Rest </k> Cfg' </config> = .empty .

 crl <config> <k> assert Cfg' ~> Rest </k> <menv>  MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg </config>
  => <config> <k> assume Cfg' ~> Rest </k> <menv> MatchEnv' </menv> <newImpl> N:Nat +Nat 1 </newImpl> skolemize(N:Nat, Cfg) </config>
  if <config> Cfg <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> </config> ===> Cfg'
  => <form> TrueFormula </form> <menv> MatchEnv' </menv> [print MatchEnv'] .

  op breakpoint : -> K .
  op watch : -> K .
 ceq <config> <k> watch ~> Rest </k> Cfg </config> = <config> <k> Rest </k> Cfg </config>
  if Cfg' := <config> <k> Rest </k> Cfg </config> [print "\n===CFG===\n" Cfg' "\n===\n"] .

---good for debugging, but a bit slower than the above
---  eq <config> <k> assert Phi ~> Rest </k> Cfg </config>
---   = <config> <k> VALID(<config> Cfg </config> ===> Phi) ? ~> assume Phi ~> Rest </k> Cfg </config> .

  var X : PVar .  vars V V1 V2 : KResult .  vars K K1 K2 Rest : K .  var Kp : KProper .
  var Env : Env++ .  var H H' : Heap++ .  var T : LocType .  var LocTypeList : List{LocType} .
  var N : Nat .  vars I I' I1 I2 J J' : Int++ .
  var Cfg Cfg' Cfg'' CFGs : Set{ConfigItem} .
  var ?ObjList : List{?MathObj} .
  var Phi Phi' : Formula .
  vars MatchEnv MatchEnv' : MatchEnv .
endm
