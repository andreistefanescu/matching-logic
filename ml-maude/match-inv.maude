in match-fol


mod TERM-GEN is inc MATHEMATICAL-DOMAIN + SUBST + META-LEVEL .
    var N : NzNat .
    var Obj : MathObj++ .
    var ObjList : List{MathObj++} .
    var OpQid : Qid .
    var Type : Type .
    var TypeList : TypeList .
    var Term : Term .
    vars TermList TermList' TermList'' PartialTermList ArgTermList : TermList .
    var OpDecl : OpDecl .
    var OpDeclSet : OpDeclSet .
    var AttrSet : AttrSet .
    var Subst : Subst .

    op undefObj : -> MathObj++ .
    op Module : -> Module .
    op ExtendedModule : -> Module .
    op mkObjs : List{MathObj++} Int -> List{MathObj++} .
    op mkTermList : List{MathObj++} -> TermList .
    op mkObjList : TermList -> List{MathObj++} .
    op mkTermsLoop : TermList OpDeclSet Int -> TermList .
    op mkTerms : TermList OpDeclSet -> TermList .
    op mkTerms : TermList OpDecl -> TermList .
    op mkTerms : Qid TypeList TermList -> TermList .
    op mkTerms : Qid TermList -> TermList .
    op mkTerms : TermList TypeList TermList -> TermList .
    op mkTerms : TermList TermList -> TermList .
    op mkTerms : TermList Term -> TermList .
    op mkTypedTermList : Type TermList -> TermList .
    op redTermList : TermList -> TermList .

    eq redTermList((TermList, Term, TermList', Term, TermList'')) = redTermList((TermList, Term, TermList', TermList'')) .
    eq redTermList(TermList) = TermList [owise] .

    eq Module = upModule('MATHEMATICAL-INT-SEQUENCE, false) .
---    eq Module = upModule('MATHEMATICAL-DOMAIN, true) .
    eq ExtendedModule = upModule('MATHEMATICAL-DOMAIN, true) .

--- convert List{MathObj++} to TermList and back
    eq mkTermList(Obj, ObjList) = upTerm(Obj), mkTermList(ObjList) .
    eq mkTermList(.empty) = empty .
    eq mkObjList((Term, TermList)) = downTerm(Term, errorObj), mkObjList(TermList) .
    eq mkObjList(empty) = .empty .

    eq mkObjs(ObjList, N) = mkObjList(mkTermsLoop(mkTermList(ObjList), getOps(Module), N)) .
    eq mkTermsLoop(TermList, OpDeclSet, N) = mkTermsLoop(redTermList((TermList, mkTerms(TermList, OpDeclSet))), OpDeclSet, N + (-1)) .
    eq mkTermsLoop(TermList, OpDeclSet, 0) = TermList .
   ceq mkTerms(TermList, OpDecl OpDeclSet) = mkTerms(TermList, OpDecl), mkTerms(TermList, OpDeclSet) if OpDeclSet =/= none .
    eq mkTerms(TermList, (none).OpDeclSet) = empty .
    
    eq mkTerms(TermList, (op OpQid : TypeList -> Type[AttrSet].)) = mkTerms(OpQid, TypeList, TermList) .
    eq mkTypedTermList(Type, (Term, TermList)) = if sortLeq(ExtendedModule, leastSort(ExtendedModule, Term), Type) then Term else empty fi,
                                                    mkTypedTermList(Type, TermList) .
    eq mkTypedTermList(Type, empty) = empty .
    
    eq mkTerms(OpQid, (Type TypeList), TermList) = mkTerms(mkTerms(OpQid, mkTypedTermList(Type, TermList)), TypeList, TermList) .
    eq mkTerms(OpQid, nil, TermList) = empty .
    eq mkTerms(OpQid, (Term, TermList)) = OpQid[Term], mkTerms(OpQid, TermList) .
    eq mkTerms(OpQid, empty) = empty .

    eq mkTerms(PartialTermList, (Type TypeList), TermList) = mkTerms(mkTerms(PartialTermList, mkTypedTermList(Type, TermList)), TypeList, TermList) .
    eq mkTerms(PartialTermList, nil, TermList) = PartialTermList .
   ceq mkTerms(PartialTermList, (Term, TermList)) = mkTerms(PartialTermList, Term), mkTerms(PartialTermList, TermList) if TermList =/= empty .
    eq mkTerms(PartialTermList, empty) = empty .
    eq mkTerms((OpQid[ArgTermList], PartialTermList), Term) = OpQid[ArgTermList, Term], mkTerms(PartialTermList, Term) .
    eq mkTerms(empty, Term) = empty .
endm


mod INV-GEN is inc TERM-GEN + FOL= .
    sort InvFormula .
    subsort InvFormula < Formula .

    var N : Nat .
    vars Obj Obj' Obj1 Obj2 : MathObj++ .
    vars ObjList ObjList' ObjList1 ObjList2 : List{MathObj++} .

    op ConstInv : MathObj++ MathObj++ -> InvFormula .
    op EqualInv : MathObj++ MathObj++ -> InvFormula .
---    op mkInvs : List{MathObj++} -> Formula .
    op mkInvs : List{MathObj++} Int -> Formula .
    op mkConstInvs : List{MathObj++} -> Formula .
    op mkEqualInvs : List{MathObj++} List{MathObj++} -> Formula .
    op mkEqualInv : List{MathObj++} MathObj++ -> Formula .
    
---    eq mkInvs(ObjList) = mkInvs(ObjList, 1) .
   ceq mkInvs(ObjList, N) = mkConstInvs(ObjList') /\ mkEqualInvs(ObjList', ObjList') if ObjList' := mkObjs(ObjList, N) .
    eq mkConstInvs(Obj, ObjList) = ConstInv(Obj, undefObj) /\ mkConstInvs(ObjList) .
    eq mkConstInvs(.empty) = TrueFormula .
    eq mkEqualInvs((Obj1, ObjList1), ObjList2) = mkEqualInv(Obj1, ObjList2) /\ mkEqualInvs(ObjList1, ObjList2) .
    eq mkEqualInvs(.empty, ObjList2) = TrueFormula .
    eq mkEqualInv(Obj1, (Obj2, ObjList2)) = EqualInv(Obj1, Obj2) /\ mkEqualInv(Obj1, ObjList2) .
    eq mkEqualInv(Obj1, .empty) = TrueFormula .
endm


mod INV-CHECK is inc INV-GEN .
    op TestModule : -> Module .
    op checkFormula : Formula Subst -> Formula .
    op checkInv : Formula Subst -> Formula .

    var Obj Obj' Obj1 Obj2 : MathObj++ .
    var InvPhi : InvFormula .
    var Phi : Formula .
    var Subst : Subst .

    eq TestModule = upModule('TEST, true) .
    eq Obj[Subst] = downTerm(getTerm(metaReduce(addEQS(TestModule, mkEQS(Subst)), upTerm(Obj))), errorObj) .

    eq checkFormula(InvPhi /\ Phi, Subst) = checkInv(InvPhi, Subst) /\ checkFormula(Phi, Subst) .
    eq checkFormula(TrueFormula, Subst) = TrueFormula .
    eq checkInv(ConstInv(Obj, undefObj), Subst) = ConstInv(Obj, Obj[Subst]) .
   ceq checkInv(ConstInv(Obj1, Obj2), Subst) = if Obj1[Subst] == Obj2 then ConstInv(Obj1, Obj2) else TrueFormula fi
    if Obj2 =/= undefObj .
    eq checkInv(EqualInv(Obj1, Obj2), Subst) = if Obj1[Subst] == Obj2[Subst] then EqualInv(Obj1, Obj2) else TrueFormula fi .
endm


***(
red mkInvs((Alpha, Beta), 1) .
--- red checkFormula(ConstInv(A :: B, undefObj) /\ ConstInv(rev(A) :: B, undefObj) /\ ConstInv(A :: rev(B), undefObj) /\ ConstInv(rev(A) :: rev(A), undefObj) ,
---     (A <- )) .
red (?A :: A)[?A <- rev(B)] .
***)
