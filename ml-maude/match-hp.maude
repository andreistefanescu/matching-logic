in match-fol


mod HP is inc FOL= .
  var N : Nat .  var P P' P1 P2 Q Q' Q1 Q2 I I' J L R L' R' B E : Int++ .  var Rest : K .  var Alpha Beta : IntSeq++ .  var H H' : Heap++ .
  var ?ObjList : List{?MathObj} .  var Phi Phi1 Phi2 : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem . var O : TypedObj .
  var Sigma Tau : IntTree++ .  var Alpha' Beta' : IntTreeSeq++ .

  
  ops node next : -> LocType .
  ops head tail : -> LocType .
  ops left right : -> LocType .


*** derive ***
  eq <config> <k> derive(P') ~> Rest </k> <heap> P' |-> O ** H </heap> <form> Phi </form> Cfg </config>
   = <config> <k> Rest </k> <heap> P' |-> O ** H </heap> <form> Phi </form> Cfg </config> .
***(
 ceq <config> <k> derive(P') ~> Rest </k> <heap> P |-> O ** H </heap> <form> Phi </form> Cfg </config>
   = <config> <k> Rest </k> <heap> P |-> O ** H </heap> <form> Phi </form> Cfg </config>
    if VALID(Phi ===> P' === P) .
***)


  op list : -> HeapPatternName .

*** Definition of Lists ***
--- First equation tells how to derive a list, so it applies the equivalence in the paper from left to right by need.
--- Second equation and the two rules apply the equivalence in the paper from right to left, identifying three cases
--- One should be able to combine the two rules into one, but we prefer to keep them distinct for now
 ceq <config> <k> derive(P') ~> Rest </k> <heap> list(P)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** list(?Int(N +Int 1))(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> list(0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** list(P')(Alpha) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)((I :: Alpha)) ** H </heap> Cfg </config> =heap=> CFG .


  op lseg : -> HeapPatternName .

*** Definition of List Segments ***
--- First equation tells how to derive a list segment , so it applies the equivalence in the paper from left to right by need.
 ceq <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === Q) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** lseg(?Int(N +Int 1),Q)(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === Q) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> lseg(P,P)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  eq <heap> lseg(P,0)(Alpha) ** H </heap> = <heap> list(P)(Alpha) ** H </heap> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** lseg(P',Q)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** list(P')(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .


  op queue : -> HeapPatternName .

*** Definition of Queues ***
--- First equation tells how to derive a queue, so it applies the equivalence in the paper from left to right by need.
 ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : head ** (P +Int 1) |-> ?Int(N +Int 1) : tail ** queue(?Int(N), ?Int(N +Int 1))(Alpha) ** H </heap>
              <form> Phi /\ ~(P === 0) </form> <newSym> N +Int 2 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> queue(0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> 0 : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(epsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : head ** (P +Int 1) |-> Q : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(epsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> Q' : tail ** queue(Q,Q')(Alpha) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(Alpha) ** H </heap> Cfg </config> =heap=> CFG .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P,Q)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Q === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(?IntSeq(N)) ** Q |-> ?Int(N +Int 1) : node ** (Q +Int 1) |-> ?Int(N +Int 2) : next ** H </heap>
              <form> Phi /\ ~(P === 0) /\ ~(Q === 0) /\ (Alpha === ?IntSeq(N) :: ?Int(N +Int 1)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === Q \/ P' === Q +Int 1) .

  eq <heap> queue(P,0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ P === 0 /\ Alpha === epsilon </form> .
  eq <heap> queue(0,Q)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Q === 0 /\ Alpha === epsilon </form> .

  rl <config> <heap> Q |-> I : node ** (Q +Int 1) |-> Q' : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(Q,Q)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** queue(P',Q)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P,Q)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .


  op tree : -> HeapPatternName .

*** Definition of Trees ***
 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree(P)(Tau) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Tau === upsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : left ** (P +Int 2) |-> ?Int(N +Int 2) : right
                ** tree(?Int(N +Int 1))(?IntTree(N +Int 3)) ** tree(?Int(N +Int 2))(?IntTree(N +Int 4)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Tau === ?IntTree(N +Int 3) [ ?Int(N) ] ?IntTree(N +Int 4)) </form> <newSym> N +Int 5 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree(0)(Tau) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Tau === upsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> 0 : right ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(upsilon [ I ] upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> 0 : right ** tree(Q)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(Tau [ I ] upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> Q : right ** tree(Q)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(upsilon [ I ] Tau) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> Q' : right ** tree(Q)(Tau) ** tree(Q')(Sigma) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(Tau [ I ] Sigma) ** H </heap> Cfg </config> =heap=> CFG .


  op tree-list : -> HeapPatternName .

*** Definition of Lists of Trees ***
 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree-list(P)(Alpha') ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha' === epsilon') </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** tree(?Int(N))(?IntTree(N +Int 2)) ** tree-list(?Int(N +Int 1))(?IntTreeSeq(N +Int 3)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Alpha' === ?IntTree(N +Int 2) ::' ?IntTreeSeq(N +Int 3)) /\ ~(?Int(N) === 0) </form> <newSym> N +Int 4 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree-list(0)(Alpha') ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha' === epsilon' </form> .

  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** tree(I)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(Tau) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> P' : next ** tree-list(P')(Alpha') ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(upsilon ::' Alpha') ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** tree(I)(Tau) ** tree-list(P')(Alpha') ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(Tau ::' Alpha') ** H </heap> Cfg </config> =heap=> CFG .


  op array : -> HeapPatternName .

*** Definition of Arrays ***
--- First equation tells how to derive a list segment , so it applies the equivalence in the paper from left to right by need.
 ceq <config> <k> derive(P') ~> Rest </k> <heap> array(P,B,E)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
---     <config> <k> derive(P') ~> Rest </k> <heap> array(P,B,E)(Alpha) ** H </heap> <form> Phi /\ ~(P === 0) /\ ~(@(I >= B) /\ @(E > I)) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ ~(P === 0) /\ ~(@(I >=Int B) /\ @(E >Int I)) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> (P +Int I) |-> ?Int(N) : node ** array(P,B,I)(?IntSeq(N +Int 1)) ** array(P,I +Int 1,E)(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ @(I >=Int B) /\ @(E >Int I) /\ (Alpha === ?IntSeq(N +Int 1) :: ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
---    if VALID(Phi ===> P' === P /\ I' === I) .
    if P +Int I := P' .

  eq <heap> array(0,B,E)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  eq <heap> array(P,B,B)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> (P +Int I) |-> J : node ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> array(P,I,I +Int 1)(J) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> array(P,B,I)(Alpha) ** array(P,I,E)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> array(P,B,E)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .
endm
