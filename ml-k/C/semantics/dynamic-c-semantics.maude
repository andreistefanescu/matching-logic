mod DYNAMIC-C-SEMANTICS is
	including COMMON-C-SEMANTICS .
	
	op incomingArgumentArray : -> Id [ctor] .
	op incomingArguments : List{K} -> K .
	op incomingArguments-aux : List{K} Nat -> K .
	eq incomingArguments(L:List{K}) = incomingArguments-aux(L:List{K}, 0) .
	eq incomingArguments-aux((E:Expression,, L:List{K}), N:Nat) = ((incomingArgumentArray[N:Nat] := Cast(Pointer(char), E:Expression) ;) ~> incomingArguments-aux(L:List{K}, sNat(N:Nat))) .
	eq incomingArguments-aux(.List{K}, N:Nat) = (incomingArgumentArray[N:Nat] := Cast(Pointer(char), NULL) ;) .
	eq eval(P:Program, L:List{K}) = 
		< T >
			< local >
				< k > P:Program 
					~> Declaration(char, Pointer(incomingArgumentArray[sNat(length L:List{K})])) 
					~> incomingArguments(L:List{K})
					--- ~> incomingArgumentArray[0] := Cast(Pointer(char), Name:String) ; 
					--- ~> incomingArgumentArray[1] := Cast(Pointer(char), NULL) ; 
					~> Apply(main, ((length L:List{K}) .,. incomingArgumentArray)) </ k >
				< env > .Map </ env >
				< loopStack > .List </ loopStack >
				< locals > .Bag </ locals >
				< types > .Map </ types >
			</ local >
			< sizes > .Map </ sizes >
			< genv > .Map </ genv > 
			< mem > .Map </ mem >
			< callStack > .List </ callStack >
			< nextLoc > 0 </ nextLoc >
			< nextFile > 3 </ nextFile >
			< malloced > .Map </ malloced >
			< statics > .Map </ statics >
			< typedefs > .Map </ typedefs >
			< structs > .Map </ structs >
			< openFiles >
				0 |-> "stdin" --- stdin
				1 |-> "stdout" --- stdout
				2 |-> "stdout" --- stderr
			</ openFiles >
		</ T >
		< files > 
			"stdin" |-> ""
			"stdout" |-> ""
		</ files >
	.
	
	--- throw away annotations
	mb [no-annotations]: rule [annotation(?); => .K] : KSentence .
	
	***(
	Declaration-Specifiers Identifier(Parameter-Type-List){
		Block-Item-List
	}
	***)
	
		

	
	
	mb [terminate]: rule 
		[< T >... < k > V:Value </ k > ...</ T >
		=> < resultValue > V:Value </ resultValue >]
		< files >...
			["stdin" |-> S1:String	"stdout" |-> S2:String => .Map]
		...</ files >
		[.Bag => < input > S1:String </ input >	< output > S2:String </ output >]
		: KSentence .
	
	
endm
