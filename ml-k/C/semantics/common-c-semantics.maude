--- $(value $var) gives what we want for pipestatus
--- why isn't K ~> K proper?
set print attribute on .
mod INCOMING-MODULES is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
endm

mod COMMON-SEMANTIC-SYNTAX is
	including INCOMING-MODULES .
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult .
	op debugK : -> K .
	op discard : -> K .
	op unnamedBitField : -> Id [ctor] .
	
	sort State .
	subsort String < State .
	
	sort Value .
	sort Type .
	sort BaseValue .
	sort Field .
	subsort Field < KResult .

	subsort Int Rat Float < BaseValue .
	subsort BaseValue < Expression .
	subsort Value < Expression .
	subsort Value < KResult .
	subsort Type < KResult .
	subsort Base-Type < Type .
	subsort TogetherList < Expression .
	op sizeof : Type -> Expression .
	op HOLE : -> Expression .
	op arrayType : Type Nat -> Type .
	op bitfieldType : Type Nat -> Type .
	op functionType : Type List{K} -> Type .
	op pointerType : Type -> Type .
	op structType : Id -> Type .
	op qualifiedType : Type K -> Type .
	op typedField : Type Id -> Field .
	op declare : K K -> K [metadata "strict(1)"] .
	op declare-aux : K K List{K} -> K .
	op converted : K K -> K .
	op evalToType : -> K .
	op interpret : K Type -> K .
	op allocate : K -> K [metadata "strict"] .
	op tv : BaseValue Type -> Value .
	op addTypes : K K -> K .
	op addGlobalTypes : K K -> K .
	op addGlobalTypes : K -> K .
	op Closure : K K K -> Value .
	op putInMem : BaseValue K Type K -> K [metadata "strict(2 4)"] .
	op putBytesInMem : Nat List{K} Type K -> K [metadata "strict(4)"] .
	op sizeofType : Type -> K [memo] .
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	op _to_ : Nat Nat -> List{K} . 
	op calcStructSize : List{KResult} -> K .
	op necessaryBytes : K -> K [metadata "strict"] .
	op calcStructSize-aux : List{KResult} Rat -> K .
	op cast : K K -> K [metadata "strict"] .
	op addLocals : Nat -> K .			
	op integerTypes : -> Set [memo] .
	op unsignedIntegerTypes : -> Set [memo] .
	op typeof : Expression -> K .
endm

mod C-SETTINGS is
	including INCOMING-MODULES .
	including COMMON-SEMANTIC-SYNTAX .

	--- S 6.2.5 p.35 i.15.  "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.  37)... Irrespective of the choice made, char is a separate type from the other two and is not compatible with either
	--- cme: I'm not sure what consequence being a separate type entails, so for now it will just be rewritten to the chosen type
	mb rule [char => signed-char] : KSentence [metadata "stuctural"] .
	
	---C99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented

	op numBytes : Type -> Nat [memo] .
	eq numBytes(signed-char) = 1 .
	eq numBytes(short-int) = 2 .
	eq numBytes(int) = 4 .
	eq numBytes(long-int) = 4 .
	eq numBytes(long-long-int) = 8 .
	
	eq numBytes(double) = 8 .
	
	
	op cfg:sizeut : -> Type .
	eq cfg:sizeut = unsigned-long-int .

	
	---- derived
	eq numBytes(unsigned-char) = numBytes(signed-char) .
	eq numBytes(unsigned-short-int) = numBytes(short-int) .
	eq numBytes(unsigned-int) = numBytes(int) .
	eq numBytes(unsigned-long-int) = numBytes(long-int) .
	eq numBytes(unsigned-long-long-int) = numBytes(long-long-int) .
	
	op numBits : Type -> Nat [memo] .
	eq numBits(T:Type) = numBytes(T:Type) *Nat 8 .
			
	op min : Type -> Int [memo] .
	op max : Type -> Int [memo] .
	eq min(signed-char) = -Int (2 ^Nat absInt(_-Int_(numBits(signed-char), 1))) .
	eq max(signed-char) = _-Int_(2 ^Nat absInt(_-Int_(numBits(signed-char), 1)), 1) .
	eq min(short-int) = -Int (2 ^Nat absInt(_-Int_(numBits(short-int), 1))) .
	eq max(short-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(short-int), 1)), 1) .
	eq min(int) = -Int (2 ^Nat absInt(_-Int_(numBits(int), 1))) .
	eq max(int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(int), 1)), 1) .
	eq min(long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-int), 1))) .
	eq max(long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-int), 1)), 1) .
	eq min(long-long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-long-int), 1))) .
	eq max(long-long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-long-int), 1)), 1) .
	
	eq min(unsigned-char) = 0 .
	eq max(unsigned-char) = _-Int_(2 ^Nat absInt(numBits(unsigned-char)), 1) .
	eq min(unsigned-short-int) = 0 .
	eq max(unsigned-short-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-short-int)), 1) .
	eq min(unsigned-int) = 0 .
	eq max(unsigned-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-int)), 1) .
	eq min(unsigned-long-int) = 0 .
	eq max(unsigned-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-int)), 1) .
	eq min(unsigned-long-long-int) = 0 .
	eq max(unsigned-long-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-long-int)), 1) .
		
	eq sizeofType(T:Base-Type) = tv(numBytes(T:Base-Type), cfg:sizeut) .
	eq sizeofType(pointerType(?)) = tv(numBytes(unsigned-long-int), cfg:sizeut) .

	mb rule 
		< k > [T:Typedef-Name => T:Type] ...</ k >
		< types >... T:Typedef-Name |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct(X:Id) => T:Type] ...</ k > 
		< types >... struct(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	
	--- — number of bits for smallest object that is not a bit-field (byte)
	--- CHAR_BIT 8
	--- — minimum value for an object of type signed char
	--- SCHAR_MIN -127 // -(27 - 1)
	--- — maximum value for an object of type signed char
	--- SCHAR_MAX +127 // 27 - 1
	--- — maximum value for an object of type unsigned char
	--- UCHAR_MAX 255 // 28 - 1
	--- — minimum value for an object of type char
	--- CHAR_MIN see below
	--- — maximum value for an object of type char
	--- CHAR_MAX see below
	--- — maximum number of bytes in a multibyte character, for any supported locale
	--- MB_LEN_MAX 1
	--- — minimum value for an object of type short int
	--- SHRT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type short int
	--- SHRT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned short int
	--- USHRT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type int
	--- INT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type int
	--- INT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned int
	--- UINT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type long int
	--- LONG_MIN -2147483647 // -(231 - 1)
	--- — maximum value for an object of type long int
	--- LONG_MAX +2147483647 // 231 - 1
	--- — maximum value for an object of type unsigned long int
	--- ULONG_MAX 4294967295 // 232 - 1
	--- — minimum value for an object of type long long int
	--- LLONG_MIN -9223372036854775807 // -(263 - 1)
	--- — maximum value for an object of type long long int
	--- LLONG_MAX +9223372036854775807 // 263 - 1
	--- — maximum value for an object of type unsigned long long int
	--- ULLONG_MAX 18446744073709551615 // 264 - 1
	
	
endm

mod COMMON-INCLUDE is
	including INCOMING-MODULES .
	including C-SETTINGS .
	including COMMON-SEMANTIC-SYNTAX .
	
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence .
		

	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
		
		
	--- Note: it only makes sense to memo this if the sets are just used to represent categories
	op _contains_ : Set K -> Bool [memo] .
	eq S:Set SetItem(K:K) contains K:K = true .
	ceq S:Set SetItem(K1:K) contains K2:K = S:Set contains K2:K 
		if K1:K =/=Bool K2:K .
	eq .Set contains K:K = false .

endm

mod SIZEOF is
	including COMMON-INCLUDE .

	ceq min(bitfieldType(T:Type, N:Nat)) = 0
		if unsignedIntegerTypes contains T:Type .
	ceq max(bitfieldType(T:Type, N:Nat)) = _-Int_(2 ^Nat absInt(N:Nat), 1)
		if unsignedIntegerTypes contains T:Type .
	
	mb rule
		< k > [sizeofType(arrayType(T:Type, N:Nat)) => '_*_(sizeofType(T:Type),, tv(N:Nat, cfg:sizeut))] ...</ k >
		: KSentence [metadata "stuctural"] .
	mb rule [sizeofType(bitfieldType(T:Type, N:Nat)) => tv(N:Nat /Rat 8, cfg:sizeut)] : KSentence [metadata "structural"] .
	
	---C99 6.2.6.1:26 ... Each unqualified type has several qualified versions of its type,40) corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers. The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements. ...
	eq sizeofType(qualifiedType(T:Type, ?)) = sizeofType(T:Type) .	
	mb rule
		< k > [sizeof(E:Expression) => evalToType ~> sizeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(T:Type)] ...</ k >
		[< type > T:Type </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	
	mb rule
		< type > [E:Expression => T:Type] ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_->_(Kp:KProper,, X:Id) => Kp:KProper ~> '_->_(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> '_->_(HOLE,, X:Id) => '_->_(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_->_(pointerType(structType(S:Id)),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> '_._(HOLE,, X:Id) => '_._(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_._(structType(S:Id),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> Deref(HOLE) => 'Deref(T:Type)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Deref(arrayType(T:Type, ?)) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Deref(tv(?, pointerType(T:Type))) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .

	eq necessaryBytes(tv(R:Rat, T:Type)) = tv(truncRat(R:Rat +Rat (7 /Rat 8)), T:Type) .
	mb [sizeof-struct]: rule
		< k > [sizeofType(structType(X:Id)) => calcStructSize(L:List{KResult})] ...</ k >
		< structs >... struct(X:Id) |-> L:List{KResult} ...</ structs >
	: KSentence .
	
	mb [calcStructSize]: rule
		< k > [calcStructSize(L:List{KResult}) => necessaryBytes(calcStructSize-aux(L:List{KResult}, 0))] ...</ k >
		: KSentence .
	
	mb [calcStructSize]: rule
		< k > [calcStructSize-aux((typedField(T:Type, X:Id),, L:List{KResult}), R:Rat) 
			=> sizeofType(T:Type) ~> calcStructSize-aux(L:List{KResult}, R:Rat)] ...</ k >
		if T:Type isa 'bitfieldType
		: KSentence .
	mb [calcStructSize]: rule
		< k > [calcStructSize-aux((typedField(T:Type, X:Id),, L:List{KResult}), R:Rat)
			=> sizeofType(T:Type) ~> calcStructSize-aux(L:List{KResult}, truncRat(R:Rat +Rat (7 /Rat 8)))] ...</ k >
		if notBool(T:Type isa 'bitfieldType)
		: KSentence .
	
	op _isa _ : K KLabel -> Bool .
	eq KL:KLabel(?) isa KL:KLabel = true .
	eq ? isa ? = false [owise] .
		
	mb [calcStructSize-cool]: rule
		< k > [tv(R':Rat, ?) ~> calcStructSize-aux(L:List{KResult}, R:Rat) 
			=> calcStructSize-aux(L:List{KResult}, R:Rat +Rat R':Rat)] ...</ k >
		: KSentence .
		
	mb [calcStructSize-done]: rule
		[calcStructSize-aux(.List{K}, R:Rat) => tv(R:Rat, cfg:sizeut)]
		: KSentence .
endm

mod TYPES is
	including COMMON-INCLUDE .
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	--- fixme ignoring qualifiers
	mb rule [qualifiedType(T:Type, ?) => T:Type] : KSentence [metadata "structural"] .
	
	mb rule [unsigned-short => unsigned-short-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long => unsigned-long-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long-long => unsigned-long-long-int] : KSentence [metadata "structural"] .
	mb rule [short => short-int] : KSentence [metadata "structural"] .
	mb rule [long => long-int] : KSentence [metadata "structural"] .
	mb rule [long-long => long-long-int] : KSentence [metadata "structural"] .
	
	mb rule
		< k > [typeof(E:Expression) => evalToType ~> typeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .
	mb rule
		< k > [evalToType ~> typeof(HOLE) => T:Type] ...</ k >
		[< type > T:Type </ type > => .Bag]
		: KSentence .
	
	mb rule 
		['_`[_`](T:Type,, N:Nat) => arrayType(T:Type, N:Nat)]
		: KSentence [metadata "structural"] .
	mb rule 
		['Pointer(T:Type) => pointerType(T:Type)]
		: KSentence [metadata "structural"] .
		

	mb rule 
		< k > ['Pointer(T:Type,, 'Direct-Function-Declarator('Parameter-Type-List(LL:List{Parameter}))) 
		=> pointerType(functionType(T:Type, getList{K}(LL:List{Parameter})))] ...</ k >
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > ['Pointer(T:Type) => pointerType(T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	--- move "Pointer" to where it belongs
	mb rule 
		[L:KLabel(T:Type,, 'Pointer(D:K)) => L:KLabel(pointerType(T:Type),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'BitField(D:K,, N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'BitField(N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, unnamedBitField)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'Direct-Function-Declarator(X:Id,, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(functionType(T:Type, getList{K}(LL:List{Parameter})),, X:Id)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule
		[L:KLabel(T:Type,, 'Direct-Function-Declarator('Pointer(D:Declarator),, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(pointerType(functionType(T:Type, getList{K}(LL:List{Parameter}))),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
		
	mb rule 
		[L:KLabel(T:Type,, D:Declarator[N:Nat]) 
		=> L:KLabel(arrayType(T:Type, N:Nat),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	
	--- fixme ignoring extern
	mb rule
		[extern => .K]
		: KSentence [metadata "structural"] .
	--- fixme ignoring static
	mb rule
		[static => .K]
		: KSentence [metadata "structural"] .
	mb rule
		[register => .K]
		: KSentence [metadata "structural"] .
	--- mb rule
		--- [extern ~> T:Type => qualifiedType(T:Type, extern)]
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- [static ~> T:Type => qualifiedType(T:Type, static)]
		--- : KSentence [metadata "structural"] .
	--- for casts, at least
	--- mb rule
		--- [Pointer(T:Type) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .

	
	op arithConversion : K K -> K [metadata "strict"] .
	op arithConversion-int : K K -> K [metadata "strict"] .
	op integerPromotion : K -> K .

	--- fixme should only happen if arguments are arithmetic
	--- mb rule
		--- < k > [.K => arithConversion(V:Value, V':Value)] ~> L:KLabel(V:Value,, V':Value) ...</ k > 
		--- if false
		--- orBool L:KLabel ==Bool '_*_
		--- orBool L:KLabel ==Bool '_/_
		--- orBool L:KLabel ==Bool '_+_
		--- orBool L:KLabel ==Bool '_-_
		--- orBool L:KLabel ==Bool '_%_
		--- orBool L:KLabel ==Bool '_<_
		--- orBool L:KLabel ==Bool '_>_
		--- orBool L:KLabel ==Bool '_<=_
		--- orBool L:KLabel ==Bool '_>=_
		--- orBool L:KLabel ==Bool '_==_
		--- orBool L:KLabel ==Bool '_!=_
		--- : KSentence .
	
		
	---C99 6.3.1.8
	--- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, long-double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, long-double), tv(V2:BaseValue, long-double))] ...</ k >
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, double), tv(V2:BaseValue, double))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float. 53) For example, addition of a double _Complex and a float entails just the conversion of the float operand to double (and yields a double _Complex result).
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, float), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, float), tv(V2:BaseValue, float))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- andBool T2:Type =/=Bool double
		--- : KSentence .
		
	--- Otherwise, the integer promotions are performed on both operands ...
	--- mb rule
		--- < k > [
			--- arithConversion(tv(V1:BaseValue, T1:Type), tv(V2:BaseValue, T2:Type)) 
			--- => 
			--- arithConversion-int(integerPromotion(tv(V1:BaseValue, T1:Type)), integerPromotion(tv(V2:BaseValue, T2:Type)))
		--- ] ...</ k >
		--- if T1:Type =/=Bool long-double andBool T2:Type =/=Bool long-double
		--- andBool T1:Type =/=Bool double andBool T2:Type =/=Bool double
		--- andBool T1:Type =/=Bool float andBool T2:Type =/=Bool float
		--- : KSentence .
	
	---C99 6.3.1.4:2 For objects or expressions with an integer type  whose integer conversion rank is less than or equal to the rank of int and unsigned int, and a bit field of type _Bool, int, signed int, or unsigned int, If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int.  These are called the integer promotions.  All other types are unchanged by the integer promotions.
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, int)) => tv(V:BaseValue, int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, unsigned-int)) => tv(V:BaseValue, unsigned-int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, unsigned-long-int)) => tv(V:BaseValue, unsigned-long-int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, pointerType(T:Type))) => tv(V:BaseValue, pointerType(T:Type))] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, arrayType(T:Type, N:Nat))) => tv(V:BaseValue, arrayType(T:Type, N:Nat))] ...</ k >
		--- : KSentence .
	
	--- Then the following rules are applied to the promoted operands:
	
	--- If both operands have the same type, then no further conversion is needed.
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- fixme not sure about this
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
	
	--- Otherwise...
	--- fixme left out cases
		
	op locs : List{K} -> KResult .
	mb [start-declare]: rule
		< k > ['Declaration(T:Type,, X:Id) => declare(T:Type, X:Id)] ...</ k >
		: KSentence .
	
endm	

------------------------------------------------
---- C standard library
mod COMMON-C-STANDARD-LIBRARY is
	including COMMON-INCLUDE .
	
	op builtin : Id -> Value .
	
	--------------------------------------------
	mb [sqrt-is-value]: rule
		< k > [sqrt => builtin(sqrt)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(sqrt), tv(F:Float, double)) => tv(sqrtFloat(F:Float), double)] ...</ k >
	: KSentence .
	
	--------------------------------------------
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), tv(N:Nat, ?)) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	--- Returns a pseudo-random integral number in the range 0 to RAND_MAX.
	
	mb [rand-is-value]: rule
		< k > [rand => builtin(rand)] ...</ k >
	: KSentence .
	--- unsignedIntegerTypes contains T:Type
	--- (2 ^Nat absInt(numBits(int)))
	--- fixme should use RAND_MAX
	mb [rand]: rule
		< k > [Apply(builtin(rand), .List{Expression}) => 
		tv(absInt(randomRandom(Loc:Nat)) %Int max(int), int)
		] ...</ k >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [free-is-value]: rule
		< k > [free => builtin(free)] ...</ k >
	: KSentence .
	
	mb [free]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => Apply(builtin(free), tv(sNat(Loc:Nat), pointerType(T:Type)))] ...</ k >
		< mem >...  [Loc:Nat |-> ? => .Map] ...</ mem >
		< malloced >... [Loc:Nat |-> sNat(N:Nat) => sNat(Loc:Nat) |-> N:Nat] ...</ malloced >
	: KSentence .
	mb [free-done]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => skipval] ...</ k >
		< malloced >... [Loc:Nat |-> 0 => .Map] ...</ malloced >
	: KSentence .
	--------------------------------------------
	mb [calloc-is-value]: rule
		< k > [calloc => builtin(calloc)] ...</ k >
	: KSentence .
	
	--- fixme ignoring size for now
	mb [calloc]: rule
		< k > ['Apply(builtin(calloc),, (tv(N:Nat, ?) .,. tv(Size:Nat, ?))) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat (N:Nat *Nat Size:Nat)) |-> 0] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat (N:Nat *Nat Size:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [memset-is-value]: rule
		< k > [memset => builtin(memset)] ...</ k >
	: KSentence .
	
	--- fixme should be checking and casting types
	--- fixme should be making sure N:Nat is a char
	mb [memset]: rule
		< k > [Apply(builtin(memset), (tv(Loc:Nat, pointerType(T:Type)) .,. tv(N:Nat, int) .,. tv(Len:Nat, ?))) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem > [M:Map => M:Map[N:Nat / Loc:Nat to (Loc:Nat +Nat Len:Nat)]] </ mem >
	: KSentence .
	--------------------------------------------
	mb [strlen-is-value]: rule
		< k > [strlen => builtin(strlen)] ...</ k >
	: KSentence .
	
	op strlen-aux : Nat Nat -> K .
	mb [strlen-start]: rule
		< k > [Apply(builtin(strlen), tv(Loc:Nat, pointerType(?))) => strlen-aux(0, Loc:Nat)] ...</ k >
	: KSentence .
	
	mb [strlen-nz]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => strlen-aux(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strlen-z]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => tv(Len:Nat, cfg:sizeut)] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcpy-is-value]: rule
		< k > [strcpy => builtin(strcpy)] ...</ k >
	: KSentence .
	
	--- fixme ensure char
	op strcpy-aux : Nat Nat Nat -> K .
	mb [strcpy-start]: rule
		< k > [Apply(builtin(strcpy), (tv(Dest:Nat, pointerType(T:Type)) .,. tv(Src:Nat, pointerType(T:Type)))) => strcpy-aux(Src:Nat, Dest:Nat, Dest:Nat)] ...</ k >
	: KSentence .
	
	mb [strcpy-nz]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => strcpy-aux(sNat(Src:Nat), sNat(Dest:Nat), Orig:Nat)] ...</ k >
		< mem >... Src:Nat |-> N:Nat Dest:Nat |-> [? => N:Nat] ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strcpy-z]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => tv(Orig:Nat, pointerType(char))] ...</ k >
		< mem >... Src:Nat |-> 0 Dest:Nat |-> [? => 0] ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcmp-is-value]: rule
		< k > [strcmp => builtin(strcmp)] ...</ k >
	: KSentence .
	
	op strcmp-aux : Nat Nat -> K .
	mb [strcmp-start]: rule
		< k > [Apply(builtin(strcmp), (tv(Loc1:Nat, pointerType(?)) .,. tv(Loc2:Nat, pointerType(?)))) => strcmp-aux(Loc1:Nat, Loc2:Nat)] ...</ k >
	: KSentence .
	
	mb [strcmp-same-addy]: rule
		< k > [strcmp-aux(Loc:Nat, Loc:Nat) => 0] ...</ k >
		: KSentence .
	mb [strcmp-same]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => strcmp-aux(sNat(Loc1:Nat), sNat(Loc2:Nat))] ...</ k >
		< mem >... Loc1:Nat |-> N:Nat Loc2:Nat |-> N:Nat ...</ mem >
		if N:Nat =/=Bool 0
		: KSentence .
	mb [strcmp-done]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => tv(0, int)] ...</ k >
		< mem >... Loc1:Nat |-> 0 Loc2:Nat |-> 0 ...</ mem >
		: KSentence .
	mb [strcmp-different]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => tv(if N1:Nat >Nat N2:Nat then 1 else -1 fi, int)] ...</ k >
		< mem >... Loc1:Nat |-> N1:Nat Loc2:Nat |-> N2:Nat ...</ mem >
		if N1:Nat =/=Bool N2:Nat
		: KSentence .
	--------------------------------------------
	mb [putchar-is-value]: rule
		< k > [putchar => builtin(putchar)] ...</ k >
	: KSentence .
	--- fixme doesn't cast to int
	mb [putchar]: rule
		< k > [Apply(builtin(putchar), tv(N:Nat, ?)) => tv(N:Nat, int)] ...</ k >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
	: KSentence .
	--------------------------------------------
	mb [lib-printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-string : Nat Nat -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [lib-printf-start]: rule
		< k > [Apply(builtin(printf), (tv(Loc:Nat, pointerType(?)) .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [lib-printf-string]: rule
		< k > [printf-string(Len:Nat, Loc:Nat) => printf-string(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat)] </ output >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [lib-printf-string-done]: rule
		< k > [printf-string(Len:Nat, Loc:Nat) => tv(Len:Nat, int)] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	
	mb [lib-printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat)] </ output >
		if notBool(N:Nat ==Bool asciiString("%")) 
		andBool notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [lib-printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => tv(Len:Nat, int)] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	mb [lib-printf-null]: rule
		< k > [printf-aux(0, 0, .List{Expression}) => tv(6, int)] ...</ k >
		< output > [S:String => S:String +String "(null)"] </ output >
	: KSentence .
	
	mb [lib-printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	--- fixme ignoring 0 flag for now
	mb [lib-printf-0]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat ==Bool asciiString("0") 
	: KSentence .
	--- ignoring num width
	mb [lib-printf-width]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat >Int asciiString("0") 
		andBool N:Nat <=Int asciiString("9")
	: KSentence .
	
	mb [lib-printf-x]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString((if (lengthString(rat2stringConversion(D:Int, 16)) ==Bool 1) then
				"0" +String rat2stringConversion(D:Int, 16)
			else 
				rat2stringConversion(D:Int, 16)
			fi)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String 
			(if (lengthString(rat2stringConversion(D:Int, 16)) ==Bool 1) then
				"0" +String rat2stringConversion(D:Int, 16)
			else 
				rat2stringConversion(D:Int, 16)
			fi)
			] </ output >
		if N:Nat ==Bool asciiString("x") 
	: KSentence .
	
	mb [lib-printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Int, 10)] </ output >
		if N:Nat ==Bool asciiString("d") 
	: KSentence .
	mb [lib-printf-%c]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(C:Nat, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat 1, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(C:Nat %Nat 256)] </ output >
		if N:Nat ==Bool asciiString("c") 
	: KSentence .
	
	mb [lib-printf-%u]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Int, 10)] </ output >
		if N:Nat ==Bool asciiString("u") 
	: KSentence .
	
	mb [lib-printf-%f]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Float, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(float2stringConversion(D:Float)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String float2stringConversion(D:Float)] </ output >
		if N:Nat ==Bool asciiString("f") 
	: KSentence .
	
	mb [lib-printf-%s]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(S:Nat, pointerType(?)) .,. L:List{Expression})) => 
			printf-string(0, S:Nat)
			~> printf-aux(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat ==Bool asciiString("s") 
	: KSentence .

	mb [lib-printf-%s-done]: rule
		< k > [tv(Len':Nat, int) ~> printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => 
			printf-aux(Len:Nat +Nat Len':Nat, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .
	op bind : List{K} List{K} -> K .

	mb [void-to-id]: rule
		[Parameter-Type-List(Parameter-Declaration(void)) 
		=> Parameter-Type-List(.List{Parameter})] : KSentence [metadata "structural"] .
	
	--- empty binding
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, .List{K}) => .K] ...</ k > 
		: KSentence .
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, ...) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	--- fixme doesn't add all derived types from T:Type
	--- fixme not cleaning memory on return
	--- fixme would be nice to check types match, but argument names etc might not be identical
	mb rule
		< k > [bind((tv(V:BaseValue, arrayType(T:Type, ?)),, L:List{KResult}), PD:List{K})
			=> bind((tv(V:BaseValue, pointerType(T:Type)),, L:List{KResult}), PD:List{K})] ...</ k > : KSentence [metadata "structural"] .
			
	--- fixme can't this be done by heating bind?
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, D:Declarator),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, D:Declarator),, P:List{K}))] ...</ k >
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .	
		
	mb [bind-one]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))
			=> addTypes(X:Id, T':Type) ~> allocate(sizeofType(T':Type)) ~> addLocals(Loc:Nat) ~> putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T':Type, sizeofType(T':Type)) ~> bind(L:List{KResult}, P:List{K})] ...</ k > 
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb [bind-var]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), (...))
			=> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat) ~> putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T:Type, sizeofType(T:Type)) ~> bind(L:List{KResult}, ...)] ...</ k > 
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, X:Id),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))] ...</ k > 
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .		
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb rule
		< k > ['Global('Declaration(T:Type,, X:Id))
			=> addGlobalTypes(X:Id, T:Type) ~> '_;(allocate(sizeofType(T:Type)))] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		if getKLabel(T:Type)=/=Bool 'functionType
		: KSentence .
		
	mb rule
		< k > ['Global('Declaration(TD:Typedef-Name,, D:Declarator))
			=> 'Global('Declaration(T:Type,, D:Declarator))] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence [metadata "structural"] .
	
	mb [global-variable-declaration-init]: rule
		< k > ['_=_('Declaration(T:Type,, X:Id),, E:Expression) => 'Global('Declaration(T:Type,, X:Id)) ~> Deref(&(X:Id)) := E:Expression ;] ...</ k >
		: KSentence .
		
	mb [function-definition]: rule 
		< k > ['_`{_`}('Declaration(T:Type,, X:Id),, B:TogetherList)=> .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> Closure(X:Id, T:Type, B:TogetherList)] </ mem >
		< types >... [.Map => X:Id |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Type] ...</ typedefs >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb rule 
		< k > ['_`{_`}('Declaration(TD:Typedef-Name,, D:Declarator),, B:TogetherList) => '_`{_`}('Declaration(T:Type,, D:Declarator),, B:TogetherList)] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb [function-prototype]: rule 
		< k > ['Global('Declaration(functionType(T:Type, L:List{K}),, I:Id)) => .K] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [Global(Typedef(T:TogetherList, X:Declarator)) => Typedef(T:TogetherList, X:Declarator)] ...</ k >
		: KSentence [metadata "structural"] .
	mb [typedef-declaration]: rule
		< k > ['Typedef(T:Type,, X:Typedef-Name) => .K] ...</ k >
		< types >... [.Map => X:Typedef-Name |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb rule 
		< k > [T:Type ~> addGlobalTypes(K:K) => addGlobalTypes(K:K, T:Type)] ...</ k >
		: KSentence .
		
	op initArray : List{K} Nat Type -> K .
	mb [global-array-declaration-init]: rule
		< k > ['_=`{_`}('Declaration(arrayType(T:Type, N:Nat),, X:Id),, L:List{Expression}) => '_;(allocate(sizeofType(arrayType(T:Type, N:Nat)))) ~> initArray(getList{K}(L:List{Expression}), Loc:Nat, T:Type)] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		< types >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ types >
		< typedefs >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	op initItem : K Nat Type -> K [metadata "strict(1)"] .
	mb [initArray]: rule
		< k > [initArray((Item:K,, Items:List{K}), Loc:Nat, T:Type) 
		=> initItem(Item:K, Loc:Nat, T:Type) ~> initArray(Items:List{K}, Loc:Nat, T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	mb [initArray-empty]: rule
		< k > [initArray(.List{K}, ?, ?) => .K] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [tv(N:Nat, ?) ~> initArray(Items:List{K}, Loc:Nat, T:Type) 
		=> initArray(Items:List{K}, Loc:Nat +Nat N:Nat, T:Type) ] ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > [initItem(tv(N:Nat, T:Type), Loc:Nat, T':Type) => putInMem(Loc:Nat, cast(T':Type, tv(N:Nat, T:Type)), T':Type, sizeofType(T':Type)) ~> sizeofType(T':Type)] ...</ k >
		: KSentence [metadata "structural"] .
			
	op struct-aux : Id K List{KResult} -> K .
	mb rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => struct-aux(X:Id, DS:TogetherList, .List{K}) ~> addGlobalTypes(X:Id)] ...</ k >
		< types >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ types >
		< typedefs >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct-aux(X:Id, (Field(T:TogetherList, D:Declarator) ~> K:K), L:List{KResult}) => Field(T:TogetherList, D:Declarator) ~> struct-aux(X:Id, K:K, L:List{KResult})] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [typedField(T:Type, X:Id) ~> struct-aux(X':Id, K:K, L:List{KResult}) => struct-aux(X':Id, K:K, (L:List{KResult},, typedField(T:Type, X:Id)))] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > ['Field(T:Type,, X:Id) => typedField(T:Type, X:Id)] ...</ k >
		: KSentence [metadata "structural"] .

	--- fixme gotta be a nicer way to do this
	mb rule
		< k > [struct-aux(X:Id, .K, L:List{KResult}) ~> addGlobalTypes(X:Id) => .K] ...</ k >
		< structs >... [.Map => struct(X:Id) |-> L:List{KResult}] ...</ structs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, pointerType(T:Type)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> pointerType(T:Type)] ...</ types >
		< typedefs >... [.Map => X:Id |-> pointerType(T:Type)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => X:Id |-> T:Base-Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Base-Type] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, arrayType(T:Type, N:Nat)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ types >
		< typedefs >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		: KSentence [metadata "structural"] .

endm

mod COMMON-LOCAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb rule
		< k > [addTypes(E:Expression, arrayType(T:Type, N:Nat)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, pointerType(T:Type)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, structType(X:Id)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> structType(X:Id)] ...</ types >
		: KSentence [metadata "structural"] .
	--- fixme?
	mb rule
		< k > [addTypes(E:Expression, functionType(T:Type, F:List{K})) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> functionType(T:Type, F:List{K})] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> T:Base-Type] ...</ types >
		: KSentence [metadata "structural"] .
		

	mb rule
		< k > [tv(N:Nat, ?) ~> addLocals(Loc:Nat) => .K] ...</ k >
		< locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat N:Nat))] ...</ locals >
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > [declare(T:Type, X:Id)
			=> addTypes(X:Id, T:Type) ~> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat)] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [allocate(tv(Len:Nat, ?)) => Len:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat Len:Nat] </ nextLoc >
		: KSentence [metadata "structural"] .

endm

mod COMMON-EXPRESSIONS is
	including COMMON-INCLUDE .

	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_+_(tv(I1:Int, cfg:sizeut),, '_*_(sizeofType(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if integerTypes contains T:Type
		andBool T':Type =/=Bool void
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_+_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if integerTypes contains T:Type
		: KSentence .
	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_-_(tv(I1:Int, cfg:sizeut),, '_*_(sizeofType(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_-_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if integerTypes contains T:Type
		: KSentence .
	--- fixme need to use defined type
	mb rule [tv(I1:Int, pointerType(T:Type)) - tv(I2:Int, pointerType(T:Type)) 
	=> tv(_-Int_(I1:Int, I2:Int), long-int)]
		: KSentence .
		
	--- fixme ignoring qualified types
	mb rule [cast(qualifiedType(T:Type, ?), V:Value) => cast(T:Type, V:Value)] 
		: KSentence .	
	
	--- fixme not sure which is correct
	mb rule [tv(I1:Rat, T:Type) + tv(I2:Rat, T:Type) => interpret(I1:Rat +Rat I2:Rat, T:Type)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [_-_(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) => cast(T:Type, _-Int_(I1:Int,I2:Int))] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) * tv(I2:Int, T:Type) => cast(T:Type, I1:Int *Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) / tv(I2:Int, T:Type) => cast(T:Type, I1:Int /Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) % tv(I2:Int, T:Type) => cast(T:Type, I1:Int %Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [-un tv(I1:Int, T:Type) => cast(T:Type, -Int_(I1:Int))] 
		if integerTypes contains T:Type
		: KSentence .
	
		
		
	mb rule [tv(I:Int, T:Type) >> tv(N:Nat, T':Type) => cast(T:Type, I:Int >>Int N:Nat)] 
		if integerTypes contains T:Type
		andBool integerTypes contains T':Type
		: KSentence .
	mb rule [tv(I:Int, T:Type) << tv(N:Nat, T':Type) => cast(T:Type, I:Int <<Int N:Nat)] 
		if integerTypes contains T:Type
		andBool integerTypes contains T':Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) | tv(I2:Int, T:Type) => cast(T:Type, I1:Int |Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) &binop tv(I2:Int, T:Type) => cast(T:Type, I1:Int &Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	--- fixme not exactly
	mb rule [~ tv(I:Int, T:Type) => cast(T:Type, ~Int I:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) ^ tv(I2:Int, T:Type) => cast(T:Type, I1:Int xorInt I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
		
	--- floats
	--- fixme
	mb rule [tv(F1:Float, T:Type) + tv(F2:Float, T:Type) => cast(T:Type, F1:Float +Float F2:Float)] 
		: KSentence .
	mb rule [_-_(tv(F1:Float, T:Type), tv(F2:Float, T:Type)) => cast(T:Type, _-Float_(F1:Float, F2:Float))] 
		: KSentence .
	mb rule [tv(F1:Float, T:Type) * tv(F2:Float, T:Type) => cast(T:Type, F1:Float *Float F2:Float)] 
		: KSentence .
	mb rule [tv(F1:Float, T:Type) / tv(F2:Float, T:Type) => cast(T:Type, F1:Float /Float F2:Float)] 
		: KSentence .
	--- --- mb rule [~ I:Int => ~Int I:Int] : KSentence .
	
	mb rule [tv(I1:Int, T:Type) < tv(I2:Int, T:Type) => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) <= tv(I2:Int, T:Type) => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) > tv(I2:Int, T:Type) => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) >= tv(I2:Int, T:Type) => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) == tv(I2:Int, T:Type) => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) != tv(I2:Int, T:Type) => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [!(tv(I:Int, T:Type)) => if (I:Int ==Bool 0) then tv(1, int) else tv(0, int) fi] : KSentence .
endm

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including SIZEOF .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-LOCAL-DECLARATION .
	including COMMON-C-STANDARD-LIBRARY .
	including COMMON-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	including TYPES .
	
	--- mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	--- fixme problem with strict operator and context?
	---op assign : K K -> K [metadata "strict 2"] .
	op assign : K K -> K .
	mb context &([HOLE] -> X:Id) : KSentence .
	mb context assign(Deref([HOLE]), ?) : KSentence .
	mb context assign(?, [HOLE]) : KSentence .

	op eval : Program -> Bag .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
		
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
		
	---c99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented.
***(
											Octal or Hexadecimal 
Suffix			Decimal Constant			Constant
------------------------------------------------------------------
none			int							int
				long int					unsigned int
				long long int				long int
											unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
u or U			unsigned int 				unsigned int
				unsigned long int 			unsigned long int
				unsigned long long int 		unsigned long long int
------------------------------------------------------------------
l or L			long int 					long int
				long long int 				unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long int 			unsigned long int
and l or L 		unsigned long long int 		unsigned long long int
------------------------------------------------------------------
ll or LL 		long long int				long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long long int 		unsigned long long int
and ll or LL
------------------------------------------------------------------
***)
	---c99 6.4.4.1:6 If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value. If all of the types in the list for the constant are signed, the extended integer type shall be signed. If all of the types in the list for the constant are unsigned, the extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.
	---c99 6.2.5:4 ... There may also be implementation-defined extended signed integer types. ...
	
	mb rule < k > [I:Int => 
		if ((I:Int <=Int max(int)) andBool (I:Int >=Int min(int))) then tv(I:Int, int) else
			if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
				if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		] ...</ k > 
		: KSentence .
		
	mb rule < k > [U(I:Int) => 
		if ((I:Int <=Int max(unsigned-int)) andBool (I:Int >=Int min(unsigned-int))) then tv(I:Int, unsigned-int) else
			if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
				if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [L(I:Int) => 
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
			if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [UL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
			if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [LL(I:Int) => 
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [ULL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
			tv(I:Int, no-type)
		fi
		] ...</ k > 
		: KSentence .
		
		
	---C99 6.4.4.2:4 An unsuffixed floating constant has type double. If suffixed by the letter f or F, it has type float. If suffixed by the letter l or L, it has type long double.
	mb rule < k > [F:Float => tv(F:Float, double)] ...</ k > 
		: KSentence .
	mb rule < k > [L(F:Float) => tv(F:Float, long-double)] ...</ k > 
		: KSentence .
	mb rule < k > [F(F:Float) => tv(F:Float, float)] ...</ k > 
		: KSentence .
		
	--- skip labels
	mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).
		
	
	---C99 6.5.3.2 (p79) footnote 90) Thus, &*E == E; &(E1[E2]) == (E1 + E2)
	
	---C99 6.5.3.2 90) ... It is always true that if E is a function designator or an lvalue that is a valid operand of the u of the unary & operator, *&E is a function designator or an lvalue equal to E.
	
	mb [for-assignment]: rule < k > [E1:Expression := E2:Expression => assign(Deref(&(E1:Expression)),  E2:Expression)] ...</ k > : KSentence .
	
	mb rule [&(Deref(E:Expression)) => E:Expression] : KSentence [metadata "structural"] .
	mb rule [&(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression] : KSentence [metadata "structural"] .
	
	--- can't be done anywhere because same syntax as in declarations
	mb rule < k > [E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression)] ...</ k > : KSentence [metadata "structural"] .
		
	---C99 6.5.3.2:4 The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
	--- also see 6.3.2.1:3 for why i made the result a pointerType
	mb rule < k > [Deref(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) => tv(Loc:Nat, pointerType(T:Type))] ...</ k > : KSentence [metadata "structural"] .

	mb [lookup-function] : rule 
		< k > [Deref(tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
	: KSentence [metadata "structural"] .
	
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
		
	--- remove empty global
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- fixme
	--- 6.5.16
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	mb [assign-mod]: rule [E1:Expression %= E2:Expression => E1:Expression := E1:Expression % E2:Expression] : KSentence .
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-lshift]: rule [E1:Expression <<= E2:Expression => E1:Expression := E1:Expression << E2:Expression] : KSentence .
	mb [assign-rshift]: rule [E1:Expression >>= E2:Expression => E1:Expression := E1:Expression >> E2:Expression] : KSentence .
	mb [assign-bit-and]: rule [E1:Expression &binop= E2:Expression => E1:Expression := E1:Expression &binop E2:Expression] : KSentence .
	mb [assign-bit-xor]: rule [E1:Expression ^= E2:Expression => E1:Expression := E1:Expression ^ E2:Expression] : KSentence .
	mb [assign-bit-or]: rule [E1:Expression |= E2:Expression => E1:Expression := E1:Expression | E2:Expression] : KSentence .
	
	----- end simple transformations -----

	op readFromMem : Nat Type K Nat Nat -> K [metadata "strict(3)"] .
	op readStructFromMem : Nat Type K List{K} -> K [metadata "strict(3)"] .
	op structVal : List{K} Type -> Value .
	
	--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => readFromMem(Loc:Nat, T:Base-Type, sizeofType(T:Base-Type), 0, 0)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> T:Base-Type ...</ types >
		: KSentence .
	mb [lookup-struct]: rule
		< k > [I:Id => readStructFromMem(Loc:Nat, structType(S:Id), sizeofType(structType(S:Id)), .List{K})] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> structType(S:Id) ...</ types >
		: KSentence .
	--- fixme not exactly
	mb rule
		< k > [readFromMem(Loc:Nat, T:Type, tv(0, ?), ?,  N:Nat) 
		=> interpret(N:Nat, T:Type)] ...</ k >
		: KSentence .
	--- fixme floats
	mb rule
		< k > [readFromMem(Loc:Nat, double, ?, ?, ?) => tv(V:Float, double)] ...</ k >
		< mem >... Loc:Nat |-> V:Float ...</ mem >
		: KSentence .
	mb rule
		< k > [readStructFromMem(Loc:Nat, T:Type, tv(0, ?), L:List{K}) 
		=> structVal(L:List{K}, T:Type)] ...</ k >
		: KSentence .

	mb rule [interpret(N:Nat, T:Type) => tv(N:Nat, T:Type)]
		if min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat
		andBool integerTypes contains T:Type
		: KSentence [metadata "structural"] .
	mb rule [interpret(N:Rat, T:Type) => tv(N:Rat, T:Type)]
		if min(T:Type) <=Rat N:Rat andBool max(T:Type) >=Rat N:Rat
		andBool integerTypes contains T:Type
		: KSentence [metadata "structural"] .
	mb rule [interpret(N:Nat, bitfieldType(T:Type, Len:Nat)) => tv(N:Nat, T:Type)]
		if 0 <=Int N:Nat 
		andBool _-Int_(2 ^Nat Len:Nat, 1) >=Int N:Nat
		: KSentence [metadata "structural"] .
		
	--- fixme not sure about this
	--- interpret is used to "cast" values read from memory
	--- signed arithmetic isn't supposed to overflow
	mb rule
		[interpret(N:Nat, T:Type) => tv(_-Int_(N:Nat, (2 ^Nat absInt(numBits(T:Type)))), T:Type)]
		if notBool(min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat)
		andBool (N:Nat >Int max(T:Type))
		andBool integerTypes contains T:Type
		: KSentence .
	
	--- fixme not necessarily the case that pointers are unsigned-ints
	mb rule [interpret(N:Nat, pointerType(T:Type)) => tv(N:Nat, pointerType(T:Type))]
		if min(unsigned-int) <=Int N:Nat andBool max(unsigned-int) >=Int N:Nat
		: KSentence [metadata "structural"] .
		
	mb [read-a-byte]: rule
		< k > [readFromMem(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), Len:Nat, N:Nat)
		=> readFromMem(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), sNat(Len:Nat), N:Nat |Nat (N':Nat <<Nat (8 *Nat Len:Nat)))] ...</ k >
		< mem >... Loc:Nat |-> N':Nat ...</ mem >
		: KSentence .

	mb rule
		< k > [readStructFromMem(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), L:List{K})
		=> readStructFromMem(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), (L:List{K},, K:K))] ...</ k >
		< mem >... Loc:Nat |-> K:K ...</ mem >
		: KSentence .
		
	mb [lookup-pointer]: rule
		< k > [I:Id => readFromMem(Loc:Nat, pointerType(T:Type), sizeofType(pointerType(T:Type)), 0, 0)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> pointerType(T:Type) ...</ types >
		: KSentence .
		
	---C99 6.3.2.1:3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
	mb rule
		< k > [X:Id => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> arrayType(T:Type, N:Nat) ...</ types >
		: KSentence .
		
	---C99 6.3.2.1:4 A function designator is an expression that has function type.  Except when it is the operand of the sizeof operator or the unary & operator, a function designator with type "function returning T" is converted to an expression that has type "pointer to a function returning T"
	mb [lookup-closure]: rule
		< k > [X:Id => tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> functionType(T:Type, L:List{K}) ...</ types >
		: KSentence .
				
	op allocString : String -> K .
	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [.K => allocString(S:String)] ~> S:String ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > M:Map [.Map => S:String |-> tv(Loc:Nat, arrayType(char, lengthString(S:String) +Nat 1))] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => tv(N:Nat, pointerType(T:Type))] ...</ k >
		< statics >... S:String |-> tv(N:Nat, arrayType(T:Type, ?)) ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> charToAscii(firstChar(S:String))] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> 0] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	
	mb [assign]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:Int, T:Type)) 
		=> putInMem(Loc:Nat, tv(V:Int, T:Type), T:Type, sizeofType(T:Type)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	mb [assign-bitfield]: rule
		< k > [assign(Deref(tv(pair(N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))), tv(V:Int, T:Type)) 
		=> putInMem(pair(N:Nat, O:Nat), tv(V:Int, T:Type), T:Type, tv(Len:Nat, cfg:sizeut)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	mb [assign-bitfield]: rule
		< k > [assign(Deref(tv(N:Nat, pointerType(bitfieldType(T:Type, Len:Nat)))), tv(V:Int, T:Type)) 
		=> putInMem(pair(N:Nat, 0), tv(V:Int, T:Type), T:Type, tv(Len:Nat, cfg:sizeut)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	--- fixme this is to get around L:List{K} not comparing equal
	mb [assign-fp]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(pointerType(functionType(T:Type, L:List{K}))))), tv(V:Int, pointerType(functionType(T:Type, L':List{K})))) 
		=> putInMem(Loc:Nat, tv(V:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L:List{K})), sizeofType(pointerType(functionType(T:Type, L:List{K})))) ~> tv(V:Int, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		: KSentence .
		
	--- fixme floats might have requirements
	mb [assign-float]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(double))), tv(V:Float, double)) 
		=> tv(V:Float, double)] ...</ k >
		< mem > [M:Map => M:Map[V:Float / Loc:Nat]] </ mem > 
		: KSentence .
		
	op assertEqual : K K -> K [metadata "strict"] .
	mb [assign-struct]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), structVal(L:List{K},T:Type))
		=> 
		---assertEqual(sizeof(T:Type), length(L:List{K})) ~> 
		putBytesInMem(Loc:Nat, L:List{K}, T:Type, sizeofType(T:Type)) ~> structVal(L:List{K},T:Type)] ...</ k >
		: KSentence	.
	
	mb rule
		< k > [putBytesInMem(Loc:Nat, (K:K,, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(sNat(Loc:Nat), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		< mem >... Loc:Nat |-> [? => K:K] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBytesInMem(Loc:Nat, .List{K}, T:Type, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	
	op putByteInMem : Nat BaseValue -> K .
	op putBitInMem : BaseValue BaseValue -> K .
	mb rule
		< k > [putInMem(?, ?, ?, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		=> putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putByteInMem(Loc:Nat, ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(sNat(Loc:Nat), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		: KSentence .
		
	mb rule
		< k > [putInMem(pair(Base:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putBitInMem(pair(Base:Nat, Offset:Nat), ((N:Int %Int 2) +Int 2) %Int 2) ~> putInMem(pair(Base:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 1, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		if Offset:Nat % 8 =/=Bool 0
		: KSentence .
		
	mb rule
		< k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		< mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		: KSentence .
	--- fixme probably a better way to do this
	mb rule
		< k > putBitInMem(pair(Base:Nat, ?), ?) ...</ k >
		< mem >... Base:Nat |-> [unknown => 0] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBitInMem(pair(Base:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		< mem >... Base:Nat |-> [Old:Nat => 
		(Old:Nat &Nat ((1 <<Nat Offset:Nat) xorNat 255)) |Nat (N:Nat <<Nat Offset:Nat)
		] ...</ mem >
		: KSentence .

	mb [ref]: rule
		< k > [&(X:Id) => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		: KSentence .
		
	--- fixme this is crazy
	--- if label not arrayType?
	op fixPointerType : Type -> Type .
	eq fixPointerType(T:Base-Type) = pointerType(T:Base-Type) .
	eq fixPointerType(arrayType(T:Type, ?)) = pointerType(T:Type) .
	eq fixPointerType(structType(X:Id)) = pointerType(structType(X:Id)) .
	eq fixPointerType(pointerType(T:Type)) = pointerType(pointerType(T:Type)) .
	eq fixPointerType(bitfieldType(T:Type, N:Nat)) = pointerType(bitfieldType(T:Type, N:Nat)) .
	eq fixPointerType(bitfieldType(T:Type, N:Nat)) = pointerType(bitfieldType(T:Type, N:Nat)) .
	
	op figureOffset : Nat K Type -> K [metadata "strict(2)"] .
	op pair : Rat Rat -> BaseValue .
	ceq figureOffset(Base:Nat, tv(R:Rat, ?), T:Type) = tv(pair(Base:Nat +Rat truncRat(R:Rat),_-Rat_(R:Rat, truncRat(R:Rat)) *Rat 8), pointerType(void))
	if T:Type isa 'bitfieldType .
	ceq figureOffset(Base:Nat, tv(R:Rat, ?), T:Type) = tv(truncRat((Base:Nat +Rat R:Rat) +Rat (7 /Rat 8)), pointerType(void))
	if notBool(T:Type isa 'bitfieldType) .

	mb [address-of-arrow]: rule
		< k > [&(tv(Base:Nat, pointerType(structType(S:Id))) -> X:Id) => cast(fixPointerType(T:Type), figureOffset(Base:Nat, calcStructSize-aux(L1:List{KResult}, 0), T:Type))] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
		
	mb [address-of-dot]: rule
		< k > [&(E:Expression . X:Id) => &((&(E:Expression)) -> X:Id)] ...</ k >
		: KSentence .
	
	mb [arrow]: rule
		< k > [tv(Base:Int, pointerType(structType(S:Id))) -> X:Id => Deref(tv(Base:Int, pointerType(structType(S:Id)))) . X:Id] ...</ k >
		: KSentence .

	op extractField : List{K} Type K K Nat Rat -> K [metadata "strict(3 4)"] .
	
	op dot-aux : K Id K -> K [metadata "strict(3)"] .
	mb rule
		< k > [(E:Expression . F:Id) => dot-aux(E:Expression, F:Id, typeof(E:Expression . F:Id))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, arrayType(?, ?)) => &(E:Expression . F:Id)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, T:Base-Type) => E:Expression ~> dot-aux(HOLE, F:Id, T:Base-Type)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, pointerType(T:Type)) => E:Expression ~> dot-aux(HOLE, F:Id, pointerType(T:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, bitfieldType(T:Type, N:Nat)) => E:Expression ~> dot-aux(HOLE, F:Id, bitfieldType(T:Type, N:Nat))] ...</ k >
		: KSentence .
		
	mb rule
		< k > [structVal(L:List{K}, structType(S:Id)) ~> dot-aux(HOLE, F:Id, T:Type) => extractField(L:List{K}, T:Type, sizeofType(T:Type), figureOffset(0, calcStructSize-aux(L1:List{KResult}, 0), T:Type), 0, 0)] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, F:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .		
	
	--- only have to make T' =/= T'' because of figureOffset
	mb [extractField-shift-bitfield]: rule
		< k > [extractField((K:K,, L:List{K}), T:Type, V:Value, tv(pair(sNat(Base:Nat), Offset:Nat), T':Type), 0, 0) => extractField(L:List{K}, T:Type, V:Value, tv(pair(Base:Nat, Offset:Nat), T':Type), 0, 0)] ...</ k >
		: KSentence .
	mb [extractField-shift-bitfield-combine]: rule
		< k > [extractField((L:List{K},, N:Nat,, N':Nat), T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), 0, 0) => extractField((L:List{K},, (N':Nat <<Nat 8) |Nat N:Nat), T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), 0, 0)] ...</ k >
		: KSentence .
	mb [extractField-shift-bitfield-offset]: rule
		< k > [extractField(N':Nat, T:Type, V:Value, tv(pair(0, sNat(Offset:Nat)), T':Type), 0, 0) => extractField(N':Nat >>Nat 1, T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), 0, 0)] ...</ k >
		: KSentence .
	mb [extractField-shift]: rule
		< k > [extractField((K:K,, L:List{K}), T:Type, V:Value, tv(sNat(Offset:Nat), T':Type), 0, 0) => extractField(L:List{K}, T:Type, V:Value, tv(Offset:Nat, T':Type), 0, 0)] ...</ k >
		: KSentence .
		
	mb [extractField-grab-normal]: rule
		< k > [extractField((N':Nat,, L:List{K}), T:Type, tv(sNat(Left:Nat), T':Type), tv(0, T'':Type), N:Nat, Len:Nat) 
		=> extractField(L:List{K}, T:Type, tv(Left:Nat, T':Type), tv(0, T'':Type), N:Nat |Nat (N':Nat <<Nat (8 *Nat Len:Nat)), sNat(Len:Nat))]
		...</ k > : KSentence .
	mb [extractField-grab-bitfield]: rule
		< k > [extractField(N':Nat, T:Type, tv(Left:Rat, T':Type), tv(pair(0, 0), T'':Type), N:Nat, Len:Rat) 
		=> extractField((N':Nat >>Nat 1), T:Type, tv(_-Rat_(Left:Rat, 1 /Rat 8), T':Type), tv(0, T'':Type), N:Nat |Nat ((N':Nat &Nat 1) <<Nat absInt(truncRat(8 *Rat Len:Rat))), Len:Rat +Rat (1 /Rat 8))] ...</ k > 
		if Left:Rat =/=Bool 0
		andBool (8 *Rat Len:Rat) ==Bool truncRat(8 *Rat Len:Rat)
		: KSentence .
	
	mb [extractField-done]: rule
		< k > [extractField(?, T:Type, tv(0, T':Type), tv(0, T'':Type), N:Nat, ?) => interpret(N:Nat, T:Type)]
		...</ k >
		: KSentence .
		
	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
		
  	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
  
	mb [function-application-pre]: rule
		< k > [Apply(tv(Loc:Nat, pointerType(functionType(?, ?))), L:List{Expression}) 
		=> Apply(V:Value, L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [function-application]: rule
		< k > [
			Apply(Closure(X:Id, functionType(R:Type, P:List{K}), B:K), L:List{Expression}) ~> K:K 
			=> 
			bind(getList{K}(L:List{Expression}), P:List{K}) ~> B:K
		] </ k >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< types > [T:Map => GT:Map] </ types >
		< typedefs > GT:Map </ typedefs >
		< loopStack > [LS:List => .List] </ loopStack >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
				< types > T:Map </ types >
				< loopStack > LS:List </ loopStack >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	
	mb [deref]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Base-Type))) 
		=> readFromMem(Loc:Nat, T:Base-Type, sizeofType(T:Base-Type), 0, 0)
		] ...</ k >
		: KSentence .
	mb [deref-pointer]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))) 
		=> readFromMem(Loc:Nat, pointerType(T:Type), sizeofType(pointerType(T:Type)), 0, 0)
		] ...</ k >
		: KSentence .
	mb [deref-struct]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(structType(X:Id)))) 
		=> readStructFromMem(Loc:Nat, structType(X:Id), sizeofType(structType(X:Id)), .List{K})
		] ...</ k >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement else S':Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (tv(0, ?)) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (tv(0, ?)) S:Statement => .K] ...</ k >
		: KSentence .


	eq integerTypes = Set(char,, signed-char,, unsigned-char,, short-int,, int,, long-int,, long-long-int,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	eq unsignedIntegerTypes = Set(unsigned-char,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	
	mb rule [Cast(T:TogetherList, E:Expression) => cast(T:TogetherList, E:Expression)] : KSentence [metadata "structural rule"] .
	
	mb rule
		< k > [cast(T:Type, tv(B:BaseValue, T:Type)) => tv(B:BaseValue, T:Type)] ...</ k > 
		: KSentence .
	
	---c99 6.3.1.3:1 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged. 
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => tv(I:Int, T:Type)] ...</ k > 
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int 
		andBool (integerTypes contains T':Type)
		andBool (integerTypes contains T:Type)
		: KSentence .
		
	---c99 6.3.1.3:2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int +Int max(T:Type) +Int 1, T':Type))] ...</ k > 
		if notBool(min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int andBool (integerTypes contains T':Type))
		andBool unsignedIntegerTypes contains T:Type 
		andBool I:Int <Int min(T:Type)
		andBool integerTypes contains T':Type
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int %Int (max(T:Type) +Int 1), T':Type))] ...</ k > 
		if notBool(min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int andBool (integerTypes contains T':Type))
		andBool unsignedIntegerTypes contains T:Type 
		andBool I:Int >Int max(T:Type)
		andBool integerTypes contains T':Type
		: KSentence .
	
	---c99 6.3.1.3:3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.
	
	---C99 6.3.1.4:1 When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.52) The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (-1, Utype_MAX+1).
	--- fixme
	mb rule
		< k > [cast(T:Type, tv(V:Float, double)) => cast(T:Type, tv(truncRat(float2ratConversion(V:Float)), long-long-int))] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
	
	---C99 6.3.1.4:2 When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined.
	--- fixme not handling floats correctly
	mb rule
		< k > [cast(double, tv(I:Int, T:Type)) => tv(rat2floatConversion(I:Int), double)] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
	
	--- fixme 6.3.2.3 not handling this correctly
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, T':Type)) => tv(I:Int, pointerType(T:Type))] ...</ k >
		if min(unsigned-int) <=Int I:Int andBool max(unsigned-int) >=Int I:Int andBool (integerTypes contains T':Type)
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(T':Type))) => cast(T:Type, tv(I:Int, unsigned-int))] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
		
	--- fixme not sure where it says this
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, arrayType(T:Type, ?))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, pointerType(void))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(void), tv(I:Int, pointerType(T:Type))) => tv(I:Int, pointerType(void))] ...</ k > 
		: KSentence .
	--- possibly not true with other endiannesses
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, pointerType(?))) => tv(I:Int, pointerType(T:Type))] ...</ k >
		if min(unsigned-int) <=Int I:Int andBool max(unsigned-int) >=Int I:Int
		: KSentence .
	--- fixme not sure about this either...
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(arrayType(T':Type, ?)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		: KSentence .
	--- fixme ridiculous.
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(structType(S:Id)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		< structs >... struct(S:Id) |-> (typedField(T':Type, ?),, ?:List{KResult}) ...</ structs >
		: KSentence .
		
	mb rule
		< k > [cast(pointerType(bitfieldType(T:Type, Len:Nat)), tv(pair(N:Nat, O:Nat), pointerType(?)))
		=> tv(pair(N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))] ...</ k > 
		: KSentence .
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(popLoop, K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K] </ k >
		< loopStack > ListItem(K:K) ...</ loopStack >
		: KSentence .

	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	op postInc : K K Type -> K [metadata "strict(2)"] .
	op postDec : K K Type -> K [metadata "strict(2)"] .
	mb [post-increment-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) ++
		=> postInc(Loc:Nat, readFromMem(Loc:Nat, T:Type, sizeofType(T:Type), 0, 0), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) + tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if integerTypes contains T:Type
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) + tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .
		
	mb [post-decrement-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) --
		=> postDec(Loc:Nat, readFromMem(Loc:Nat, T:Type, sizeofType(T:Type), 0, 0), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) - tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if integerTypes contains T:Type
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) - tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .

	mb [discard]: rule
		< k > [V:Value ~> discard => .K] ...</ k >
		: KSentence .
	
	mb context 'switch`(_`)_(?,, 'Block(? ~> 'case_:_(`[HOLE`]:K,, ?) ~> ?)) : KSentence .

	mb [switch]: rule
		< k > ['switch`(_`)_(V:Value,, 'Block(? ~> 'case_:_(V:Value,, K1:K) ~> K2:K)) => K1:K ~> K2:K ~> popLoop] ~> K:K </ k >
		< loopStack > [.List => ListItem(_~>_(popLoop, K:K))] ...</ loopStack >
		: KSentence .
		
endm


