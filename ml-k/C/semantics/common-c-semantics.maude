--- not evaluating inside initializers
mod COMMON-INCLUDE is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
	
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult . 
	op closure : -> KLabel .
	sort Value .
	sort Type . 
	subsort Struct-Or-Union-Specifier < Value .
	subsort Int < Value < Expression KResult .
	subsort TogetherList < Type < Expression < K .
	
	op Closure : Function-Definition -> Value .
	
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence .
		
	op _to_ : Nat Nat -> List{K} .  
	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
		
	op calcStructSize : SeqList -> K .
	mb [calcStructSize-int]: rule
		< k > ['calcStructSize(Field(TD:Type-Specifier, D:Declarator) ~> DS:SeqList) 
			=> '_+_(sizeof(TD:Type-Specifier),, calcStructSize(DS:SeqList))] ...</ k >
		: KSentence .
	mb [calcStructSize-done]: rule
		['calcStructSize(.K) => 0]
		: KSentence .	
endm

------------------------------------------------
---- C standard library
mod COMMON-C-STANDARD-LIBRARY is
	including COMMON-INCLUDE .
	
	op builtin : Id -> Value .
	--------------------------------------------
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), N:Nat) => Loc:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [rand-is-value]: rule
		< k > [rand => builtin(rand)] ...</ k >
	: KSentence .
	mb [rand]: rule
		< k > [Apply(builtin(rand), .List{Expression}) => randomRandom(Loc:Nat)] ...</ k >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [free-is-value]: rule
		< k > [free => builtin(free)] ...</ k >
	: KSentence .
	
	mb [free]: rule
		< k > [Apply(builtin(free), Loc:Nat) => Apply(builtin(free), sNat(Loc:Nat))] ...</ k >
		< mem >...  [Loc:Nat |-> ? => .Map] ...</ mem >
		< malloced >... [Loc:Nat |-> sNat(N:Nat) => sNat(Loc:Nat) |-> N:Nat] ...</ malloced >
	: KSentence .
	mb [free-done]: rule
		< k > [Apply(builtin(free), Loc:Nat) => skipval] ...</ k >
		< malloced >... [Loc:Nat |-> 0 => .Map] ...</ malloced >
	: KSentence .
	--------------------------------------------
	mb [calloc-is-value]: rule
		< k > [calloc => builtin(calloc)] ...</ k >
	: KSentence .
	
	--- ignoring size for now
	--- fixme
	mb [calloc]: rule
		< k > [Apply(builtin(calloc), (N:Nat .,. Size:Nat)) => Loc:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> 0] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [memset-is-value]: rule
		< k > [memset => builtin(memset)] ...</ k >
	: KSentence .
	
	mb [memset]: rule
		< k > [Apply(builtin(memset), (Loc:Nat .,. N:Nat .,. Len:Nat)) => Loc:Nat] ...</ k >
		< mem > [M:Map => M:Map[N:Nat / Loc:Nat to (Loc:Nat +Nat Len:Nat)]] </ mem >
	: KSentence .
	--------------------------------------------
	mb [strlen-is-value]: rule
		< k > [strlen => builtin(strlen)] ...</ k >
	: KSentence .
	
	op strlen-aux : Nat Nat -> K .
	mb [strlen-start]: rule
		< k > [Apply(builtin(strlen), Loc:Nat) => strlen-aux(0, Loc:Nat)] ...</ k >
	: KSentence .
	
	mb [strlen-nz]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => strlen-aux(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strlen-z]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcpy-is-value]: rule
		< k > [strcpy => builtin(strcpy)] ...</ k >
	: KSentence .
	
	op strcpy-aux : Nat Nat Nat -> K .
	mb [strcpy-start]: rule
		< k > [Apply(builtin(strcpy), (Dest:Nat .,. Src:Nat)) => strcpy-aux(Src:Nat, Dest:Nat, Dest:Nat)] ...</ k >
	: KSentence .
	
	mb [strcpy-nz]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => strcpy-aux(sNat(Src:Nat), sNat(Dest:Nat), Orig:Nat)] ...</ k >
		< mem >... Src:Nat |-> N:Nat Dest:Nat |-> [? => N:Nat] ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strcpy-z]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => Orig:Nat] ...</ k >
		< mem >... Src:Nat |-> 0 Dest:Nat |-> [? => 0] ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcmp-is-value]: rule
		< k > [strcmp => builtin(strcmp)] ...</ k >
	: KSentence .
	
	op strcmp-aux : Nat Nat -> K .
	mb [strcmp-start]: rule
		< k > [Apply(builtin(strcmp), (Loc1:Nat .,. Loc2:Nat)) => strcmp-aux(Loc1:Nat, Loc2:Nat)] ...</ k >
	: KSentence .
	
	mb [strcmp-same-addy]: rule
		< k > [strcmp-aux(Loc:Nat, Loc:Nat) => 0] ...</ k >
		: KSentence .
	mb [strcmp-same]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => strcmp-aux(sNat(Loc1:Nat), sNat(Loc2:Nat))] ...</ k >
		< mem >... Loc1:Nat |-> N:Nat Loc2:Nat |-> N:Nat ...</ mem >
		if N:Nat =/=Bool 0
		: KSentence .
	mb [strcmp-done]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => 0] ...</ k >
		< mem >... Loc1:Nat |-> 0 Loc2:Nat |-> 0 ...</ mem >
		: KSentence .
	mb [strcmp-different]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => if N1:Nat >Nat N2:Nat then 1 else -1 fi] ...</ k >
		< mem >... Loc1:Nat |-> N1:Nat Loc2:Nat |-> N2:Nat ...</ mem >
		if N1:Nat =/=Bool N2:Nat
		: KSentence .
	--------------------------------------------
	mb [putchar-is-value]: rule
		< k > [putchar => builtin(putchar)] ...</ k >
	: KSentence .
	mb [putchar]: rule
		< k > [Apply(builtin(putchar), (N:Nat)) => N:Nat] ...</ k >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
	: KSentence .
	--------------------------------------------
	mb [printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [printf-start]: rule
		< k > [Apply(builtin(printf), (Loc:Nat .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
		if notBool(N:Nat ==Bool asciiString("%")) 
		andBool notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	mb [printf-null]: rule
		< k > [printf-aux(0, 0, .List{Expression}) => 6] ...</ k >
		< output > [S:String => S:String +String "(null)"] </ output >
	: KSentence .
	
	mb [printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	mb [printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (D:Int .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Int, 10)] </ output >
		if N:Nat ==Bool asciiString("d") 
	: KSentence .
	mb [printf-%s]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (S:Nat .,. L:List{Expression})) => 
			printf-aux(0, S:Nat, .List{Expression})
			~> printf-aux(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat ==Bool asciiString("s") 
	: KSentence .

	mb [printf-%s-done]: rule
		< k > [Len':Nat ~> printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => 
			printf-aux(Len:Nat +Nat Len':Nat, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .
	op bind : -> KLabel .

		
	--- empty binding
	mb [bind-empty-void]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(Parameter-Declaration(void))) => .K] ...</ k > 
		: KSentence .
	mb [bind-empty]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(.List{Parameter})) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	mb [bind-one-int]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(int, I:Id) ,., P:List{Parameter})) =>
			bind((.List{Expression} .,. L:List{Expression}),, 
				Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(int, I:Id))] ...</ parameters >
		< types >... [.Map => I:Id |-> int] ...</ types >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [bind-one-int-pointer]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id) ,., P:List{Parameter})) =>
			bind((.List{Expression} .,. L:List{Expression}),, 
				Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id))] ...</ parameters >
		< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [bind-one-func-pointer]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter}))) ,., P:List{Parameter})) =>
			bind((.List{Expression} .,. L:List{Expression}),, 
				Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter}))))] ...</ parameters >
		---< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
		
	mb [bind-one-typedef]: rule 
		< k > [bind(L:List{Expression},, 
				Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter})) =>
			bind(L:List{Expression},, 
				Parameter-Type-List(Parameter-Declaration(T':Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter}))]
				...</ k > 
		< typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		: KSentence .
		
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .
	mb [global-variable-declaration]: rule
		< k > [Global(Declaration(int, I:Id)) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> int] ...</ types >
		: KSentence .
	mb [global-pointer-declaration]: rule
		< k > [Global(Declaration(Pointer(T:Type-Specifier), I:Id)) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		: KSentence .
	mb [global-func-pointer-declaration]: rule
		< k > [Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)] ...</ types >
		: KSentence .	
		
	mb [global-variable-declaration-init]: rule
		< k > [Declaration(int, I:Id) = E:Expression => Global(Declaration(int, I:Id)) ~> Deref(&(I:Id)) := E:Expression ;] ...</ k >
		: KSentence .
	mb [global-pointer-declaration-init]: rule
		< k > [Declaration(Pointer(T:Type-Specifier), I:Id) = E:Expression => Global(Declaration(Pointer(T:Type-Specifier), I:Id)) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		: KSentence .
		
	mb [global-func-pointer-declaration-init]: rule
		< k > [Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)) = E:Expression => Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		: KSentence .
		
	mb [function-prototype]: rule 
		< k > [Global(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List))) => .K] ...</ k >
		: KSentence .
	mb [typedef-declaration]: rule
		< k > [Global(Typedef(DS:TogetherList, X:Typedef-Name)) => .K] ...</ k >
		< typedefs >... [.Map => X:Typedef-Name |-> DS:TogetherList] ...</ typedefs >
		: KSentence .
		
			
	mb [global-array-declaration-init]: rule
		< k > [Declaration(T:Type-Specifier, X:Id[N:Nat]) = { L:List{Expression} } => .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat N:Nat) |-> getList{K}(L:List{Expression})] ...</ mem >
		< nextLoc > [Loc:Nat => (sNat(Loc:Nat) +Nat N:Nat)] </ nextLoc >
		< types >... [.Map => X:Id |-> T:Type-Specifier[N:Nat]] ...</ types >
		: KSentence .
endm

mod COMMON-LOCAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb [declaration-using-typedef]: rule
		< k > ['Declaration(Kp:KProper,, I:Id) => Declaration(T':Type-Specifier, I:Id)] ...</ k >
		< typedefs >... Kp:KProper |-> T':Type-Specifier ...</ typedefs >
		: KSentence .
		
	mb [variable-declaration]: rule
		< k > [Declaration(int, I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> int] ...</ types >
		: KSentence .
	mb [pointer-declaration]: rule
		< k > [Declaration(Pointer(T:Type-Specifier), I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(Pointer(T:Type-Specifier), I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		: KSentence .
	mb [array-declaration]: rule
		< k > [Declaration(T:Type-Specifier, X:Id[N:Nat]) => .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat N:Nat) |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(T:Type-Specifier, X:Id[N:Nat]))] ...</ locals >
		< nextLoc > [Loc:Nat => (sNat(Loc:Nat) +Nat N:Nat)] </ nextLoc >
		< types >... [.Map => X:Id |-> T:Type-Specifier[N:Nat]] ...</ types >
		: KSentence .
	mb [local-struct-declaration-start]: rule
		< k > [Declaration(struct(X:Id), X':Id) => calcStructSize(DS:TogetherList) ~> Declaration(struct(X:Id), X':Id)] ...</ k >
		< typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		: KSentence .

	op struct-aux : Id Id Nat -> K .
	mb [local-struct-declaration]: rule
		< k > [Len:Nat ~> Declaration(struct(X:Id), X':Id) => .K] ...</ k >
		< env >... [.Map => X':Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(struct-aux(X:Id, X':Id, Len:Nat))] ...</ locals >
		< nextLoc > [Loc:Nat => (Loc:Nat +Nat Len:Nat)] </ nextLoc >
		< types >... [.Map => X':Id |-> struct(X:Id)] ...</ types >
		< typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		: KSentence .
	mb [struct-declaration]: rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => .K] ...</ k >
		< typedefs >... [.Map => struct(X:Id) |-> struct(X:Id, DS:TogetherList)] ...</ typedefs >
		: KSentence .

endm

mod COMMON-EXPRESSIONS is
	including COMMON-INCLUDE .

	mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [- I => -Int I] : KSentence .
	mb rule [I1:Int < I2:Int => if (I1:Int <Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int <= I2:Int => if (I1:Int <=Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int > I2:Int => if (I1:Int >Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int >= I2:Int => if (I1:Int >=Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int == I2:Int => if (I1:Int ==Bool I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int != I2:Int => if (I1:Int =/=Bool I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	mb rule [!(I:Int) => if (I:Int ==Bool 0) then 1 else 0 fi] : KSentence .
	
	mb rule [I:Int >> N:Nat => I:Int >>Int N:Nat] : KSentence .
	mb rule [I:Int << N:Nat => I:Int <<Int N:Nat] : KSentence .
	mb rule [I1:Int | I2:Int => I1:Int |Int I2:Int] : KSentence .
	mb rule [_&_(I1:Int, I2:Int) => I1:Int &Int I2:Int] : KSentence .
	mb rule [~ I:Int => ~Int I:Int] : KSentence .

	
endm

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-LOCAL-DECLARATION .
	including COMMON-C-STANDARD-LIBRARY .
	including COMMON-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	
	mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	

	op eval : Program -> Bag .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
		
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
	--- we're ignoring types for now
	mb rule [U(I:Int) => I:Int] : KSentence [metadata "structural"] .
	mb rule [UL(I:Int) => I:Int] : KSentence [metadata "structural"] .
	mb rule [unsigned-int => int] : KSentence [metadata "structural"] .
	mb rule [unsigned-char => int] : KSentence [metadata "structural"] .
	mb rule [char => int] : KSentence [metadata "structural"] .
	
	--- skip labels
	mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).
	
	--- turn variables into references when appropriate
	mb [make-assign-ref]: rule < k > [I:Id := E:Expression => Deref(&(I:Id)) := E:Expression] ...</ k > : KSentence .
	mb [make-assign-arrow-ref]: rule < k > [(E1:Expression -> X:Id) := E2:Expression => Deref(&(E1:Expression -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	mb [make-assign-arrow-ref]: rule < k > [(E1:Expression . X:Id) := E2:Expression => Deref(&((& E1:Expression) -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	mb [make-call-ref]: rule < k > [Apply(I:Id, L:List{Expression}) => Apply(Deref(&(I:Id)), L:List{Expression})] ...</ k > : KSentence .
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
	mb [array-revision]: rule < k > [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] ...</ k > : KSentence .
	mb [make-assign-array-ref]: rule < k > [ E1:Expression[E2:Expression] := E:Expression => Deref(E1:Expression + E2:Expression) := E:Expression] ...</ k > : KSentence .
	
	--- remove empty global
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- fixme
	--- 6.5.16
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	mb [assign-mod]: rule [E1:Expression %= E2:Expression => E1:Expression := E1:Expression % E2:Expression] : KSentence .
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-lshift]: rule [E1:Expression <<= E2:Expression => E1:Expression := E1:Expression << E2:Expression] : KSentence .
	mb [assign-rshift]: rule [E1:Expression >>= E2:Expression => E1:Expression := E1:Expression >> E2:Expression] : KSentence .
	mb [assign-bit-and]: rule [E1:Expression &= E2:Expression => E1:Expression := _&_(E1:Expression,  E2:Expression)] : KSentence .
	mb [assign-bit-xor]: rule [E1:Expression ^= E2:Expression => E1:Expression := E1:Expression ^ E2:Expression] : KSentence .
	mb [assign-bit-or]: rule [E1:Expression |= E2:Expression => E1:Expression := E1:Expression | E2:Expression] : KSentence .
	
	--- move "Pointer" to where it belongs
	mb rule 
		[Declaration(DS:TogetherList, Pointer(DFD:Direct-Declarator)) => Declaration(Pointer(DS:TogetherList), DFD:Direct-Declarator)]
		: KSentence [metadata "structural"] .
	mb rule 
		[Parameter-Declaration(DS:TogetherList, Pointer(DFD:Direct-Declarator)) => Parameter-Declaration(Pointer(DS:TogetherList), DFD:Direct-Declarator)]
		: KSentence [metadata "structural"] .
	mb rule 
		[Field(T:TogetherList, Pointer(D:Direct-Declarator)) => Field(Pointer(T:TogetherList), D:Direct-Declarator)]  
		: KSentence [metadata "structural"] .
	----- end simple transformations -----

		--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => V:Value] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	op allocString : String -> K .

	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [S:String => allocString(S:String) ~> Loc:Nat] ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > [M:Map => M:Map[Loc:Nat / S:String]] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => Loc:Nat] ...</ k >
		< statics >... S:String |-> Loc:Nat ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> charToAscii(firstChar(S:String))] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> 0] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .

	mb [assign]: rule
		< k > [Deref(Loc:Nat) := V:Value => V:Value] ...</ k >
		< mem >... Loc:Nat |-> [? => V:Value] ...</ mem >
		---if N:Nat <Int 1000000000
		: KSentence .
	--- mb [assign]: rule
		--- < k > [Deref(Loc:Nat) := N:Nat => N:Nat] ...</ k >
		--- < mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		--- ---if N:Nat <Int 1000000000
		--- : KSentence .
		
	mb [equality]: rule
		< k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		: KSentence .
		
		
	---op evalDesignator : Expression -> K .
	
	mb [ref]: rule
		< k > [&(I:Id) => Loc:Nat] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		: KSentence .
	
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(E1:Expression + getOffset(E1:Expression, X:Id))] ...</ k >
		--- : KSentence .
	mb [arrow]: rule
		< k > [E1:Expression -> X:Id => Deref(& (E1:Expression -> X:Id))] ...</ k >
		: KSentence .
	mb [dot]: rule
		< k > [E1:Expression . X:Id => (& E1:Expression) -> X:Id] ...</ k >
		: KSentence .
		
	op getOffset : K K -> Expression .
	mb [ref-arrow]: rule
		< k > [&(E1:Expression -> X:Id) => E1:Expression + getOffset(Deref(E1:Expression), X:Id)] ...</ k >
		: KSentence .
	mb [ref-dot]: rule
		< k > [&(E1:Expression . X:Id) => (& (E1:Expression)) + getOffset(E1:Expression, X:Id)] ...</ k >
		: KSentence .
		
	op evalToType : -> K .
	op HOLE : -> Expression .
	
	mb [getOffset-heat]: rule
		< k > [getOffset(E:Expression, X:Id) => evalToType ~> getOffset(HOLE, X:Id)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .

	mb [getOffset-cool]: rule
		< k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		[< type > struct(X:Id) </ type > => .Bag]
		< typedefs >... struct(X:Id) |-> 'struct(X:Id,, (Fields1:SeqList ~> Field(T:TogetherList, X':Id) ~>  Fields2:SeqList)) ...</ typedefs >
		: KSentence .
	mb [getOffset-cool-func-pointer]: rule
		< k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		[< type > struct(X:Id) </ type > => .Bag]
		< typedefs >... struct(X:Id) |-> 'struct(X:Id,, (Fields1:SeqList ~> Field(T:TogetherList, Direct-Function-Declarator(Pointer(X':Id), PTL:Parameter-Type-List)) ~>  Fields2:SeqList)) ...</ typedefs >
		: KSentence .
		
	
	mb rule < type > [Deref(& E:Expression) => E:Expression] ...</ type > : KSentence [metadata "structural"] .
	mb rule < type > [Deref(Pointer(T:TogetherList)) => T:TogetherList] ...</ type > : KSentence [metadata "structural"] .
	
	mb [evalToType-exp-to-type]: rule
		< type > [E:Expression => T:Type] ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence .
	mb [deref-heat]: rule
		< type > ['Deref(Kp:KProper) => Kp:KProper ~> 'Deref(HOLE)] ...</ type >
		: KSentence .
	mb [deref-cool]: rule
		< type > [Kr:KResult ~> 'Deref(HOLE) => 'Deref(Kr:KResult)] ...</ type >
		: KSentence .
	mb [pointer-heat]: rule
		< type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		: KSentence .
	mb [pointer-cool]: rule
		< type > [Kr:KResult ~> 'Pointer(HOLE) => 'Pointer(Kr:KResult)] ...</ type >
		: KSentence .
	mb [dot-heat]: rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence .
	mb [dot-cool]: rule
		< type > [Kr:KResult ~> '_._(HOLE,, X:Id) => '_._(Kr:KResult,, X:Id)] ...</ type >
		: KSentence .
	mb [dot-lookup]: rule
		< type > ['_._(struct(SName:Id),, FName:Id) => T:TogetherList] ...</ type >
		< typedefs >... struct(SName:Id) |-> 'struct(SName:Id,, (Fields1:SeqList ~> Field(T:TogetherList, FName:Id) ~>  Fields2:SeqList)) ...</ typedefs >
		: KSentence .
	mb [typedef-lookup]: rule
		< type > [Kp:KProper => T:Type] ...</ type >
		< typedefs >... Kp:KProper |-> T:Type ...</ typedefs >
		: KSentence .
	
	mb [deref]: rule
		< k > [Deref(Loc:Nat) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (I:Int) S:Statement else S':Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (0) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (I:Int) S:Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (0) S:Statement => .K] ...</ k >
		: KSentence .
		
	--- throwing away casts now
	mb [cast-int]: rule
		[Cast(int, I:Int) => I:Int]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-long]: rule
		[Cast(unsigned-long, I:Int) => I:Int]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-int]: rule
		[Cast(unsigned-int, I:Int) => I:Int]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-pointer-type]: rule
		[Cast(Pointer(T:Type-Specifier), I:Int) => I:Int]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-func-pointer-type]: rule
		[Cast(Pointer(T:Type-Specifier, T':Type-Specifier), I:Int) => I:Int]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-typedef]: rule
		< k > [Cast(T:Type-Specifier, I:Int) => Cast(T':Type-Specifier, I:Int)] ...</ k >
		< typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		: KSentence .
		
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K ] </ k >
		< loopStack > [ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K)) => .List] ...</ loopStack >
		: KSentence .

	mb [return-value-clean-local-pointer]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
		
	mb [return-value-clean-local-array]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(T:Type-Specifier, I:Id[N:Nat])) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem > [M:Map Loc:Nat |-> Start:Nat => cleanMap(M:Map, Start:Nat, N:Nat)] </ mem >
		: KSentence .
	mb [return-value-clean-local-struct]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(struct-aux(X:Id, X':Id, Len:Nat)) => .Bag] ...</ locals >	
		< env >... X':Id |-> Loc:Nat ...</ env >
		< mem > [M:Map => cleanMap(M:Map, Loc:Nat, Len:Nat)] </ mem >
		: KSentence .
	mb [return-clean-local-array]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id[N:Nat])) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem > [M:Map Loc:Nat |-> Start:Nat => cleanMap(M:Map, Start:Nat, N:Nat)] </ mem >
		: KSentence .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local-pointer]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
		
	op cleanMap : Map Nat Nat -> Map .
	eq cleanMap((M:Map (N:Nat |-> ?)), N:Nat, sNat(N':Nat)) = cleanMap(M:Map, sNat(N:Nat), N':Nat) .
	eq cleanMap(M:Map, N:Nat, 0) = M:Map .
		
	mb [return-value-clean-params]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-params-pointer]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
		
	mb [return-value-clean-func-pointer]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter})))) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .	
		
	
	mb [return-clean-params]: rule 
		< k > return ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-params-pointer]: rule 
		< k > return ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-func-pointer]: rule 
		< k > return ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter})))) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< parameters > [.Bag => P:Bag] </ parameters >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< parameters > P:Bag </ parameters >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< parameters > [.Bag => P:Bag] </ parameters >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< parameters > P:Bag </ parameters >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	
	mb [post-increment]: rule
		< k > [Deref(Loc:Nat) ++ => V:Int] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => V:Int +Int 1] ...</ mem >
		: KSentence .	
	mb [post-decrement]: rule
		< k > [Deref(Loc:Nat) -- => V:Int] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => _-Int_(V:Int, 1)] ...</ mem >
		: KSentence .
		
	
	---- FIXME 
	mb [sizeof-array-lookup]: rule
		< k > [sizeof(X:Id[?]) => 1] ...</ k >
		< types >... X:Id |-> int[N:Nat] ...</ types >
	: KSentence .
	mb [sizeof-array]: rule
		< k > [sizeof(X:Id) => N:Nat] ...</ k >
		< types >... X:Id |-> int[N:Nat] ...</ types >
	: KSentence .
	
	mb [sizeof-typedef]: rule
		< k > ['sizeof_(Kp:KProper) => sizeof(T:Type)] ...</ k >
		< typedefs >... Kp:KProper |-> T:Type ...</ typedefs >
	: KSentence .
	mb [sizeof-pointer]: rule
		< k > [sizeof(Pointer(TD:Type-Specifier)) => 1] ...</ k >
	: KSentence .
	mb [sizeof-int]: rule
		< k > [sizeof(int) => 1] ...</ k >
	: KSentence .
	mb [sizeof-struct]: rule
		< k > [sizeof(struct(X:Id)) => calcStructSize(Fields:SeqList)] ...</ k >
		< typedefs >... struct(X:Id) |-> struct(X:Id, Fields:SeqList) ...</ typedefs >
	: KSentence .



	
endm
