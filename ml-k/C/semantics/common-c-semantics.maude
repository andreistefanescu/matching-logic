--- why isn't K ~> K proper?
--- arrow unions?
--- readunionfrommem not implemented
--- arithmetic on a void * pointer
--- argument of function type
--- need one past array
--- 6.7.5.3:11 if, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name
--- memcpy uninit memory

---C99 6.7.8:10 If an object has static duration ... if it has pointer type, it is NULL, if it is arithmetic, 0, aggregate, recursively these, union, first member by these

--- EP, UF, UT
--- 33, 42, 33
--- 62, 31, 15
--- 63, 28, 13
--- 60, 29, 15
--- ptrdiff is int
--- 65, 26, 13
--- 68, 22, 8
--- 69, 21, 8
--- 70, 18, 8
--- redo fields, mem
--- 69, 19, 8


--- # of expected passes            44527
--- # of unexpected failures        7081
--- # of unexpected successes       6
--- # of expected failures          183
--- # of unresolved testcases       241
--- # of unsupported tests          1285
--- /usr/bin/gcc  version 4.1.2 20080704 (Red Hat 4.1.2-48)


set print attribute on .
mod INCOMING-MODULES is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
endm

---C99 5.1.2.2.1:1
--- The function called at program startup is named main. The implementation declares no
--- prototype for this function. It shall be defined with a return type of int and with no
--- parameters:
--- int main(void) { /* ... */ }
--- or with two parameters (referred to here as argc and argv, though any names may be
--- used, as they are local to the function in which they are declared):
--- int main(int argc, char *argv[]) { /* ... */ }
--- or equivalent;9) or in some other implementation-defined manner

---C99 5.1.2.2.1:2
--- If they are declared, the parameters to the main function shall obey the following
--- constraints:
--- — The value of argc shall be nonnegative.
--- — argv[argc] shall be a null pointer.
--- — If the value of argc is greater than zero, the array members argv[0] through
--- argv[argc-1] inclusive shall contain pointers to strings, which are given
--- implementation-defined values by the host environment prior to program startup. The
--- intent is to supply to the program information determined prior to program startup
--- from elsewhere in the hosted environment. If the host environment is not capable of
--- supplying strings with letters in both uppercase and lowercase, the implementation
--- shall ensure that the strings are received in lowercase.
--- — If the value of argc is greater than zero, the string pointed to by argv[0]
--- represents the program name; argv[0][0] shall be the null character if the
--- program name is not available from the host environment. If the value of argc is
--- greater than one, the strings pointed to by argv[1] through argv[argc-1]
--- represent the program parameters.
--- — The parameters argc and argv and the strings pointed to by the argv array shall
--- be modifiable by the program, and retain their last-stored values between program
--- startup and program termination.


mod COMMON-SEMANTIC-SYNTAX is
	including INCOMING-MODULES .
	op List : BagItem -> ListItem .
	op unknown : -> Nat [ctor] .
	op unknownF : -> Float [ctor] .
	---op unknown : -> Nat .
	---eq unknown = 0 .
	op skipval : -> KResult .
	op debugK : -> K .
	op discard : -> K .
	op unnamedBitField : -> Id [ctor] .
	
	sort State .
	subsort String < State .
	
	sort Value .
	sort Type .
	sort BaseValue .
	sort Field .
	subsort Field < KResult .

	subsort Int Rat Float < BaseValue .
	subsort BaseValue < Expression .
	subsort Value < Expression .
	subsort Value < KResult .
	subsort Type < KResult .
	subsort Base-Type < Type .
	subsort TogetherList < Expression .
	op sizeof : Type -> Expression .
	op HOLE : -> Expression .
	
	--- Types
	op arrayType : Type Nat -> Type .
	op bitfieldType : Type Nat -> Type .
	op functionType : Type List{K} -> Type .
	op pointerType : Type -> Type .
	op structType : Id -> Type .
	op enumType : Id -> Base-Type .
	op unionType : Id -> Type .
	op qualifiedType : Type K -> Type .
	
	op typedField : Type Id -> Field .
	op declare : K K -> K [metadata "strict(1)"] .
	op declare-aux : K K List{K} -> K .
	op converted : K K -> K .
	op evalToType : -> K .
	op interpret : K Type -> K .
	op allocate : K -> K [metadata "strict"] .
	op tv : BaseValue Type -> Value .
	op atv : List{K} Type -> Value .
	op piece : Nat Nat -> K .
	op concretize : Value -> K .
	---op structVal : List{K} Type -> Value .
	---op unionVal : List{K} Type -> Value .
	op addTypes : K K -> K .
	op addGlobalTypes : K K -> K .
	op addGlobalTypes : K -> K .
	op Closure : K K K -> Value .
	op putInMem : BaseValue K Type K -> K [metadata "strict(2 4)"] .
	op putBytesInMem : Nat List{K} Type K -> K [metadata "strict(4)"] .
	op sizeofType : Type -> Expression [memo] .
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	op _to_ : Nat Nat -> List{K} . 
	op calcStructSize : List{KResult} -> K .
	op calcStructSize-aux : List{KResult} Rat -> K .
	op calcUnionSize : List{KResult} -> K .
	op calcUnionSize-aux : List{KResult} Rat -> K .
	op necessaryBytes : K -> K [metadata "strict"] .
	op cast : K K -> K [metadata "strict"] .
	op addLocals : Nat -> K .			
	op integerTypes : -> Set [memo] .
	op unsignedIntegerTypes : -> Set [memo] .
	op hasIntegerType : Type -> Bool [memo] .
	op typeof : Expression -> K .
	op writeToFD : Nat Nat -> K .
	op writeToFD : Nat String -> K .
	op readFromFD : Nat -> K .
endm

mod C-SETTINGS is
	including INCOMING-MODULES .
	including COMMON-SEMANTIC-SYNTAX .

	--- S 6.2.5 p.35 i.15.  "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.  37)... Irrespective of the choice made, char is a separate type from the other two and is not compatible with either
	--- cme: I'm not sure what consequence being a separate type entails, so for now it will just be rewritten to the chosen type
	mb rule [char => signed-char] : KSentence [metadata "stuctural"] .
	
	mb rule [NULL => tv(0, pointerType(void))] : KSentence [metadata "stuctural"] .
	
	---C99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented

	op numBytes : Type -> Nat [memo] .
	eq numBytes(signed-char) = 1 .
	eq numBytes(short-int) = 2 .
	eq numBytes(int) = 4 .
	eq numBytes(long-int) = 4 .
	eq numBytes(long-long-int) = 8 .
	
	eq numBytes(float) = 4 .
	eq numBytes(double) = 8 .
	
	eq numBytes(enumType(X:Id)) = numBytes(int) .
	
	
	op cfg:sizeut : -> Type .
	eq cfg:sizeut = unsigned-long-int .

	--- fixme unfortunate, but this is what cil assumes
	op cfg:ptrdiffut : -> Type .
	eq cfg:ptrdiffut = int .
	
	---- derived
	eq numBytes(unsigned-char) = numBytes(signed-char) .
	eq numBytes(unsigned-short-int) = numBytes(short-int) .
	eq numBytes(unsigned-int) = numBytes(int) .
	eq numBytes(unsigned-long-int) = numBytes(long-int) .
	eq numBytes(unsigned-long-long-int) = numBytes(long-long-int) .
	
	op numBits : Type -> Nat [memo] .
	eq numBits(T:Type) = numBytes(T:Type) *Nat 8 .
			
	op min : Type -> Int [memo] .
	op max : Type -> Int [memo] .
	eq min(signed-char) = -Int (2 ^Nat absInt(_-Int_(numBits(signed-char), 1))) .
	eq max(signed-char) = _-Int_(2 ^Nat absInt(_-Int_(numBits(signed-char), 1)), 1) .
	eq min(short-int) = -Int (2 ^Nat absInt(_-Int_(numBits(short-int), 1))) .
	eq max(short-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(short-int), 1)), 1) .
	eq min(int) = -Int (2 ^Nat absInt(_-Int_(numBits(int), 1))) .
	eq max(int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(int), 1)), 1) .
	eq min(long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-int), 1))) .
	eq max(long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-int), 1)), 1) .
	eq min(long-long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-long-int), 1))) .
	eq max(long-long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-long-int), 1)), 1) .
	
	eq min(unsigned-char) = 0 .
	eq max(unsigned-char) = _-Int_(2 ^Nat absInt(numBits(unsigned-char)), 1) .
	eq min(unsigned-short-int) = 0 .
	eq max(unsigned-short-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-short-int)), 1) .
	eq min(unsigned-int) = 0 .
	eq max(unsigned-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-int)), 1) .
	eq min(unsigned-long-int) = 0 .
	eq max(unsigned-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-int)), 1) .
	eq min(unsigned-long-long-int) = 0 .
	eq max(unsigned-long-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-long-int)), 1) .
	
	eq min(enumType(?)) = min(int) .
	eq max(enumType(?)) = max(int) .
		
	eq sizeofType(T:Base-Type) = tv(numBytes(T:Base-Type), cfg:sizeut) .
	eq sizeofType(pointerType(?)) = tv(numBytes(unsigned-long-int), cfg:sizeut) .

	--- need to be careful about simplifying these into one rule because there may be variables with the same name as a typedef?
	mb rule 
		< k > [T:Typedef-Name => T:Type] ...</ k >
		< types >... T:Typedef-Name |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct(X:Id) => T:Type] ...</ k > 
		< types >... struct(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [union(X:Id) => T:Type] ...</ k > 
		< types >... union(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [enum(X:Id) => T:Type] ...</ k > 
		< types >... enum(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	
	--- — number of bits for smallest object that is not a bit-field (byte)
	--- CHAR_BIT 8
	--- — minimum value for an object of type signed char
	--- SCHAR_MIN -127 // -(27 - 1)
	--- — maximum value for an object of type signed char
	--- SCHAR_MAX +127 // 27 - 1
	--- — maximum value for an object of type unsigned char
	--- UCHAR_MAX 255 // 28 - 1
	--- — minimum value for an object of type char
	--- CHAR_MIN see below
	--- — maximum value for an object of type char
	--- CHAR_MAX see below
	--- — maximum number of bytes in a multibyte character, for any supported locale
	--- MB_LEN_MAX 1
	--- — minimum value for an object of type short int
	--- SHRT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type short int
	--- SHRT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned short int
	--- USHRT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type int
	--- INT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type int
	--- INT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned int
	--- UINT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type long int
	--- LONG_MIN -2147483647 // -(231 - 1)
	--- — maximum value for an object of type long int
	--- LONG_MAX +2147483647 // 231 - 1
	--- — maximum value for an object of type unsigned long int
	--- ULONG_MAX 4294967295 // 232 - 1
	--- — minimum value for an object of type long long int
	--- LLONG_MIN -9223372036854775807 // -(263 - 1)
	--- — maximum value for an object of type long long int
	--- LLONG_MAX +9223372036854775807 // 263 - 1
	--- — maximum value for an object of type unsigned long long int
	--- ULLONG_MAX 18446744073709551615 // 264 - 1
	
	op rank : Type -> Nat .
	
	eq rank(char) = 1 .
	eq rank(signed-char) = 1 .
	eq rank(unsigned-char) = 1 .
	eq rank(short-int) = 2 .
	eq rank(unsigned-short-int) = 2 .
	eq rank(int) = 3 .
	eq rank(unsigned-int) = 3 .
	eq rank(long-int) = 4 .
	eq rank(unsigned-long-int) = 4 .
	eq rank(long-long-int) = 5 .
	eq rank(unsigned-long-long-int) = 5 .
	
	--- fixme unlikely but possible to have more than int enum values
	eq rank(enumType(?)) = rank(int) .
	---C99 6.3.1.1
	
	***(
	--- no two signed are the same
	rank of signed shall be greater than rank of signed with less precision
	rank(long-long-int) > rank(long int) > rank(int) > rank(short int) > rank(signed-char)
	rank unsigned is same as signed
	rank(char) == rank(signed char) == rank(unsigned-char)
	rank(_Bool) < rank(char)
	rank(enumType) == rank compatible int type
	transitive
	***)
endm

mod COMMON-INCLUDE is
	including INCOMING-MODULES .
	including C-SETTINGS .
	including COMMON-SEMANTIC-SYNTAX .
	
	--- fixme can do a much better job than this
	eq ? &Nat unknown = unknown .
	eq ? |Nat unknown = unknown .
	eq ? *Float unknownF = unknownF .
	eq unknownF *Float ? = unknownF .
	eq ? +Float unknownF = unknownF .
	eq unknownF +Float ? = unknownF .
	eq float2ratConversion(unknownF) = unknown .
	eq _-Float_(?, unknownF) = unknownF .
	eq _-Float_(unknownF, ?) = unknownF .
	eq _/Float_(?, unknownF) = unknownF .
	eq _/Float_(unknownF, ?) = unknownF .
	eq -Float(unknownF) = unknownF .
	eq expFloat(unknownF) = unknownF .
	eq logFloat(unknownF) = unknownF .
	ceq logFloat(F:Float) = unknownF 
		if F:Float <Float 0.0 .
	
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence [metadata "structural"] .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence [metadata "structural"] .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence [metadata "structural"] .
		
		
	eq hex(S:String) = string2ratConversion(S:String, 16) .
	eq Parameter-Type-List() = Parameter-Type-List(.List{Parameter}) .

	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
		
		
	--- Note: it only makes sense to memo this if the sets are just used to represent categories
	op _contains_ : Set K -> Bool [memo] .
	eq S:Set SetItem(K:K) contains K:K = true .
	ceq S:Set SetItem(K1:K) contains K2:K = S:Set contains K2:K 
		if K1:K =/=Bool K2:K .
	eq .Set contains K:K = false .

	ceq hasIntegerType(T:Type) = true
		if (integerTypes contains T:Type) .
	eq hasIntegerType(enumType(?)) = true .
	eq hasIntegerType(bitfieldType(?, ?)) = true .
endm

mod SIZEOF is
	including COMMON-INCLUDE .

	ceq min(bitfieldType(T:Type, N:Nat)) = 0
		if unsignedIntegerTypes contains T:Type .
	ceq max(bitfieldType(T:Type, N:Nat)) = _-Int_(2 ^Nat absInt(N:Nat), 1)
		if unsignedIntegerTypes contains T:Type .
	
	mb rule
		< k > [sizeofType(arrayType(T:Type, N:Nat)) => '_*_(sizeofType(T:Type),, tv(N:Nat, cfg:sizeut))] ...</ k >
		: KSentence [metadata "stuctural"] .
	mb rule [sizeofType(bitfieldType(T:Type, N:Nat)) => tv(N:Nat /Rat 8, cfg:sizeut)] : KSentence [metadata "structural"] .
	
	---C99 6.2.6.1:26 ... Each unqualified type has several qualified versions of its type,40) corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers. The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements. ...
	eq sizeofType(qualifiedType(T:Type, ?)) = sizeofType(T:Type) .	
	mb rule
		< k > [sizeof(E:Expression) => evalToType ~> sizeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence [metadata "stuctural"] .
	--- fixme the below rule actually changes itself to "value" and there can be values that aren't yet types
	--- mb rule
		--- < k > [evalToType ~> sizeof(HOLE) => sizeofType(T:Type)] ...</ k >
		--- [< type > T:Type </ type > => .Bag]
		--- : KSentence [metadata "stuctural"] .
	--- fixme should be able to do this for all types
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(T:Base-Type)] ...</ k >
		[< type > T:Base-Type </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(arrayType(T:Type, N:Nat))] ...</ k >
		[< type > arrayType(T:Type, N:Nat) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(structType(X:Id))] ...</ k >
		[< type > structType(X:Id) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(unionType(X:Id))] ...</ k >
		[< type > unionType(X:Id) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(bitfieldType(T:Type, N:Nat))] ...</ k >
		[< type > bitfieldType(T:Type, N:Nat) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(functionType(T:Type, L:List{K}))] ...</ k >
		[< type > functionType(T:Type, L:List{K}) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(pointerType(T:Type))] ...</ k >
		[< type > pointerType(T:Type) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(enumType(X:Id))] ...</ k >
		[< type > enumType(X:Id) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(qualifiedType(T:Type, K:K))] ...</ k >
		[< type > qualifiedType(T:Type, K:K) </ type > => .Bag]
		: KSentence [metadata "stuctural"] .
	
	
	mb rule
		< type > [E:Expression => T:Type] ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [tv(?, T:Type) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [cast(T:Type, ?) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb [type-arrow-heat]: rule
		< type > ['_->_(Kp:KProper,, X:Id) => Kp:KProper ~> '_->_(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb [type-arrow-cool]: rule
		< type > [T:Type ~> '_->_(HOLE,, X:Id) => '_->_(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb [type-arrow]: rule
		< type > ['_->_(pointerType(structType(S:Id)),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence [metadata "stuctural"] .
	mb [type-dot-heat]: rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb [type-dot-cool]: rule
		< type > [T:Type ~> '_._(HOLE,, X:Id) => '_._(T:Type,, X:Id)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb [type-struct-dot]: rule
		< type > ['_._(structType(S:Id),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence [metadata "stuctural"] .
	mb [type-union-dot]: rule
		< type > ['_._(unionType(S:Id),, X:Id) => T:Type] ...</ type >
		< structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > [T:Type ~> Deref(HOLE) => 'Deref(T:Type)] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Deref(arrayType(T:Type, ?)) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .
	mb rule
		< type > ['Deref(tv(?, pointerType(T:Type))) => T:Type] ...</ type >
		: KSentence [metadata "stuctural"] .

	eq necessaryBytes(tv(R:Rat, T:Type)) = tv(truncRat(R:Rat +Rat (7 /Rat 8)), T:Type) .
	mb [sizeof-struct]: rule
		< k > [sizeofType(structType(X:Id)) => calcStructSize(L:List{KResult})] ...</ k >
		< structs >... struct(X:Id) |-> L:List{KResult} ...</ structs >
	: KSentence .
	mb [sizeof-union]: rule
		< k > [sizeofType(unionType(X:Id)) => calcUnionSize(L:List{KResult})] ...</ k >
		< structs >... union(X:Id) |-> L:List{KResult} ...</ structs >
	: KSentence .
	mb [sizeof-enum]: rule
		< k > [sizeofType(enumType(X:Id)) => tv(1, cfg:sizeut)] ...</ k >
	: KSentence .
	
	mb [calcStructSize]: rule
		< k > [calcStructSize(L:List{KResult}) => necessaryBytes(calcStructSize-aux(L:List{KResult}, 0))] ...</ k >
		: KSentence .
	mb [calcUnionSize]: rule
		< k > [calcUnionSize(L:List{KResult}) => necessaryBytes(calcUnionSize-aux(L:List{KResult}, 0))] ...</ k >
		: KSentence .
	
	mb [calcStructSize]: rule
		< k > [calcStructSize-aux((typedField(T:Type, X:Id),, L:List{KResult}), R:Rat) 
			=> sizeofType(T:Type) ~> calcStructSize-aux(L:List{KResult}, R:Rat)] ...</ k >
		if T:Type isa 'bitfieldType
		: KSentence .
	mb [calcStructSize]: rule
		< k > [calcStructSize-aux((typedField(T:Type, X:Id),, L:List{KResult}), R:Rat)
			=> sizeofType(T:Type) ~> calcStructSize-aux(L:List{KResult}, truncRat(R:Rat +Rat (7 /Rat 8)))] ...</ k >
		if notBool(T:Type isa 'bitfieldType)
		: KSentence .
		
	mb [calcUnionSize]: rule
		< k > [calcUnionSize-aux((typedField(T:Type, X:Id),, L:List{KResult}), R:Rat) 
			=> sizeofType(T:Type) ~> calcUnionSize-aux(L:List{KResult}, R:Rat)] ...</ k >
		: KSentence .
	
	op _isa _ : K KLabel -> Bool .
	eq KL:KLabel(?) isa KL:KLabel = true .
	eq ? isa ? = false [owise] .
		
	mb [calcStructSize-cool]: rule
		< k > [tv(R':Rat, ?) ~> calcStructSize-aux(L:List{KResult}, R:Rat) 
			=> calcStructSize-aux(L:List{KResult}, R:Rat +Rat R':Rat)] ...</ k >
		: KSentence .
	mb [calcUnionSize-cool]: rule
		< k > [tv(R':Rat, ?) ~> calcUnionSize-aux(L:List{KResult}, R:Rat) 
			=> calcUnionSize-aux(L:List{KResult}, maxRat(R:Rat, R':Rat))] ...</ k >
		: KSentence .
		
	mb [calcStructSize-done]: rule
		[calcStructSize-aux(.List{K}, R:Rat) => tv(R:Rat, cfg:sizeut)]
		: KSentence .
	mb [calcUnionSize-done]: rule
		[calcUnionSize-aux(.List{K}, R:Rat) => tv(R:Rat, cfg:sizeut)]
		: KSentence .
endm

mod TYPES is
	including COMMON-INCLUDE .
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	--- fixme ignoring qualifiers
	mb rule [qualifiedType(T:Type, ?) => T:Type] : KSentence [metadata "structural"] .
	
	mb rule [unsigned-short => unsigned-short-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long => unsigned-long-int] : KSentence [metadata "structural"] .
	mb rule [unsigned-long-long => unsigned-long-long-int] : KSentence [metadata "structural"] .
	mb rule [short => short-int] : KSentence [metadata "structural"] .
	mb rule [long => long-int] : KSentence [metadata "structural"] .
	mb rule [long-long => long-long-int] : KSentence [metadata "structural"] .
	
	mb rule
		< k > [typeof(E:Expression) => evalToType ~> typeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .
	mb rule
		< k > [evalToType ~> typeof(HOLE) => T:Type] ...</ k >
		[< type > T:Type </ type > => .Bag]
		: KSentence .
	
	mb rule 
		['_`[_`](T:Type,, N:Nat) => arrayType(T:Type, N:Nat)]
		: KSentence [metadata "structural"] .
	--- mb rule 
		--- [enum(X:Id) => enumType(X:Id)]
		--- : KSentence [metadata "structural"] .
	mb rule 
		['Pointer(T:Type) => pointerType(T:Type)]
		: KSentence [metadata "structural"] .
		

	mb rule 
		< k > ['Pointer(T:Type,, 'Direct-Function-Declarator('Parameter-Type-List(LL:List{Parameter}))) 
		=> pointerType(functionType(T:Type, getList{K}(LL:List{Parameter})))] ...</ k >
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > ['Pointer(T:Type) => pointerType(T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	--- move "Pointer" to where it belongs
	mb rule 
		[L:KLabel(T:Type,, 'Pointer(D:K)) => L:KLabel(pointerType(T:Type),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	--- fixme these feel like cheating
	mb rule 
		[L:KLabel(struct(X:Id),, D:K) => L:KLabel(structType(X:Id),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(enum(X:Id),, D:K) => L:KLabel(enumType(X:Id),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(union(X:Id),, D:K) => L:KLabel(unionType(X:Id),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'BitField(D:K,, N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'BitField(N:Nat)) => L:KLabel(bitfieldType(T:Type, N:Nat),, unnamedBitField)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'Direct-Function-Declarator(X:Id,, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(functionType(T:Type, getList{K}(LL:List{Parameter})),, X:Id)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule
		[L:KLabel(T:Type,, 'Direct-Function-Declarator('Pointer(D:Declarator),, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(pointerType(functionType(T:Type, getList{K}(LL:List{Parameter}))),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
		
	mb rule 
		[L:KLabel(T:Type,, D:Declarator[N:Nat]) 
		=> L:KLabel(arrayType(T:Type, N:Nat),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	
	--- fixme ignoring extern
	mb rule
		[extern => .K]
		: KSentence [metadata "structural"] .
	--- fixme ignoring static
	mb rule
		[static => .K]
		: KSentence [metadata "structural"] .
	mb rule
		[register => .K]
		: KSentence [metadata "structural"] .
	--- mb rule
		--- [extern ~> T:Type => qualifiedType(T:Type, extern)]
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- [static ~> T:Type => qualifiedType(T:Type, static)]
		--- : KSentence [metadata "structural"] .
	--- for casts, at least
	--- mb rule
		--- [Pointer(T:Type) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .

	
	op arithConversion : K K -> K [metadata "strict"] .
	op arithConversion-int : K K -> K [metadata "strict"] .
	op promote : K -> K .

	
	op isArithBinOp : KLabel -> Bool .
	op arithBinOps : -> Set [memo] .
	op l : KLabel -> K .
	eq arithBinOps = Set(
		l('_*_),, l('_/_),, l('_%_),,
		l('_+_),, l('_-_),,
		l('_<<_),, l('_>>_),,
		l('_<_),, l('_>_),, l('_<=_),, l('_>=_),,
		l('_==_),, l('_!=_)
	) .
	eq isArithBinOp(KL:KLabel) = if arithBinOps contains l(KL:KLabel)  then true else false fi .
	
	--- fixme should these promotions be done elsewhere?
	mb rule
		< k > L:KLabel([tv(V:BaseValue, T:Type) => promote(tv(V:BaseValue, T:Type))],, ?) ...</ k > 
		if     isArithBinOp(L:KLabel)
		andBool rank(T:Type) <Int rank(int)
		andBool hasIntegerType(T:Type)
		: KSentence .
	mb rule
		< k > L:KLabel(?,, [tv(V:BaseValue, T:Type) => promote(tv(V:BaseValue, T:Type))]) ...</ k > 
		if     isArithBinOp(L:KLabel)
		andBool rank(T:Type) <Int rank(int)
		andBool hasIntegerType(T:Type)
		: KSentence .
	
		
	---C99 6.3.1.8
	--- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, long-double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, long-double), tv(V2:BaseValue, long-double))] ...</ k >
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, double), tv(V2:BaseValue, double))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float. 53) For example, addition of a double _Complex and a float entails just the conversion of the float operand to double (and yields a double _Complex result).
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, float), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, float), tv(V2:BaseValue, float))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- andBool T2:Type =/=Bool double
		--- : KSentence .
		
	--- Otherwise, the integer promotions are performed on both operands ...
	--- mb rule
		--- < k > [
			--- arithConversion(tv(V1:BaseValue, T1:Type), tv(V2:BaseValue, T2:Type)) 
			--- => 
			--- arithConversion-int(integerPromotion(tv(V1:BaseValue, T1:Type)), integerPromotion(tv(V2:BaseValue, T2:Type)))
		--- ] ...</ k >
		--- if T1:Type =/=Bool long-double andBool T2:Type =/=Bool long-double
		--- andBool T1:Type =/=Bool double andBool T2:Type =/=Bool double
		--- andBool T1:Type =/=Bool float andBool T2:Type =/=Bool float
		--- : KSentence .
	
	---C99 6.3.1.4:2 For objects or expressions with an integer type  whose integer conversion rank is less than or equal to the rank of int and unsigned int, and a bit field of type _Bool, int, signed int, or unsigned int, If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int.  These are called the integer promotions.  All other types are unchanged by the integer promotions.
	---C99 6.3.1.4:3 The integer promotions preserve value including sign. As discussed earlier, whether a "plain" char is treated as signed is implementation-defined.
	mb rule
		< k > [promote(tv(V:BaseValue, T:Type)) => tv(V:BaseValue, int)] ...</ k >
		if     hasIntegerType(T:Type)
		andBool rank(T:Type) <=Int rank(int)
		andBool min(int) <=Int min(T:Type) 
		andBool max(int) >=Int max(T:Type)		
		: KSentence .
	--- fixme unclear what 6.3.1.4:3 means
	mb rule
		< k > [promote(tv(V:BaseValue, T:Type)) => interpret(V:BaseValue, unsigned-int)] ...</ k >
		if     hasIntegerType(T:Type)
		andBool rank(T:Type) <=Int rank(int)
		andBool notBool (
			min(int) <=Int min(T:Type) 
			andBool max(int) >=Int max(T:Type)		
		)
		: KSentence .


	
	--- Then the following rules are applied to the promoted operands:
	
	--- If both operands have the same type, then no further conversion is needed.
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- fixme not sure about this
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
	
	--- Otherwise...
	--- fixme left out cases
		
	op locs : List{K} -> KResult .
	mb [start-declare]: rule
		< k > ['Declaration(T:Type,, X:Id) => declare(T:Type, X:Id)] ...</ k >
		: KSentence .
	
endm	

------------------------------------------------
---- C standard library
mod COMMON-C-STANDARD-LIBRARY is
	including COMMON-INCLUDE .
	
	op builtin : Id -> Value .
	
	mb [debug-is-value]: rule
		< k > [debug => builtin(debug)] ...</ k >
	: KSentence .
	mb [debug]: rule
		< k > [Apply(builtin(debug), .List{Expression}) => skipval] ...</ k >
	: KSentence .
	
	--------------------------------------------
	mb [exit-is-value]: rule
		< k > [exit => builtin(exit)] ...</ k >
	: KSentence .
	mb [exit]: rule
		< k > [Apply(builtin(exit), tv(I:Int, int)) ~> ? => tv(I:Int, int)] </ k >
	: KSentence .
	--------------------------------------------
	mb [abort-is-value]: rule
		< k > [abort => builtin(abort)] ...</ k >
	: KSentence .
	mb [abort]: rule
		< k > [Apply(builtin(abort), .List{Expression}) ~> ? => tv(134, int)] </ k >
	: KSentence .
	--------------------------------------------
	mb [sqrt-is-value]: rule
		< k > [sqrt => builtin(sqrt)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(sqrt), tv(F:Float, double)) => tv(sqrtFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [log-is-value]: rule
		< k > [log => builtin(log)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(log), tv(F:Float, double)) => tv(logFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [exp-is-value]: rule
		< k > [exp => builtin(exp)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(exp), tv(F:Float, double)) => tv(expFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [atan-is-value]: rule
		< k > [atan => builtin(atan)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(atan), tv(F:Float, double)) => tv(atanFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [cos-is-value]: rule
		< k > [cos => builtin(cos)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(cos), tv(F:Float, double)) => tv(cosFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [sin-is-value]: rule
		< k > [sin => builtin(sin)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(sin), tv(F:Float, double)) => tv(sinFloat(F:Float), double)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), tv(N:Nat, ?)) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> piece(unknown, 8)] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	--- Returns a pseudo-random integral number in the range 0 to RAND_MAX.
	
	mb [rand-is-value]: rule
		< k > [rand => builtin(rand)] ...</ k >
	: KSentence .
	--- unsignedIntegerTypes contains T:Type
	--- (2 ^Nat absInt(numBits(int)))
	--- fixme should use RAND_MAX
	mb [rand]: rule
		< k > [Apply(builtin(rand), .List{Expression}) => 
		tv(absInt(randomRandom(Loc:Nat)) %Int max(int), int)
		] ...</ k >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [free-is-value]: rule
		< k > [free => builtin(free)] ...</ k >
	: KSentence .
	
	mb [free]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => Apply(builtin(free), tv(sNat(Loc:Nat), pointerType(T:Type)))] ...</ k >
		< mem >...  [Loc:Nat |-> ? => .Map] ...</ mem >
		< malloced >... [Loc:Nat |-> sNat(N:Nat) => sNat(Loc:Nat) |-> N:Nat] ...</ malloced >
	: KSentence .
	mb [free-done]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => skipval] ...</ k >
		< malloced >... [Loc:Nat |-> 0 => .Map] ...</ malloced >
	: KSentence .
	--------------------------------------------
	mb [calloc-is-value]: rule
		< k > [calloc => builtin(calloc)] ...</ k >
	: KSentence .
	
	mb [calloc]: rule
		< k > ['Apply(builtin(calloc),, (tv(N:Nat, ?) .,. tv(Size:Nat, ?))) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat (N:Nat *Nat Size:Nat)) |-> piece(0, 8)] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat (N:Nat *Nat Size:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [putchar-is-value]: rule
		< k > [putchar => builtin(putchar)] ...</ k >
	: KSentence .
	--- fixme doesn't cast to int
	mb [putchar]: rule
		< k > [Apply(builtin(putchar), tv(N:Nat, ?)) => writeToFD(1, N:Nat) ~> tv(N:Nat, int)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [getchar-is-value]: rule
		< k > [getchar => builtin(getchar)] ...</ k >
	: KSentence .
	--- fixme doesn't cast to int
	mb [getchar]: rule
		< k > [Apply(builtin(getchar), .List{Expression}) => readFromFD(0)] ...</ k >
	: KSentence .
	--------------------------------------------
	mb [lib-printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-string : Nat Nat -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [lib-printf-start]: rule
		< k > [Apply(builtin(printf), (tv(Loc:Nat, pointerType(?)) .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [lib-printf-string]: rule
		< k > [printf-string(Len:Nat, Loc:Nat) => writeToFD(1, N:Nat) ~> printf-string(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat =/=Bool 0
	: KSentence .
	mb [lib-printf-string-done]: rule
		< k > [printf-string(Len:Nat, Loc:Nat) => tv(Len:Nat, int)] ...</ k >
		< mem >... Loc:Nat |-> piece(0, 8) ...</ mem >
	: KSentence .
	
	---fixme why do i have to have the 0--255 check?
	mb [lib-printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => writeToFD(1, N:Nat) ~> printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat =/=Bool asciiString("%") 
		andBool N:Nat =/=Bool 0
		andBool N:Nat >=Nat 0 
		andBool N:Nat <=Nat 255
	: KSentence .
	mb [lib-printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => tv(Len:Nat, int)] ...</ k >
		< mem >... Loc:Nat |-> piece(0, 8) ...</ mem >
	: KSentence .
	mb [lib-printf-null]: rule
		< k > [printf-aux(0, 0, .List{Expression}) => writeToFD(1, "(null)") ~> tv(6, int)] ...</ k >
	: KSentence .
	
	mb [lib-printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	--- fixme ignoring 0 flag for now
	mb [lib-printf-0]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("0") 
	: KSentence .
	--- ignoring num width
	mb [lib-printf-width]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat >Int asciiString("0") 
		andBool N:Nat <=Int asciiString("9")
	: KSentence .
	
	mb [lib-printf-x]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => writeToFD(1, (if (lengthString(rat2stringConversion(D:Int, 16)) ==Bool 1) then
				"0" +String rat2stringConversion(D:Int, 16)
			else 
				rat2stringConversion(D:Int, 16)
			fi)) ~> printf-aux(Len:Nat +Nat lengthString((if (lengthString(rat2stringConversion(D:Int, 16)) ==Bool 1) then
				"0" +String rat2stringConversion(D:Int, 16)
			else 
				rat2stringConversion(D:Int, 16)
			fi)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("x") 
	: KSentence .
	
	mb [lib-printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => writeToFD(1, rat2stringConversion(D:Int, 10)) ~> printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("d")
	: KSentence .
	mb [lib-printf-%c]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(C:Nat, ?) .,. L:List{Expression})) => writeToFD(1, C:Nat) ~> printf-aux(Len:Nat +Nat 1, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("c") 
	: KSentence .
	
	mb [lib-printf-%u]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => writeToFD(1, rat2stringConversion(D:Int, 10)) ~> printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("u") 
	: KSentence .
	
	mb [lib-printf-%f]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Float, ?) .,. L:List{Expression})) => writeToFD(1, float2stringConversion(D:Float)) ~> printf-aux(Len:Nat +Nat lengthString(float2stringConversion(D:Float)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("f") 
	: KSentence .
	
	mb [lib-printf-%s]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(S:Nat, pointerType(?)) .,. L:List{Expression})) => 
			printf-string(0, S:Nat)
			~> printf-aux(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		if N:Nat ==Bool asciiString("s") 
	: KSentence .

	mb [lib-printf-%s-done]: rule
		< k > [tv(Len':Nat, int) ~> printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => 
			printf-aux(Len:Nat +Nat Len':Nat, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .
	op bind : List{K} List{K} -> K .

	mb [void-to-id]: rule
		[Parameter-Type-List(Parameter-Declaration(void)) 
		=> Parameter-Type-List(.List{Parameter})] : KSentence [metadata "structural"] .
	
	--- empty binding
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, .List{K}) => .K] ...</ k > 
		: KSentence .
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, ...) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	mb rule
		< k > [bind((tv(V:BaseValue, arrayType(T:Type, ?)),, L:List{KResult}), PD:List{K})
			=> bind((tv(V:BaseValue, pointerType(T:Type)),, L:List{KResult}), PD:List{K})] ...</ k > : KSentence [metadata "structural"] .
			
	--- fixme can't this be done by heating bind?
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, D:Declarator),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, D:Declarator),, P:List{K}))] ...</ k >
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(struct(X:Id),, D:Declarator),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, D:Declarator),, P:List{K}))] ...</ k >
		< typedefs >... struct(X:Id) |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(union(X:Id),, D:Declarator),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, D:Declarator),, P:List{K}))] ...</ k >
		< typedefs >... union(X:Id) |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb [bind-one]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))
			=> addTypes(X:Id, T':Type) ~> allocate(sizeofType(T':Type)) ~> addLocals(Loc:Nat) ~> putInMem(Loc:Nat, cast(T':Type, tv(V:BaseValue, T:Type)), T':Type, sizeofType(T':Type)) ~> bind(L:List{KResult}, P:List{K})] ...</ k > 
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb [bind-struct]: rule
		< k > [bind((atv(V:List{K}, T:Type),, L:List{KResult}), ('Parameter-Declaration(T:Type,, X:Id),, P:List{K}))
			=> addTypes(X:Id, T:Type) ~> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat) 
			~> putBytesInMem(Loc:Nat, V:List{K}, T:Type, sizeofType(T:Type)) 
			~> bind(L:List{KResult}, P:List{K})] ...</ k > 
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb [bind-var]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), (...))
			=> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat) ~> putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T:Type, sizeofType(T:Type)) ~> bind(L:List{KResult}, ...)] ...</ k > 
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	--- fixme todo this happens when we don't have the right prototype.  I think it's correct
	mb [bind-var]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), .List{K})
			=> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat) ~> putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T:Type, sizeofType(T:Type)) ~> bind(L:List{KResult}, ...)] ...</ k > 
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, X:Id),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))] ...</ k > 
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence [metadata "structural"] .		
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb rule
		< k > ['Global('Declaration(T:Type,, X:Id))
			=> addGlobalTypes(X:Id, T:Type) ~> '_;(allocate(sizeofType(T:Type)))] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		if getKLabel(T:Type)=/=Bool 'functionType
		: KSentence .
		
	op structInitializer : K List{K} -> Expression .
	mb rule [Declaration(struct(S:Id), X:Id) = Initializer(InitList(L:List{Expression}))
		=> Declaration(struct(S:Id), X:Id) = structInitializer(X:Id, getList{K}(L:List{Expression}))] : KSentence [metadata "structural"] .
	
	mb rule
		< k > ['Global('Declaration(TD:Typedef-Name,, D:Declarator))
			=> 'Global('Declaration(T:Type,, D:Declarator))] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence [metadata "structural"] .
	
	mb [global-variable-declaration-init]: rule
		< k > ['_=_('Declaration(T:Type,, X:Id),, E:Expression) => 'Global('Declaration(T:Type,, X:Id)) ~> Deref(&(X:Id)) := E:Expression ;] ...</ k >
		: KSentence .
		
	mb [function-definition]: rule 
		< k > ['_`{_`}('Declaration(T:Type,, X:Id),, B:TogetherList) => .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> Closure(X:Id, T:Type, B:TogetherList)] </ mem >
		< types >... [.Map => X:Id |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Type] ...</ typedefs >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb rule 
		< k > ['_`{_`}('Declaration(TD:Typedef-Name,, D:Declarator),, B:TogetherList) => '_`{_`}('Declaration(T:Type,, D:Declarator),, B:TogetherList)] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb [function-prototype]: rule 
		< k > ['Global('Declaration(functionType(T:Type, L:List{K}),, I:Id)) => .K] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [Global(Typedef(T:TogetherList, X:Declarator)) => Typedef(T:TogetherList, X:Declarator)] ...</ k >
		: KSentence [metadata "structural"] .
		
	--- fixme this isn't how things are, but it seems to work out
	---C99 6.7.2.2:3 The identifiers in an enumerator list are declared as constants that have type int and may appear wherever such are permitted
	mb rule
		< k > [Global(enum(X:Id, ((X':Id := E:Expression) .,. L:List{Expression}))) => '_=_('Declaration(int,, X':Id),, E:Expression) ~> Global(enum(X:Id, L:List{Expression}))] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [Global(enum(X:Id, .List{Expression})) => .K] ...</ k >
		< types >... [.Map => enum(X:Id) |-> enumType(X:Id)] ...</ types >
		< typedefs >... [.Map => enum(X:Id) |-> enumType(X:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb [typedef-declaration]: rule
		< k > ['Typedef(T:Type,, X:Typedef-Name) => .K] ...</ k >
		< types >... [.Map => X:Typedef-Name |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	mb rule 
		< k > [T:Type ~> addGlobalTypes(K:K) => addGlobalTypes(K:K, T:Type)] ...</ k >
		: KSentence .
		
	op initArray : List{K} Nat Type -> K .
	mb [global-array-declaration-init]: rule
		< k > ['_=`{_`}('Declaration(arrayType(T:Type, N:Nat),, X:Id),, L:List{Expression}) => '_;(allocate(sizeofType(arrayType(T:Type, N:Nat)))) ~> initArray(getList{K}(L:List{Expression}), Loc:Nat, T:Type)] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		< types >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ types >
		< typedefs >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		: KSentence [metadata "structural"] .
		
	op initItem : K Nat Type -> K [metadata "strict(1)"] .
	mb [initArray]: rule
		< k > [initArray((Item:K,, Items:List{K}), Loc:Nat, T:Type) 
		=> initItem(Item:K, Loc:Nat, T:Type) ~> initArray(Items:List{K}, Loc:Nat, T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	mb [initArray-empty]: rule
		< k > [initArray(.List{K}, ?, ?) => .K] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [tv(N:Nat, ?) ~> initArray(Items:List{K}, Loc:Nat, T:Type) 
		=> initArray(Items:List{K}, Loc:Nat +Nat N:Nat, T:Type) ] ...</ k >
		: KSentence [metadata "structural"] .
		
	mb rule
		< k > [initItem(tv(I:Int, T:Type), Loc:Nat, T:Type) => putInMem(Loc:Nat, tv(I:Int, T:Type), T:Type, sizeofType(T:Type)) ~> sizeofType(T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
			
	op struct-aux : Id K List{KResult} -> K .
	op union-aux : Id K List{KResult} -> K .
	mb rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => struct-aux(X:Id, DS:TogetherList, .List{K}) ~> addGlobalTypes(X:Id)] ...</ k >
		< types >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ types >
		< typedefs >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [Global(struct(X:Id)) => .K] ...</ k >
		< types >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ types >
		< typedefs >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [Global(union(X:Id, DS:TogetherList) ;) => union-aux(X:Id, DS:TogetherList, .List{K}) ~> addGlobalTypes(X:Id)] ...</ k >
		< types >... [.Map => union(X:Id) |-> unionType(X:Id)] ...</ types >
		< typedefs >... [.Map => union(X:Id) |-> unionType(X:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct-aux(X:Id, (Field(T:TogetherList, D:Declarator) ~> K:K), L:List{KResult}) => Field(T:TogetherList, D:Declarator) ~> struct-aux(X:Id, K:K, L:List{KResult})] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [union-aux(X:Id, (Field(T:TogetherList, D:Declarator) ~> K:K), L:List{KResult}) => Field(T:TogetherList, D:Declarator) ~> union-aux(X:Id, K:K, L:List{KResult})] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [typedField(T:Type, X:Id) ~> struct-aux(X':Id, K:K, L:List{KResult}) => struct-aux(X':Id, K:K, (L:List{KResult},, typedField(T:Type, X:Id)))] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [typedField(T:Type, X:Id) ~> union-aux(X':Id, K:K, L:List{KResult}) => union-aux(X':Id, K:K, (L:List{KResult},, typedField(T:Type, X:Id)))] ...</ k >
		: KSentence [metadata "structural"] .
	mb rule 
		< k > ['Field(T:Type,, X:Id) => typedField(T:Type, X:Id)] ...</ k >
		: KSentence [metadata "structural"] .

	--- fixme gotta be a nicer way to do this
	mb rule
		< k > [struct-aux(X:Id, .K, L:List{KResult}) ~> addGlobalTypes(X:Id) => .K] ...</ k >
		< structs >... [.Map => struct(X:Id) |-> L:List{KResult}] ...</ structs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [union-aux(X:Id, .K, L:List{KResult}) ~> addGlobalTypes(X:Id) => .K] ...</ k >
		< structs >... [.Map => union(X:Id) |-> L:List{KResult}] ...</ structs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, pointerType(T:Type)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> pointerType(T:Type)] ...</ types >
		< typedefs >... [.Map => X:Id |-> pointerType(T:Type)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, structType(S:Id)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> structType(S:Id)] ...</ types >
		< typedefs >... [.Map => X:Id |-> structType(S:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, unionType(S:Id)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> unionType(S:Id)] ...</ types >
		< typedefs >... [.Map => X:Id |-> unionType(S:Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, enumType(X':Id)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> enumType(X':Id)] ...</ types >
		< typedefs >... [.Map => X:Id |-> enumType(X':Id)] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => X:Id |-> T:Base-Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Base-Type] ...</ typedefs >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addGlobalTypes(X:Id, arrayType(T:Type, N:Nat)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ types >
		< typedefs >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		: KSentence [metadata "structural"] .

endm

mod COMMON-LOCAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb rule
		< k > [addTypes(E:Expression, arrayType(T:Type, N:Nat)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, pointerType(T:Type)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, structType(X:Id)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> structType(X:Id)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, unionType(X:Id)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> unionType(X:Id)] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, enumType(X:Id)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> enumType(X:Id)] ...</ types >
		: KSentence [metadata "structural"] .
	--- fixme?
	mb rule
		< k > [addTypes(E:Expression, functionType(T:Type, F:List{K})) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> functionType(T:Type, F:List{K})] ...</ types >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [addTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> T:Base-Type] ...</ types >
		: KSentence [metadata "structural"] .
		

	mb rule
		< k > [tv(N:Nat, ?) ~> addLocals(Loc:Nat) => .K] ...</ k >
		< locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat N:Nat))] ...</ locals >
		: KSentence [metadata "structural"] .
	
	mb rule
		< k > [declare(T:Type, X:Id)
			=> addTypes(X:Id, T:Type) ~> allocate(sizeofType(T:Type)) ~> addLocals(Loc:Nat)] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence [metadata "structural"] .
	mb rule
		< k > [allocate(tv(Len:Nat, ?)) => Len:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> piece(unknown, 8)] ...</ mem >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat Len:Nat] </ nextLoc >
		: KSentence [metadata "structural"] .

endm

mod COMMON-EXPRESSIONS is
	including COMMON-INCLUDE .

	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_+_(tv(I1:Int, cfg:sizeut),, '_*_(sizeofType(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if hasIntegerType(T:Type)
		andBool T':Type =/=Bool void
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_+_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if hasIntegerType(T:Type)
		: KSentence .
	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_-_(tv(I1:Int, cfg:sizeut),, '_*_(sizeofType(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_-_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if hasIntegerType(T:Type)
		: KSentence .

	mb [pointer-difference]: rule [tv(I1:Int, pointerType(T:Type)) - tv(I2:Int, pointerType(T:Type)) 
	=> tv(_-Int_(I1:Int, I2:Int), cfg:ptrdiffut)]
		: KSentence .
		
	--- fixme ignoring qualified types
	mb rule [cast(qualifiedType(T:Type, ?), V:Value) => cast(T:Type, V:Value)] 
		: KSentence .	
	
	--- fixme not sure which is correct
	mb rule [tv(I1:Rat, T:Type) + tv(I2:Rat, T:Type) => interpret(I1:Rat +Rat I2:Rat, T:Type)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [_-_(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) => cast(T:Type, _-Int_(I1:Int,I2:Int))] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) * tv(I2:Int, T:Type) => cast(T:Type, I1:Int *Int I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) / tv(I2:Int, T:Type) => cast(T:Type, I1:Int /Int I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) % tv(I2:Int, T:Type) => cast(T:Type, I1:Int %Int I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [-un tv(I1:Int, T:Type) => cast(T:Type, -Int_(I1:Int))] 
		if hasIntegerType(T:Type)
		: KSentence .
	
		
		
	mb rule [tv(I:Int, T:Type) >> tv(N:Nat, T':Type) => cast(T:Type, I:Int >>Int N:Nat)] 
		if hasIntegerType(T:Type)
		andBool hasIntegerType(T':Type)
		: KSentence .
	mb rule [tv(I:Int, T:Type) << tv(N:Nat, T':Type) => cast(T:Type, I:Int <<Int N:Nat)] 
		if hasIntegerType(T:Type)
		andBool hasIntegerType(T':Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) | tv(I2:Int, T:Type) => cast(T:Type, I1:Int |Int I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) &binop tv(I2:Int, T:Type) => cast(T:Type, I1:Int &Int I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	--- fixme not exactly
	mb rule [~ tv(I:Int, T:Type) => cast(T:Type, ~Int I:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule [tv(I1:Int, T:Type) ^ tv(I2:Int, T:Type) => cast(T:Type, I1:Int xorInt I2:Int)] 
		if hasIntegerType(T:Type)
		: KSentence .
		
	--- floats
	--- fixme
	mb rule [tv(F1:Float, T:Type) + tv(F2:Float, T:Type) => cast(T:Type, F1:Float +Float F2:Float)] 
		: KSentence .
	mb rule [_-_(tv(F1:Float, T:Type), tv(F2:Float, T:Type)) => cast(T:Type, _-Float_(F1:Float, F2:Float))]
		: KSentence .
	mb rule [tv(F1:Float, T:Type) * tv(F2:Float, T:Type) => cast(T:Type, F1:Float *Float F2:Float)] 
		: KSentence .
	mb rule [tv(F1:Float, T:Type) / tv(F2:Float, T:Type) => cast(T:Type, F1:Float /Float F2:Float)] 
		: KSentence .
	mb rule [-un tv(F:Float, T:Type) => cast(T:Type, -Float_(F:Float))] 
		: KSentence .
		
	mb rule [tv(F1:Float, T:Type) < tv(F2:Float, T:Type) => if (F1:Float <Float F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(F1:Float, T:Type) <= tv(F2:Float, T:Type) => if (F1:Float <=Float F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(F1:Float, T:Type) > tv(F2:Float, T:Type) => if (F1:Float >Float F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(F1:Float, T:Type) >= tv(F2:Float, T:Type) => if (F1:Float >=Float F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(F1:Float, T:Type) == tv(F2:Float, T:Type) => if (F1:Float ==Bool F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(F1:Float, T:Type) != tv(F2:Float, T:Type) => if (F1:Float =/=Bool F2:Float) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [!(tv(F:Float, T:Type)) => if (F:Float ==Bool 0.0) then tv(1, int) else tv(0, int) fi] : KSentence .
		
	--- --- mb rule [~ I:Int => ~Int I:Int] : KSentence .
	
	mb rule [tv(I1:Int, T:Type) < tv(I2:Int, T:Type) => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) <= tv(I2:Int, T:Type) => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) > tv(I2:Int, T:Type) => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) >= tv(I2:Int, T:Type) => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) == tv(I2:Int, T:Type) => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) != tv(I2:Int, T:Type) => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [!(tv(I:Int, T:Type)) => if (I:Int ==Bool 0) then tv(1, int) else tv(0, int) fi] : KSentence .
endm

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including SIZEOF .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-LOCAL-DECLARATION .
	including COMMON-C-STANDARD-LIBRARY .
	including COMMON-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	including TYPES .
	
	mb rule [EmptyStatement ; => .K] : KSentence [metadata "structural"] .
	
	--- mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	--- fixme problem with strict operator and context?
	---op assign : K K -> K [metadata "strict 2"] .
	op assign : K K -> K .
	mb context &([HOLE] -> X:Id) : KSentence .
	mb context assign(Deref([HOLE]), ?) : KSentence .
	mb context assign(?, [HOLE]) : KSentence .

	op eval : Program -> Bag .
	op eval : Program List{K} String -> Bag .
	
	---eq eval(P:Program) = eval(P:Program, "") .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
		
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
		
	---c99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented.
***(
											Octal or Hexadecimal 
Suffix			Decimal Constant			Constant
------------------------------------------------------------------
none			int							int
				long int					unsigned int
				long long int				long int
											unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
u or U			unsigned int 				unsigned int
				unsigned long int 			unsigned long int
				unsigned long long int 		unsigned long long int
------------------------------------------------------------------
l or L			long int 					long int
				long long int 				unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long int 			unsigned long int
and l or L 		unsigned long long int 		unsigned long long int
------------------------------------------------------------------
ll or LL 		long long int				long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long long int 		unsigned long long int
and ll or LL
------------------------------------------------------------------
***)
	---c99 6.4.4.1:6 If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value. If all of the types in the list for the constant are signed, the extended integer type shall be signed. If all of the types in the list for the constant are unsigned, the extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.
	---c99 6.2.5:4 ... There may also be implementation-defined extended signed integer types. ...
	
	mb rule < k > [I:Int => 
		if ((I:Int <=Int max(int)) andBool (I:Int >=Int min(int))) then tv(I:Int, int) else
			if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
				if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		] ...</ k > 
		: KSentence .
		
	mb rule [@U(I:Int) => 
		if ((I:Int <=Int max(unsigned-int)) andBool (I:Int >=Int min(unsigned-int))) then tv(I:Int, unsigned-int) else
			if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
				if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		]
		: KSentence .
	mb rule [@L(I:Int) => 
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
			if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		]
		: KSentence .
	mb rule [@UL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
			if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		]
		: KSentence .
	mb rule [@LL(I:Int) => 
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi
		]
		: KSentence .
	mb rule [@ULL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
			tv(I:Int, no-type)
		fi
		]
		: KSentence .
		
		
	---C99 6.4.4.2:4 An unsuffixed floating constant has type double. If suffixed by the letter f or F, it has type float. If suffixed by the letter l or L, it has type long double.
	mb rule < k > [F:Float => tv(F:Float, double)] ...</ k > 
		: KSentence .
	mb rule [@L(F:Float) => tv(F:Float, long-double)]
		: KSentence .
	mb rule [@F(F:Float) => tv(F:Float, float)]
		: KSentence .
		
	--- skip labels
	mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).
		
	
	---C99 6.5.3.2 (p79) footnote 90) Thus, &*E == E; &(E1[E2]) == (E1 + E2)
	
	---C99 6.5.3.2 90) ... It is always true that if E is a function designator or an lvalue that is a valid operand of the u of the unary & operator, *&E is a function designator or an lvalue equal to E.
	
	mb [for-assignment]: rule < k > [E1:Expression := E2:Expression => assign(Deref(&(E1:Expression)),  E2:Expression)] ...</ k > : KSentence .
	
	mb rule [&(Deref(E:Expression)) => E:Expression] : KSentence [metadata "structural"] .
	mb rule [&(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression] : KSentence [metadata "structural"] .
	
	--- can't be done anywhere because same syntax as in declarations
	mb rule < k > [E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression)] ...</ k > : KSentence [metadata "structural"] .
		
	---C99 6.5.3.2:4 The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
	--- also see 6.3.2.1:3 for why i made the result a pointerType
	mb rule < k > [Deref(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) => tv(Loc:Nat, pointerType(T:Type))] ...</ k > : KSentence [metadata "structural"] .

	mb [lookup-function] : rule 
		< k > [Deref(tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
	: KSentence [metadata "structural"] .
	
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
		
	--- remove empty global
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- fixme
	--- 6.5.16
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	mb [assign-mod]: rule [E1:Expression %= E2:Expression => E1:Expression := E1:Expression % E2:Expression] : KSentence .
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-lshift]: rule [E1:Expression <<= E2:Expression => E1:Expression := E1:Expression << E2:Expression] : KSentence .
	mb [assign-rshift]: rule [E1:Expression >>= E2:Expression => E1:Expression := E1:Expression >> E2:Expression] : KSentence .
	mb [assign-bit-and]: rule [E1:Expression &binop= E2:Expression => E1:Expression := E1:Expression &binop E2:Expression] : KSentence .
	mb [assign-bit-xor]: rule [E1:Expression ^= E2:Expression => E1:Expression := E1:Expression ^ E2:Expression] : KSentence .
	mb [assign-bit-or]: rule [E1:Expression |= E2:Expression => E1:Expression := E1:Expression | E2:Expression] : KSentence .
	
	op readFromMem : Nat Type -> K .
	--- location, result type, num bytes, result 
	op readFromMem-aux : Nat Type K List{K} -> K [metadata "strict(3)"] .
	eq readFromMem(N:Nat, T:Type) = readFromMem-aux(N:Nat, T:Type, sizeofType(T:Type), .List{K}) [metadata "strict(3)"] .

	--- generic lookup
	--- fixme don't need all these, adjust for array
	mb [lookup]: rule
		< k > [I:Id => readFromMem(Loc:Nat, T:Base-Type)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> T:Base-Type ...</ types >
		: KSentence .
	mb [lookup-struct]: rule
		< k > [I:Id => readFromMem(Loc:Nat, structType(S:Id))] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> structType(S:Id) ...</ types >
		: KSentence .
	mb [lookup-pointer]: rule
		< k > [I:Id => readFromMem(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> pointerType(T:Type) ...</ types >
		: KSentence .

	mb rule
		< k > [readFromMem-aux(Loc:Nat, T:Type, tv(0, ?), L:List{K}) 
		=> concretize(atv(L:List{K}, T:Type))] ...</ k >
		: KSentence .
	
	mb [read-byte]: rule
		< k > [readFromMem-aux(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), L:List{K})
		=> readFromMem-aux(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), (L:List{K},, piece(N:Nat, 8)))] ...</ k >
		< mem >... Loc:Nat |-> piece(N:Nat, 8) ...</ mem >
		: KSentence .
		
	mb [read-float]: rule
		< k > [readFromMem-aux(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), L:List{K})
		=> readFromMem-aux(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), (L:List{K},, F:Float))] ...</ k >
		< mem >... Loc:Nat |-> F:Float ...</ mem >
		: KSentence .

	mb rule [interpret(N:Nat, T:Type) => tv(N:Nat, T:Type)]
		if min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	mb rule [interpret(N:Nat, enumType(X:Id)) => tv(N:Nat, enumType(X:Id))]
		if min(enumType(X:Id)) <=Int N:Nat andBool max(enumType(X:Id)) >=Int N:Nat
		: KSentence [metadata "structural"] .
	mb rule [interpret(N:Rat, T:Type) => tv(N:Rat, T:Type)]
		if min(T:Type) <=Rat N:Rat andBool max(T:Type) >=Rat N:Rat
		andBool hasIntegerType(T:Type)
		: KSentence [metadata "structural"] .
	--- fixme look at promotions to do this correct
	mb rule [interpret(N:Nat, bitfieldType(T:Type, Len:Nat)) => tv(N:Nat, T:Type)]
		if 0 <=Int N:Nat 
		andBool _-Int_(2 ^Nat Len:Nat, 1) >=Int N:Nat
		: KSentence [metadata "structural"] .
		
	--- fixme not sure about this
	--- interpret is used to "cast" values read from memory
	--- signed arithmetic isn't supposed to overflow
	mb rule
		[interpret(N:Nat, T:Type) => tv(_-Int_(N:Nat, (2 ^Nat absInt(numBits(T:Type)))), T:Type)]
		if notBool(min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat)
		andBool (N:Nat >Int max(T:Type))
		andBool hasIntegerType(T:Type)
		: KSentence .
	
	--- fixme not necessarily the case that pointers are unsigned-ints
	mb rule [interpret(N:Nat, pointerType(T:Type)) => tv(N:Nat, pointerType(T:Type))]
		if min(unsigned-int) <=Int N:Nat andBool max(unsigned-int) >=Int N:Nat
		: KSentence [metadata "structural"] .


	op concretize-aux : Value Nat -> K .
	ceq concretize(atv(L:List{K}, T:Type)) = concretize-aux(atv(L:List{K}, T:Type), 0) 
		if hasIntegerType(T:Type) .
	eq concretize(atv((F:Float,, L:List{K}), float)) = tv(F:Float, float) .
	eq concretize(atv((F:Float,, L:List{K}), double)) = tv(F:Float, double) .
	--- fixme for now
	eq concretize(atv(L:List{K}, pointerType(T:Type))) = concretize-aux(atv(L:List{K}, pointerType(T:Type)), 0) .
	eq concretize(atv(L:List{K}, structType(X:Id))) = atv(L:List{K}, structType(X:Id)) .
	eq concretize(atv(L:List{K}, unionType(X:Id))) = atv(L:List{K}, unionType(X:Id)) .
	
	eq concretize-aux(atv((L:List{K},, piece(N':Nat, Len:Nat)), T:Type), N:Nat) 
		= concretize-aux(atv(L:List{K}, T:Type), (N:Nat <<Nat Len:Nat) |Nat N':Nat) .
	eq concretize-aux(atv(.List{K}, T:Type), N:Nat)
		= interpret(N:Nat, T:Type) .
		
	---C99 6.3.2.1:3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type "array of type" is converted to an expression with type "pointer to type" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
	mb rule
		< k > [X:Id => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> arrayType(T:Type, N:Nat) ...</ types >
		: KSentence .
		
	---C99 6.3.2.1:4 A function designator is an expression that has function type.  Except when it is the operand of the sizeof operator or the unary & operator, a function designator with type "function returning T" is converted to an expression that has type "pointer to a function returning T"
	mb [lookup-closure]: rule
		< k > [X:Id => tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> functionType(T:Type, L:List{K}) ...</ types >
		: KSentence .
				
	op allocString : String -> K .
	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [.K => allocString(S:String)] ~> S:String ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > M:Map [.Map => S:String |-> tv(Loc:Nat, arrayType(char, lengthString(S:String) +Nat 1))] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => tv(N:Nat, pointerType(T:Type))] ...</ k >
		< statics >... S:String |-> tv(N:Nat, arrayType(T:Type, ?)) ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> piece(charToAscii(firstChar(S:String)), 8)] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> piece(0, 8)] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	
	mb [assign]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:Int, T:Type)) 
		=> putInMem(Loc:Nat, tv(V:Int, T:Type), T:Type, sizeofType(T:Type)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	mb [assign-bitfield]: rule
		< k > [assign(Deref(tv(pair(N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))), tv(V:Int, T:Type)) 
		=> putInMem(pair(N:Nat, O:Nat), tv(V:Int, T:Type), T:Type, tv(Len:Nat, cfg:sizeut)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	--- mb [assign-bitfield]: rule
		--- < k > [assign(Deref(tv(N:Nat, pointerType(bitfieldType(T:Type, Len:Nat)))), tv(V:Int, T:Type)) 
		--- => putInMem(pair(N:Nat, 0), tv(V:Int, T:Type), T:Type, tv(Len:Nat, cfg:sizeut)) ~> tv(V:Int, T:Type)] ...</ k >
		--- : KSentence .
	--- fixme this is to get around L:List{K} not comparing equal
	mb [assign-fp]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(pointerType(functionType(T:Type, L:List{K}))))), tv(V:Int, pointerType(functionType(T:Type, L':List{K})))) 
		=> putInMem(Loc:Nat, tv(V:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L:List{K})), sizeofType(pointerType(functionType(T:Type, L:List{K})))) ~> tv(V:Int, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		: KSentence .
		
	--- fixme floats might have requirements
	mb [assign-double]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(double))), tv(V:Float, double)) 
		=> tv(V:Float, double)] ...</ k >
		< mem > [M:Map => M:Map[V:Float / Loc:Nat]] </ mem > 
		: KSentence .
	--- fixme
	mb [assign-float]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(float))), tv(V:Float, float)) 
		=> tv(V:Float, float)] ...</ k >
		< mem > [M:Map => M:Map[V:Float / Loc:Nat]] </ mem > 
		: KSentence .
		
	op assertEqual : K K -> K [metadata "strict"] .
	mb [assign-struct]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), atv(L:List{K}, T:Type))
		=> 
		---assertEqual(sizeof(T:Type), length(L:List{K})) ~> 
		putBytesInMem(Loc:Nat, L:List{K}, T:Type, sizeofType(T:Type)) ~> atv(L:List{K},T:Type)] ...</ k >
		: KSentence	.
	
	--- fixme not enough, need more rules
	--- fixme is this backwards?
	mb rule
		< k > [putBytesInMem(Loc:Nat, (piece(N:Nat, BitLen:Nat),, piece(N':Nat, 1),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putBytesInMem(Loc:Nat, (piece((N':Nat <<Nat BitLen:Nat) |Nat N:Nat, sNat(BitLen:Nat)),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type))] ...</ k >
		if BitLen:Nat <Nat 8
		: KSentence .
	mb rule
		< k > [putBytesInMem(Loc:Nat, (piece(N:Nat, 8),, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(sNat(Loc:Nat), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		< mem >... Loc:Nat |-> [? => piece(N:Nat, 8)] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBytesInMem(Loc:Nat, (F:Float,, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(sNat(Loc:Nat), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		< mem >... Loc:Nat |-> [? => F:Float] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBytesInMem(Loc:Nat, .List{K}, T:Type, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	
	op putByteInMem : Nat BaseValue -> K .
	op putBitInMem : BaseValue BaseValue -> K .
	mb rule
		< k > [putInMem(?, ?, ?, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		=> putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putByteInMem(Loc:Nat, ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(sNat(Loc:Nat), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(F:Float, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) => .K] ...</ k >
		< mem >... Loc:Nat |-> [? => F:Float] ...</ mem >
		if (T:Type ==Bool double)
		orBool T:Type ==Bool float
		: KSentence .
		
	mb rule
		< k > [putInMem(pair(Base:Nat, Offset:Nat), tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putBitInMem(pair(Base:Nat, Offset:Nat), ((N:Int %Int 2) +Int 2) %Int 2) ~> putInMem(pair(Base:Nat, sNat(Offset:Nat)), tv(N:Int >>Int 1, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		if Offset:Nat % 8 =/=Bool 0
		: KSentence .
		
	mb rule
		< k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		< mem >... Loc:Nat |-> [? => piece(N:Nat, 8)] ...</ mem >
		: KSentence .
	--- fixme probably a better way to do this
	mb rule
		< k > putBitInMem(pair(Base:Nat, ?), ?) ...</ k >
		< mem >... Base:Nat |-> [piece(unknown, 8) => piece(0, 8)] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBitInMem(pair(Base:Nat, Offset:Nat), N:Nat) => .K] ...</ k >
		< mem >... Base:Nat |-> [piece(Old:Nat, 8) => 
		piece((Old:Nat &Nat ((1 <<Nat Offset:Nat) xorNat 255)) |Nat (N:Nat <<Nat Offset:Nat), 8)
		] ...</ mem >
		: KSentence .

	mb [ref]: rule
		< k > [&(X:Id) => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		: KSentence .
		
	--- fixme this is crazy
	--- if label not arrayType?
	op fixPointerType : Type -> Type .
	eq fixPointerType(T:Base-Type) = pointerType(T:Base-Type) .
	eq fixPointerType(arrayType(T:Type, ?)) = pointerType(T:Type) .
	eq fixPointerType(structType(X:Id)) = pointerType(structType(X:Id)) .
	eq fixPointerType(unionType(X:Id)) = pointerType(unionType(X:Id)) .
	eq fixPointerType(pointerType(T:Type)) = pointerType(pointerType(T:Type)) .
	eq fixPointerType(bitfieldType(T:Type, N:Nat)) = pointerType(bitfieldType(T:Type, N:Nat)) .
	eq fixPointerType(bitfieldType(T:Type, N:Nat)) = pointerType(bitfieldType(T:Type, N:Nat)) .
	
	op figureOffset : Nat K Type -> K [metadata "strict(2)"] .
	op pair : Rat Rat -> BaseValue .
	ceq figureOffset(Base:Nat, tv(R:Rat, ?), T:Type) = tv(pair(Base:Nat +Rat truncRat(R:Rat),_-Rat_(R:Rat, truncRat(R:Rat)) *Rat 8), pointerType(void))
	if T:Type isa 'bitfieldType .
	ceq figureOffset(Base:Nat, tv(R:Rat, ?), T:Type) = tv(truncRat((Base:Nat +Rat R:Rat) +Rat (7 /Rat 8)), pointerType(void))
	if notBool(T:Type isa 'bitfieldType) .

	mb [address-of-arrow-struct]: rule
		< k > [&(tv(Base:Nat, pointerType(structType(S:Id))) -> X:Id) => cast(fixPointerType(T:Type), figureOffset(Base:Nat, calcStructSize-aux(L1:List{KResult}, 0), T:Type))] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
	mb [address-of-arrow-union]: rule
		< k > [&(tv(Base:Nat, pointerType(unionType(S:Id))) -> X:Id) => cast(fixPointerType(T:Type), tv(Base:Nat, pointerType(void)))] ...</ k >
		< structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
		
	mb [address-of-dot]: rule
		< k > [&(E:Expression . X:Id) => &((&(E:Expression)) -> X:Id)] ...</ k >
		: KSentence .
	
	mb [arrow]: rule
		< k > [tv(Base:Int, pointerType(structType(S:Id))) -> X:Id => Deref(tv(Base:Int, pointerType(structType(S:Id)))) . X:Id] ...</ k >
		: KSentence .

	op extractField : List{K} Type Id -> K .
	op extractField-pre : List{K} Type K K -> K [metadata "strict(3 4)"] .
	op extractField-aux : List{K} Type Nat Nat List{K} -> K .
	---figureOffset(Base:Nat, tv(R:Rat, ?), T:Type)
	--- mb rule
		--- < k > [extractField(L:List{K}, structType(S:Id), F:Id) 
			--- => extractField-pre(L:List{K}, T:Type, calcStructSize-aux(L1:List{KResult}, 0), sizeofType(T:Type))] ...</ k >
		--- < structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, F:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence .
	mb rule
		< k > [extractField(L:List{K}, structType(S:Id), F:Id) 
			=> extractField-pre(L:List{K}, T:Type, figureOffset(0, calcStructSize-aux(L1:List{KResult}, 0), T:Type), sizeofType(T:Type))] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, F:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
	mb rule
		< k > [extractField(L:List{K}, unionType(S:Id), F:Id) 
			=> extractField-pre(L:List{K}, T:Type, tv(0, cfg:sizeut), sizeofType(T:Type))] ...</ k >
		< structs >... union(S:Id) |-> (?:List{KResult},, typedField(T:Type, F:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
	mb rule
		< k > [extractField-pre(L:List{K}, T:Type, tv(pair(Offset1:Nat, Offset2:Nat), ?),  tv(Len:Rat, ?)) 
			=> extractField-aux(explodeToBits(L:List{K}), T:Type, Offset1:Nat *Nat 8 +Nat Offset2:Nat, absInt(truncRat(Len:Rat *Rat 8)), .List{K})] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-pre(L:List{K}, T:Type, tv(Offset:Nat, ?), tv(Len:Rat, ?)) 
			=> extractField-aux(explodeToBits(L:List{K}), T:Type, Offset:Nat *Nat 8, absInt(truncRat(Len:Rat *Rat 8)), .List{K})] ...</ k >
		: KSentence .
		
	op explodeToBits : List{K} -> List{K} .
		
	eq explodeToBits((K:K,, L:NeList{K})) = (explodeToBits(K:K),, explodeToBits(L:NeList{K})) .
	eq explodeToBits(piece(N:Nat, sNat(Len:Nat)))
		= (piece(N:Nat &Nat 1, 1),, explodeToBits(piece(N:Nat >>Nat 1, Len:Nat))) .
	eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	eq explodeToBits(piece(N:Nat, 0)) = .List{K} .
	eq explodeToBits(.List{K}) = .List{K} .
	
	mb rule
		< k > [extractField-aux((piece(?, 1),, L:List{K}), T:Type, sNat(Offset:Nat), Len:Nat, .List{K})
		=> extractField-aux(L:List{K}, T:Type, Offset:Nat, Len:Nat, .List{K})] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux((explodeToBits(?:Float),, L:List{K}), T:Type, sNat(sNat(sNat(sNat(sNat(sNat(sNat(sNat(Offset:Nat)))))))), Len:Nat, .List{K})
		=> extractField-aux(L:List{K}, T:Type, Offset:Nat, Len:Nat, .List{K})] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux((piece(N:Nat, 1),, L:List{K}), T:Type, 0, sNat(Len:Nat), L':List{K})
		=> extractField-aux(L:List{K}, T:Type, 0, Len:Nat, (L':List{K},, piece(N:Nat, 1)))] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux((explodeToBits(F:Float),, L:List{K}), T:Type, 0, sNat(sNat(sNat(sNat(sNat(sNat(sNat(sNat(Len:Nat)))))))), L':List{K})
		=> extractField-aux(L:List{K}, T:Type, 0, Len:Nat, (L':List{K},, F:Float))] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux((explodeToBits(F:Float),, L:List{K}), float, 0, ?, .List{K})
		=> tv(F:Float, float)] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux((F:Float,, L:List{K}), double, 0, ?, .List{K})
		=> tv(F:Float, double)] ...</ k >
		: KSentence .
	mb rule
		< k > [extractField-aux(?, T:Type, 0, 0, L:List{K})
		=> concretize(atv(L:List{K}, T:Type))] ...</ k >
		: KSentence .
	
	op dot-aux : K Id K -> K [metadata "strict(3)"] .
	mb rule
		< k > [(E:Expression . F:Id) => dot-aux(E:Expression, F:Id, typeof(E:Expression . F:Id))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, arrayType(?, ?)) => &(E:Expression . F:Id)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, T:Base-Type) => E:Expression ~> dot-aux(HOLE, F:Id, T:Base-Type)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, pointerType(T:Type)) => E:Expression ~> dot-aux(HOLE, F:Id, pointerType(T:Type))] ...</ k >
		: KSentence .
	--- fixme is this right?  not tested
	mb rule
		< k > [dot-aux(E:Expression, F:Id, structType(X:Id)) => E:Expression ~> dot-aux(HOLE, F:Id, structType(X:Id))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, unionType(X:Id)) => E:Expression ~> dot-aux(HOLE, F:Id, unionType(X:Id))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, bitfieldType(T:Type, N:Nat)) => E:Expression ~> dot-aux(HOLE, F:Id, bitfieldType(T:Type, N:Nat))] ...</ k >
		: KSentence .
		
	mb rule
		< k > [atv(L:List{K}, T:Type) ~> dot-aux(HOLE, F:Id, ?) => extractField(L:List{K}, T:Type, F:Id)] ...</ k >
		: KSentence .	
	
	--- only have to make T' =/= T'' because of figureOffset
	--- mb [extractField-shift-bitfield]: rule
		--- < k > [extractField((K:K,, L:List{K}), T:Type, V:Value, tv(pair(sNat(Base:Nat), Offset:Nat), T':Type), tv(0, T:Type), 0) => extractField(L:List{K}, T:Type, V:Value, tv(pair(Base:Nat, Offset:Nat), T':Type), tv(0, T:Type), 0)] ...</ k >
		--- : KSentence .
	--- mb [extractField-shift-bitfield-combine]: rule
		--- < k > [extractField((L:List{K},, N:Nat,, N':Nat), T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), tv(0, T:Type), 0) => extractField((L:List{K},, (N':Nat <<Nat 8) |Nat N:Nat), T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), tv(0, T:Type), 0)] ...</ k >
		--- : KSentence .
	--- mb [extractField-shift-bitfield-offset]: rule
		--- < k > [extractField(N':Nat, T:Type, V:Value, tv(pair(0, sNat(Offset:Nat)), T':Type), tv(0, T:Type), 0) => extractField(N':Nat >>Nat 1, T:Type, V:Value, tv(pair(0, Offset:Nat), T':Type), tv(0, T:Type), 0)] ...</ k >
		--- : KSentence .
	--- mb [extractField-shift]: rule
		--- < k > [extractField((K:K,, L:List{K}), T:Type, V:Value, tv(sNat(Offset:Nat), T':Type), tv(0, T:Type), 0) => extractField(L:List{K}, T:Type, V:Value, tv(Offset:Nat, T':Type), tv(0, T:Type), 0)] ...</ k >
		--- : KSentence .
		
	--- mb [extractField-grab-normal]: rule
		--- < k > [extractField((N':Nat,, L:List{K}), T:Type, tv(sNat(Left:Nat), T':Type), tv(0, T'':Type), tv(N:Nat, T:Type), Len:Nat) 
		--- => extractField(L:List{K}, T:Type, tv(Left:Nat, T':Type), tv(0, T'':Type), tv(N:Nat |Nat (N':Nat <<Nat (8 *Nat Len:Nat)), T:Type), sNat(Len:Nat))]
		--- ...</ k > : KSentence .
	--- mb [extractField-grab-bitfield]: rule
		--- < k > [extractField(N':Nat, T:Type, tv(Left:Rat, T':Type), tv(pair(0, 0), T'':Type), tv(N:Nat, T:Type), Len:Rat) 
		--- => extractField((N':Nat >>Nat 1), T:Type, tv(_-Rat_(Left:Rat, 1 /Rat 8), T':Type), tv(0, T'':Type), tv(N:Nat |Nat ((N':Nat &Nat 1) <<Nat absInt(truncRat(8 *Rat Len:Rat))), T:Type), Len:Rat +Rat (1 /Rat 8))] ...</ k > 
		--- if Left:Rat =/=Bool 0
		--- andBool (8 *Rat Len:Rat) ==Bool truncRat(8 *Rat Len:Rat)
		--- : KSentence .
	
	--- fixme this is terrible
	--- mb [extractField-grab-union]: rule
		--- < k > [extractField(L:List{K}, unionType(X:Id), tv(Left:Nat, T':Type), tv(0, T'':Type), tv(0, unionType(X:Id)), Len:Nat) 
		--- => extractField(L:List{K}, unionType(X:Id), tv(Left:Nat, T':Type), tv(0, T'':Type), unionVal(.List{K}, unionType(X:Id)), Len:Nat)]
		--- ...</ k > : KSentence .
	--- mb [extractField-grab-union]: rule
		--- < k > [extractField((V:BaseValue,, L:List{K}), T:Type, tv(sNat(Left:Nat), T':Type), tv(0, T'':Type), unionVal(L':List{K}, T:Type), Len:Nat) 
		--- => extractField(L:List{K}, T:Type, tv(Left:Nat, T':Type), tv(0, T'':Type), unionVal((L':List{K},,V:BaseValue), T:Type), sNat(Len:Nat))]
		--- ...</ k > : KSentence .
	--- --- fixme floats doubles
	--- mb [extractField-grab-double]: rule
		--- < k > [extractField((F:Float,, L:List{K}), double, tv(?, T':Type), tv(0, T'':Type), tv(0, T:Type), 0) 
		--- => tv(F:Float, double)]
		--- ...</ k > : KSentence .
	--- mb [extractField-grab-float]: rule
		--- < k > [extractField((F:Float,, L:List{K}), float, tv(?, T':Type), tv(0, T'':Type), tv(0, T:Type), 0) 
		--- => tv(F:Float, float)]
		--- ...</ k > : KSentence .

	--- mb [extractField-done]: rule
		--- < k > [extractField(?, T:Type, tv(0, T':Type), tv(0, T'':Type), tv(N:Nat, T:Type), ?) => interpret(N:Nat, T:Type)]
		--- ...</ k >
		--- : KSentence .
	--- mb [extractField-done]: rule
		--- < k > [extractField(?, T:Type, tv(0, T':Type), tv(0, T'':Type), unionVal(L:List{K}, T:Type), ?) => unionVal(L:List{K}, T:Type)]
		--- ...</ k >
		--- : KSentence .
		
	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
		
  	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
  
	mb [function-application-pre]: rule
		< k > [Apply(tv(Loc:Nat, pointerType(functionType(?, ?))), L:List{Expression}) 
		=> Apply(V:Value, L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [function-application]: rule
		< k > [
			Apply(Closure(X:Id, functionType(R:Type, P:List{K}), B:K), L:List{Expression}) ~> K:K 
			=> 
			bind(getList{K}(L:List{Expression}), P:List{K}) ~> B:K
		] </ k >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< types > [T:Map => GT:Map] </ types >
		< typedefs > GT:Map </ typedefs >
		< loopStack > [LS:List => .List] </ loopStack >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
				< types > T:Map </ types >
				< loopStack > LS:List </ loopStack >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	
	mb [deref]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Base-Type))) => readFromMem(Loc:Nat, T:Base-Type)
		] ...</ k >
		: KSentence .
	mb [deref-pointer]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))) => readFromMem(Loc:Nat, pointerType(T:Type))
		] ...</ k >
		: KSentence .
	mb [deref-struct]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(structType(X:Id)))) => readFromMem(Loc:Nat, structType(X:Id))
		] ...</ k >
		: KSentence .
	mb [deref-union]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(unionType(X:Id)))) => readFromMem(Loc:Nat, unionType(X:Id))
		] ...</ k >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement else S':Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (tv(0, ?)) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (tv(0, ?)) S:Statement => .K] ...</ k >
		: KSentence .


	eq integerTypes = Set(char,, signed-char,, unsigned-char,, short-int,, int,, long-int,, long-long-int,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	eq unsignedIntegerTypes = Set(unsigned-char,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	
	mb rule [Cast(T:TogetherList, E:Expression) => cast(T:TogetherList, E:Expression)] : KSentence [metadata "structural rule"] .
	
	mb rule
		< k > [cast(T:Type, tv(B:BaseValue, T:Type)) => tv(B:BaseValue, T:Type)] ...</ k > 
		: KSentence .
	
	---c99 6.3.1.3:1 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged. 
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => tv(I:Int, T:Type)] ...</ k > 
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int 
		andBool hasIntegerType(T':Type)
		andBool hasIntegerType(T:Type)
		: KSentence .
		
	---c99 6.3.1.3:2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int +Int max(T:Type) +Int 1, T':Type))] ...</ k > 
		if notBool(
			min(T:Type) <=Int I:Int 
			andBool max(T:Type) >=Int I:Int 
			andBool hasIntegerType(T':Type)
		)
		andBool unsignedIntegerTypes contains T:Type 
		andBool I:Int <Int min(T:Type)
		andBool hasIntegerType(T':Type)
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int %Int (max(T:Type) +Int 1), T':Type))] ...</ k > 
		if notBool(
			min(T:Type) <=Int I:Int 
			andBool max(T:Type) >=Int I:Int 
			andBool hasIntegerType(T':Type)
		)
		andBool unsignedIntegerTypes contains T:Type 
		andBool I:Int >Int max(T:Type)
		andBool hasIntegerType(T':Type)
		: KSentence .
	
	---c99 6.3.1.3:3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.
	
	---C99 6.3.1.4:1 When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.52) The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (-1, Utype_MAX+1).
	--- fixme
	mb rule
		< k > [cast(T:Type, tv(V:Float, double)) => cast(T:Type, tv(truncRat(float2ratConversion(V:Float)), long-long-int))] ...</ k > 
		if hasIntegerType(T:Type)
		: KSentence .
	
	---C99 6.3.1.4:2 When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined.
	--- fixme not handling floats correctly
	mb rule
		< k > [cast(double, tv(I:Int, T:Type)) => tv(rat2floatConversion(I:Int), double)] ...</ k > 
		if hasIntegerType(T:Type)
		: KSentence .
	mb rule
		< k > [cast(float, tv(I:Int, T:Type)) => tv(rat2floatConversion(I:Int), float)] ...</ k > 
		if hasIntegerType(T:Type)
		: KSentence .
	--- fixme
	mb rule
		< k > [cast(float, tv(F:Float, double)) => tv(F:Float, float)] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(double, tv(F:Float, float)) => tv(F:Float, double)] ...</ k > 
		: KSentence .
	
	--- fixme 6.3.2.3 not handling this correctly
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, T':Type)) => tv(I:Int, pointerType(T:Type))] ...</ k >
		if min(unsigned-int) <=Int I:Int andBool max(unsigned-int) >=Int I:Int andBool hasIntegerType(T':Type)
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(T':Type))) => cast(T:Type, tv(I:Int, unsigned-int))] ...</ k > 
		if hasIntegerType(T:Type)
		: KSentence .
		
	--- fixme not sure where it says this
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, arrayType(T:Type, ?))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, pointerType(void))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(void), tv(I:Int, pointerType(T:Type))) => tv(I:Int, pointerType(void))] ...</ k > 
		: KSentence .
	--- possibly not true with other endiannesses
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, pointerType(?))) => tv(I:Int, pointerType(T:Type))] ...</ k >
		if min(unsigned-int) <=Int I:Int andBool max(unsigned-int) >=Int I:Int
		: KSentence .
	--- fixme not sure about this either...
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(arrayType(T':Type, ?)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		: KSentence .
	--- fixme ridiculous.
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(structType(S:Id)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		< structs >... struct(S:Id) |-> (typedField(T':Type, ?),, ?:List{KResult}) ...</ structs >
		: KSentence .
		
	--- fixme not sure why this comes up, i think because we have no extended types
	mb rule
		< k > [cast(T:Type, tv(I:Int, no-type)) 
		=> interpret(I:Int, T:Type)] ...</ k >
		if unsignedIntegerTypes contains T:Type 		
		: KSentence .
		
	mb rule
		< k > [cast(pointerType(bitfieldType(T:Type, Len:Nat)), tv(pair(N:Nat, O:Nat), pointerType(?)))
		=> tv(pair(N:Nat, O:Nat), pointerType(bitfieldType(T:Type, Len:Nat)))] ...</ k > 
		: KSentence .
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(popLoop, K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K] </ k >
		< loopStack > ListItem(K:K) ...</ loopStack >
		: KSentence .

	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	op postInc : K K Type -> K [metadata "strict(2)"] .
	op postDec : K K Type -> K [metadata "strict(2)"] .
	mb [post-increment-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) ++
		=> postInc(Loc:Nat, readFromMem(Loc:Nat, T:Type), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) + tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if hasIntegerType(T:Type)
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) + tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .
		
	mb [post-decrement-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) --
		=> postDec(Loc:Nat, readFromMem(Loc:Nat, T:Type), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) - tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if hasIntegerType(T:Type)
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) - tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .

	mb [discard]: rule
		< k > [V:Value ~> discard => .K] ...</ k >
		: KSentence .
	
	mb context 'switch`(_`)_(?,, 'Block(? ~> 'case_:_(`[HOLE`]:K,, ?) ~> ?)) : KSentence .

	mb [switch]: rule
		< k > ['switch`(_`)_(V:Value,, 'Block(? ~> 'case_:_(V:Value,, K1:K) ~> K2:K)) => K1:K ~> K2:K ~> popLoop] ~> K:K </ k >
		< loopStack > [.List => ListItem(_~>_(popLoop, K:K))] ...</ loopStack >
		: KSentence .
	mb [switch-default]: rule
		< k > ['switch`(_`)_(?,, 'Block('default`:_(K1:K) ~> K2:K)) => K1:K ~> K2:K ~> popLoop] ~> K:K </ k >
		< loopStack > [.List => ListItem(_~>_(popLoop, K:K))] ...</ loopStack >
		: KSentence .
		
	mb [switch-notcase]: rule
		< k > 'switch`(_`)_(V:Value,, 'Block(['case_:_(V':Value,, ?) => .K] ~> ?)) ...</ k >
		if V:Value =/=Bool V':Value
		: KSentence .
	mb [switch-badcode]: rule
		< k > 'switch`(_`)_(V:Value,, 'Block([KL:KLabel(?) => .K] ~> ?)) ...</ k >
		if KL:KLabel =/=Bool 'case_:_
		andBool KL:KLabel =/=Bool 'default`:_
		: KSentence .

		
	mb [case-pullout]: rule
		['case_:_(K1:K,, K2:K) => 'case_:_(K1:K,, .K) ~> K2:K]
		if K2:K =/=Bool .K
		: KSentence [metadata "structural"] .
		
	mb [case]: rule
		< k > ['case_:_(?,, K:K) => K:K] ...</ k >
		: KSentence .
		
		
	mb [writeToFD-char] : rule
		< k > [writeToFD(FD:Nat, N:Nat) => .K]  ...</ k >
		< openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		< files >... Filename:String |-> [S:String => S:String +String charString(N:Nat %Nat 256)] ...</ files >
		: KSentence .
	mb [writeToFD-string] : rule
		< k > [writeToFD(FD:Nat, S':String) => .K] ...</ k >
		< openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		< files >... Filename:String |-> [S:String => S:String +String S':String] ...</ files >
		: KSentence .
	mb [readFromFD-char] : rule
		< k > [readFromFD(FD:Nat) => tv(charToAscii(firstChar(S:String)), int)]  ...</ k >
		< openFiles >... FD:Nat |-> Filename:String ...</ openFiles >
		< files >... Filename:String |-> [S:String => butFirstChar(S:String)] ...</ files >
		if S:String =/=Bool ""
		: KSentence .
endm


