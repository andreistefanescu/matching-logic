mod COMMON-KERNEL-C-SEMANTICS is
	including KERNEL-C-CONFIGURATION .
	including K-CONTEXTS .
	
	sort Value .
	
	op Closure : Function-Definition -> Value .
	
	mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	
	subsort Int < Value < Expression .
	subsort Value < KResult .
	
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult . 
	op closure : -> KLabel .
	

	op eval : Program -> Bag .

	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
	
	--- lists turn to their id
	---mb rule [_`,List`{Expression`}_(.List{K}) => .List{Expression}] : KSentence .
	
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
	---mb rule [.K S:Statement => .K] : KSentence .
	
	--- remove _;
	--- mb rule [E:Expression ; => E:Expression] : KSentence .
	--- mb rule [D:Declaration ; => D:Declaration] : KSentence .
	
	--- we're ignoring types for now
	mb rule [U(I:Int) => I:Int] : KSentence .
	
	--- dissolve blocks
	mb rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- turn variables into references when appropriate
	mb [make-assign-ref]: rule < k > [I:Id := E:Expression => Deref(&(I:Id)) := E:Expression] ...</ k > : KSentence .
	mb [make-call-ref]: rule < k > [Apply(I:Id, L:List{Expression}) => Apply(Deref(&(I:Id)), L:List{Expression})] ...</ k > : KSentence .
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	
	mb [array-revision]: rule < k > [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] ...</ k > : KSentence .
	
	--- for now, just ignore global wrapper
	---mb [remove-global-marker]: rule [Global(D:Declaration ;) => D:Declaration ;] : KSentence .
	--- for now, just ignore globals
	mb [remove-global-marker]: rule [Global(D:Declaration) => .K] : KSentence .
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	

	----- end simple transformations -----

	mb [terminate]: rule 
		[< T >... < k > V:Value </ k > < output > O:List </ output > ...</ T >
		=>
		< resultValue > V:Value </ resultValue >
		< resultOutput > O:List </ resultOutput >]
		: KSentence .
	
	--- special case lookup for main, since genv hasn't been put into env yet
	mb [lookup-main]: rule
		< k > [main => V:Value] ...</ k >
		< env > .Map </ env >
		< genv >... main |-> Loc:Nat ...</ genv >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => V:Value] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
	
	mb [variable-declaration]: rule
		< k > [Declaration(int, I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [variable-declaration2]: rule
		< k > [Declaration((unsigned-int), I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [pointer-declaration]: rule
		< k > [Declaration((unsigned-int), Pointer(I:Id)) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [array-declaration]: rule
		< k > [Declaration((unsigned-int), X:Id[I:Int]) => .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat absInt(I:Int)) |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, X:Id[I:Int]))] ...</ locals >
		< nextLoc > [Loc:Nat => (sNat(Loc:Nat) +Nat absInt(I:Int))] </ nextLoc >
		if I:Int >=Int 0
		: KSentence .
	
	
	op _to_ : Nat Nat -> List{K} .  
	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
	
	
	***(
	Declaration-Specifiers Identifier(Parameter-Type-List){
		Block-Item-List
	}
	***)
	mb [function-definition]: rule 
		< k > [
			Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List)){
				B:TogetherList
			}
			=> .K]
		...</ k >
		< genv > [E:Map => E:Map[Loc:Nat / I:Id]]  </ genv >
		< mem > [M:Map => M:Map[Closure(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List)){ B:TogetherList }) / Loc:Nat]] </ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	

	op bind : -> KLabel .
	mb [function-application]: rule
		< k > [Apply(Closure(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List)){ B:TogetherList }), L:List{Expression}) ~> K:K => bind(L:List{Expression},, PTL:Parameter-Type-List) ~> B:TogetherList] </ k >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< parameters > [P:Bag => .Bag] </ parameters >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< parameters > P:Bag </ parameters >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
		
	--- empty binding
	mb [bind-empty]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(Parameter-Declaration(void))) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	mb [bind-one-int]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(int, I:Id))) => .K] ...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(int, I:Id))] ...</ parameters >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [bind-one-unsigned-int]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(unsigned-int, I:Id))) => .K] ...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(unsigned-int, I:Id))] ...</ parameters >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .	
		

--- bind(("_`,List`{Expression`}_").KHybridLabel("Int" 2(.List{K})),, ("Parameter-Type-List").KProperLabel(("Parameter-Declaration").KProperLabel(("int").KProperLabel(.List{K}),,("n").KProperLabel(.List{
		
	mb [assign]: rule
		< k > [Deref(Loc:Nat) := V:Value => V:Value] ...</ k >
		< mem >... Loc:Nat |-> [? => V:Value] ...</ mem >
		: KSentence .
		
	mb [equality]: rule
		< k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		: KSentence .
		
	mb [ref]: rule
		< k > [&(I:Id) => Loc:Nat] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		: KSentence .
		
	mb [deref]: rule
		< k > [Deref(Loc:Nat) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (I:Int) S:Statement else S':Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (0) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (I:Int) S:Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (0) S:Statement => .K] ...</ k >
		: KSentence .
		
	--- throwing away casts now
	mb [cast-int]: rule
		< k > [Cast(int, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-long]: rule
		< k > [Cast(unsigned-long, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-int]: rule
		< k > [Cast(unsigned-int, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
		
	
	--------------- Start Expressions ---------------
	mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [- I => -Int I] : KSentence .
	mb rule [I1:Int < I2:Int => if (I1:Int <Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int <= I2:Int => if (I1:Int <=Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int > I2:Int => if (I1:Int >Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int >= I2:Int => if (I1:Int >=Int I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [V1 == V2 => V1 ==Bool V2] : KSentence .
	--- mb rule [V1 != V2 => V1 =/=Bool V2] : KSentence .
	--- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	--- mb rule [not(T) => notBool(T)] : KSentence .
	--------------- End Expressions ---------------
	
	mb [while]: rule
		< k > [while (B:Expression) S:Statement 
		=> 
		if (B:Expression) Block(S:Statement while (B:Expression) S:Statement)
		] ...</ k >
		: KSentence .	
	---mb rule < k > [while B do S  => if B then {S while B do S} else {}] ...</ k > : KSentence .
		
	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-local-array]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id[N:Nat])) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem > [M:Map Loc:Nat |-> Start:Nat => cleanMap(M:Map, Start:Nat, N:Nat)] </ mem >
		: KSentence .
		
	op cleanMap : Map Nat Nat -> Map .
	eq cleanMap((M:Map (N:Nat |-> ?)), N:Nat, sNat(N':Nat)) = cleanMap(M:Map, sNat(N:Nat), N':Nat) .
	eq cleanMap(M:Map, N:Nat, 0) = M:Map .
		
	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(unsigned-int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-params]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-params]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(unsigned-int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< parameters > [.Bag => P:Bag ] </ parameters >
		< locals > [.Bag => L:Bag ] </ locals >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< parameters > P:Bag </ parameters >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	
	mb [post-increment]: rule
		< k > [Deref(Loc:Nat) ++ => V:Int] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => V:Int +Int 1] ...</ mem >
		: KSentence .	
		
	--- keq <k> [[return V ; -> K ==> K'' -> V -> K']] </k>
		--- <env> [[E ==> E']] </env>
		--- <envStack> [[env(E') ==> .nil]] ...</envStack>
		--- <callStack> [[funk(K') ==> .nil]] ...</callStack>
		--- <onReturn> [[K'' ==> .K]] </onReturn>
endm
