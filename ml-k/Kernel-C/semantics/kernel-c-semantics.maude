load kernel-c-syntax

mod KERNEL-C-SEMANTICS is
	---including KERNEL-C-SYNTAX .
	including KERNEL-C-SYNTAX-TEST .
	---including K .

	---subsort AExp BExp Stmt < K .
	subsort Program < K .
	sort Value .
	--- subsort Int < KResult .
	--- subsort Bool < KResult .
	---subsort Id < Identifier . --- hack
	subsort Int < Value < Expression .
	subsort Value < KResult .
	
	op output : -> CellLabel .
	op k : -> CellLabel .
	op env : -> CellLabel .
	op genv : -> CellLabel .
	op mem : -> CellLabel .
	op nextLoc : -> CellLabel .
	op resultValue : -> CellLabel .
	op resultOutput : -> CellLabel .
	
	op callStack : -> CellLabel .
	op stackFrame : -> CellLabel .
	op continuation : -> CellLabel .
	op locals : -> CellLabel .
	op parameters : -> CellLabel .
	
	op List : BagItem -> ListItem .
	
	op unknown : -> K .
	op skipval : -> KResult . 
	
	mb configuration 
		< T > 
			< k > P:Program </ k >
			< env > Env:Map </ env > 
			< genv > GEnv:Map </ genv > 
			< mem > Store:Map </ mem >  
			< output > Output:List </ output > 
			< callStack > Stack:List </ callStack >
			< nextLoc > N:Nat </ nextLoc >
			< locals > Locals:Bag </ locals >
			< parameters > Parameters:Bag </ parameters >
		</ T > 
		< resultValue > V:Value </ resultValue >
		< resultOutput > Output:List </ resultOutput > 
		: KSentence .

	op eval : Program -> Bag .
	eq eval(P:Program) = 
		< T >
			< k > P:Program ~> Apply(main) </ k > 
			< env > .Map </ env > 
			< genv > .Map </ genv > 
			< mem > .Map </ mem >  
			< output > .List </ output >
			< callStack > .List </ callStack >
			< nextLoc > 0 </ nextLoc >
			< locals > .Bag </ locals >
			< parameters > .Bag </ parameters >
		</ T > .
	
	op closure : -> KLabel .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(I:Identifier) => Apply(I:Identifier, .List{Expression})] : KSentence .
	
	--- lists turn to their id
	---mb rule [_`,List`{Expression`}_(.List{K}) => .List{Expression}] : KSentence .
	
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence .
	
	--- remove _;
	--- mb rule [E:Expression ; => E:Expression] : KSentence .
	--- mb rule [D:Declaration ; => D:Declaration] : KSentence .
	
	--- dissolve blocks
	mb rule < k > [Block(B:Block-Item-List) => B:Block-Item-List] ...</ k >	: KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- turn variables into references when appropriate
	--- can't write--- it loops because I can't describe only identifiers
	---mb [make-assign-ref]: rule < k > [I:Identifier := E:Expression => Deref(&(I:Identifier)) := E:Expression] ...</ k > : KSentence .
	---mb [make-call-ref]: rule < k > [Apply(I:Identifier, L:List{Expression}) => Apply(Deref(&(I:Identifier)), L:List{Expression})] ...</ k > : KSentence .
	
	--- for now, just ignore global wrapper
	---mb [remove-global-marker]: rule [Global(D:Declaration ;) => D:Declaration ;] : KSentence .
	--- for now, just ignore globals
	mb [remove-global-marker]: rule [Global(D:Declaration ;) => .K] : KSentence .
	
	----- end simple transformations -----

	mb [terminate]: rule 
		[< T >... < k > V:Value </ k > < output > O:List </ output > ...</ T >
		=>
		< resultValue > V:Value </ resultValue >
		< resultOutput > O:List </ resultOutput >]
		: KSentence .
	
	--- special case lookup for main, since genv hasn't been put into env yet
	--- mb [lookup-main]: rule
		--- < k > [main => Loc:Nat] ...</ k >
		--- < genv >... main |-> Loc:Nat ...</ genv >
		--- : KSentence .
		
	--- generic lookup
	--- mb [lookup]: rule
		--- < k > [I:Identifier => V:Value] ...</ k >
		--- < env >... I:Identifier |-> Loc:Nat ...</ env >
		--- < mem >... Loc:Nat |-> V:Value ...</ env >
		--- : KSentence .
	
	mb [variable-declaration]: rule
		< k > [Declaration(int, I:Identifier) => skipval] ...</ k >
		< env >... [.Map => I:Identifier |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Identifier))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	
	
	
	***(
	Declaration-Specifiers Identifier(Parameter-Type-List){
		Block-Item-List
	}
	***)
	mb [function-definition]: rule 
		< k > [
			Declaration(DS:Declaration-Specifiers, Direct-Function-Declarator(I:Identifier, PTL:Parameter-Type-List)){
				B:Block-Item-List
			}
			=> .K]
		...</ k >
		< genv > [E:Map => E:Map[Loc:Nat / I:Identifier]]  </ genv >
		< mem > [M:Map => M:Map[Declaration(DS:Declaration-Specifiers, Direct-Function-Declarator(I:Identifier, PTL:Parameter-Type-List)){ B:Block-Item-List } / Loc:Nat]] </ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	
	***(
	mb [function-application]: rule
		< k > [Apply(Loc:Nat, .List{Expression}) ~> K:K => B:Block-Item-List] </ k >
		< mem >... Loc:Nat |-> (D:Declaration{ B:Block-Item-List }) ...</ mem >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< locals > [P:Bag => .Bag] </ locals >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< parameters > P:Bag </ parameters >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	***)
	op bind : -> KLabel .
	mb [function-application]: rule
		< k > [Apply(Loc:Nat, L:List{Expression}) ~> K:K => bind(L:List{Expression},, PTL:Parameter-Type-List) ~> B:Block-Item-List] </ k >
		< mem >... Loc:Nat |-> (Declaration(DS:Declaration-Specifiers, Direct-Function-Declarator(I:Identifier, PTL:Parameter-Type-List)){ B:Block-Item-List }) ...</ mem >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< parameters > [P:Bag => .Bag] </ parameters >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< parameters > P:Bag </ parameters >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	--- empty binding
	mb [function-application]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(Parameter-Declaration(void))) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- mb [function-application]: rule 
		--- < k > [bind((V:Value ,List{Expression} L:List{Expression}),, 
				--- Parameter-Type-List(Parameter-Declaration(int, I:Identifier))) => .K] ...</ k > 
		--- < env >... [.Map => I:Identifier |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- : KSentence .

--- bind(("_`,List`{Expression`}_").KHybridLabel("Int" 2(.List{K})),, ("Parameter-Type-List").KProperLabel(("Parameter-Declaration").KProperLabel(("int").KProperLabel(.List{K}),,("n").KProperLabel(.List{
		
	mb [assign]: rule
		< k > [P:Int := V:Int => V:Int] ...</ k >
		< mem >... P:Int |-> [? => V:Int] ...</ mem >
		: KSentence .
		
	mb [equality]: rule
		< k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (I:Int) S:Statement else S':Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (0) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	--- mb [if-then-true]: rule
		--- < k > [if (I:Int) S:Statement => S:Statement] ...</ k >
		--- if notBool(I:Int ==Bool 0)
		--- : KSentence .
	--- mb [if-then-false]: rule
		--- < k > [if (0) S:Statement => .K] ...</ k >
		--- : KSentence .
		
		
		
	--------------- Start Expressions ---------------
	--- mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	--- mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	--- mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	--- mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [- I => -Int I] : KSentence .
	--- mb rule [I1:Int < I2:Int => I1:Int <Int I2:Int] : KSentence .
	--- mb rule [I1:Int <= I2:Int => I1:Int <=Int I2:Int] : KSentence .
	--- mb rule [I1:Int > I2:Int => I1:Int >Int I2:Int] : KSentence .
	--- mb rule [I1:Int >= I2:Int => I1:Int >=Int I2:Int] : KSentence .
	--- mb rule [V1 == V2 => V1 ==Bool V2] : KSentence .
	--- mb rule [V1 != V2 => V1 =/=Bool V2] : KSentence .
	--- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	--- mb rule [not(T) => notBool(T)] : KSentence .
	--------------- End Expressions ---------------
	
	--- mb [assign]: rule
		--- < k > [while (B:Expression) S:Statement 
		--- => 
		--- ---if (B:Expression) (S:Statement (while (B:Expression) S:Statement)) --- doesn't work
		--- ---if`(_`)_(B:Expression, (S:Statement)) --- works
		--- ---if`(_`)_(B:Expression, (while (B:Expression) S:Statement)) --- works
		--- ---if`(_`)_(B:Expression, (S:Statement (while (B:Expression) S:Statement))) --- doesn't work
		--- ] ...</ k >
		--- : KSentence .	
	---mb rule < k > [while B do S  => if B then {S while B do S} else {}] ...</ k > : KSentence .
		
	--- mb [return-value]: rule 
		--- < k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		--- < env > E:Map </ env >
		--- < callStack >
			--- [List(
				--- < stackFrame >...
					--- < continuation > K:K </ continuation >
					--- < parameters > .List </ parameters >
				--- </ stackFrame >
			--- ) => .List]
		--- ...</ callStack >
		--- : KSentence .
		
	--- keq <k> [[return V ; -> K ==> K'' -> V -> K']] </k>
		--- <env> [[E ==> E']] </env>
		--- <envStack> [[env(E') ==> .nil]] ...</envStack>
		--- <callStack> [[funk(K') ==> .nil]] ...</callStack>
		--- <onReturn> [[K'' ==> .K]] </onReturn>
endm
