--- not evaluating inside initializers
--- $(value $var) gives what we want for pipestatus
set print attribute on .
mod INCOMING-MODULES is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
endm

mod COMMON-SEMANTIC-SYNTAX is
	including INCOMING-MODULES .
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult .
	op debugK : -> K .
	sort State .
	subsort String < State .
	
	sort Value .
	sort Type .
	---subsort Struct-Or-Union-Specifier < Value .
	sort BaseValue .
	subsort Int Rat < BaseValue .
	subsort BaseValue < Expression .
	subsort Value < Expression .
	subsort Value < KResult .
	---subsort Type < TogetherList .
	subsort Type < KResult .
	subsort Base-Type < Type .
	subsort TogetherList < Expression .
	op sizeof : Type -> Expression .
	---subsort Typedef-Name < Type .
	---subsort Type-Specifier < Type .
	
	op arrayType : K Nat -> Type .
	op functionType : K List{K} -> Type .
	op pointerType : K -> Type .
	op structType : K K -> Type .
	op qualifiedType : Type K -> Type .
	op declare : K K -> K [metadata "strict(1)"] .
	op declare-aux : K K List{K} -> K .
	op converted : K K -> K .
	op evalToType : -> K .
	--- op tid : Id K -> K .
	op tv : BaseValue Type -> Value .
	op addTypes : K K -> K .
	op addGlobalTypes : K K -> K .
	op Closure : K K K -> Value .
	
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	op _to_ : Nat Nat -> List{K} . 
	op calcStructSize : SeqList -> K .

endm

mod C-SETTINGS is
	including INCOMING-MODULES .
	including COMMON-SEMANTIC-SYNTAX .

	--- S 6.2.5 p.35 i.15.  "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.  37)... Irrespective of the choice made, char is a separate type from the other two and is not compatible with either
	--- cme: I'm not sure what consequence being a separate type entails, so for now it will just be rewritten to the chosen type
	mb rule [char => unsigned-char] : KSentence .
	
	---C99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented
	
	op cfg:sizeut : -> Type .
	eq cfg:sizeut = unsigned-long .
	
	op cfg:sizeofInt : -> Nat .
	eq cfg:sizeofInt = 4 .
	op cfg:sizeofUL : -> Nat .
	eq cfg:sizeofUL = 4 .
	
	op cfg:sizeofPtr : -> Nat .
	eq cfg:sizeofPtr = cfg:sizeofUL .
	
	--- op drv:bitsPerInt : -> Nat .
	--- eq drv:bitsPerInt = 8 *Nat cfg:sizeofInt .
	op drv:maxInt : -> Nat .
	op drv:minInt : -> Int .
	--- fixme (should actually be derived
	eq drv:maxInt = 2147483647 .
	eq drv:minInt = -2147483647 .
	
	
	mb rule < k > [I:Int => tv(I:Int, int)] ...</ k > 
		if (I:Int <=Int drv:maxInt)
		andBool (I:Int >=Int drv:minInt)
		: KSentence .
	
	mb rule < k > [sizeof(int) => tv(cfg:sizeofInt, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(unsigned-int) => tv(cfg:sizeofInt, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(unsigned-long) => tv(cfg:sizeofUL, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(signed-int) => tv(cfg:sizeofInt, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(pointerType(?)) => tv(cfg:sizeofPtr, cfg:sizeut)] ...</ k > : KSentence .

	mb rule 
		< k > [T:Typedef-Name => T:Type] ...</ k > 
		< types >... T:Typedef-Name |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct(X:Id) => T:Type] ...</ k > 
		< types >... struct(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	
	--- — number of bits for smallest object that is not a bit-field (byte)
	--- CHAR_BIT 8
	--- — minimum value for an object of type signed char
	--- SCHAR_MIN -127 // -(27 - 1)
	--- — maximum value for an object of type signed char
	--- SCHAR_MAX +127 // 27 - 1
	--- — maximum value for an object of type unsigned char
	--- UCHAR_MAX 255 // 28 - 1
	--- — minimum value for an object of type char
	--- CHAR_MIN see below
	--- — maximum value for an object of type char
	--- CHAR_MAX see below
	--- — maximum number of bytes in a multibyte character, for any supported locale
	--- MB_LEN_MAX 1
	--- — minimum value for an object of type short int
	--- SHRT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type short int
	--- SHRT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned short int
	--- USHRT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type int
	--- INT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type int
	--- INT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned int
	--- UINT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type long int
	--- LONG_MIN -2147483647 // -(231 - 1)
	--- — maximum value for an object of type long int
	--- LONG_MAX +2147483647 // 231 - 1
	--- — maximum value for an object of type unsigned long int
	--- ULONG_MAX 4294967295 // 232 - 1
	--- — minimum value for an object of type long long int
	--- LLONG_MIN -9223372036854775807 // -(263 - 1)
	--- — maximum value for an object of type long long int
	--- LLONG_MAX +9223372036854775807 // 263 - 1
	--- — maximum value for an object of type unsigned long long int
	--- ULLONG_MAX 18446744073709551615 // 264 - 1
	
	
endm

mod COMMON-INCLUDE is
	including INCOMING-MODULES .
	including C-SETTINGS .
	including COMMON-SEMANTIC-SYNTAX .
	
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence .
		

	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .

endm

mod SIZEOF is
	including COMMON-INCLUDE .
	
	mb rule < k > [sizeof(char) => tv(1, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(unsigned-char) => tv(1, cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeof(signed-char) => tv(1, cfg:sizeut)] ...</ k > : KSentence .
	
	mb rule
		< k > [sizeof(arrayType(T:Type, N:Nat)) => sizeof(T:Type) * N:Nat] ...</ k >
		: KSentence .
	mb [sizeof-typedef]: rule
		< k > [sizeof(T:Type) => sizeof(T':Type)] ...</ k >
		< typedefs >... T:Type |-> T':Type ...</ typedefs >
	: KSentence .
	mb rule
		< k > [sizeof(E:Expression) => sizeof(T:Type)] ...</ k >
		< types >... E:Expression |-> T:Type ...</ types >
	: KSentence .
	mb rule
		< k > [sizeof(E:Expression[I:Int]) => sizeof(E:Expression[0])] ...</ k >
		if I:Int =/=Bool 0
	: KSentence .
	mb [sizeof-struct]: rule
		< k > [sizeof(structType(X:Id, Fields:SeqList)) => calcStructSize(Fields:SeqList)] ...</ k >
	: KSentence .
	
	
	mb [calcStructSize-int]: rule
		< k > ['calcStructSize(Field(TD:Type-Specifier, X:Id) ~> DS:SeqList) 
			=> '_+_(sizeof(TD:Type-Specifier),, calcStructSize(DS:SeqList))] ...</ k >
		: KSentence .
	mb [calcStructSize-done]: rule
		['calcStructSize(.K) => 0]
		: KSentence .	
	
	--- mb [sizeof-id]: rule
		--- < k > [sizeof(X:Id) => sizeof(T:Type)] ...</ k >
		--- < types >... X:Id |-> T:Type ...</ types >
	--- : KSentence .
	---- FIXME 
	--- mb [sizeof-array-lookup]: rule
		--- < k > [sizeof(X:Id[?]) => 1] ...</ k >
		--- < types >... X:Id |-> int[N:Nat] ...</ types >
	--- : KSentence .
	--- mb [sizeof-array]: rule
		--- < k > [sizeof(X:Id) => N:Nat] ...</ k >
		--- < types >... X:Id |-> int[N:Nat] ...</ types >
	--- : KSentence .

	--- mb [sizeof-pointer]: rule
		--- < k > [sizeof(Pointer(TD:Type-Specifier)) => 1] ...</ k >
	--- : KSentence .
	--- mb [sizeof-int]: rule
		--- < k > [sizeof(int) => 1] ...</ k >
	--- : KSentence .
	--- mb [sizeof-struct]: rule
		--- < k > [sizeof(struct(X:Id)) => calcStructSize(Fields:SeqList)] ...</ k >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, Fields:SeqList) ...</ typedefs >
	--- : KSentence .
endm

mod TYPES is
	including COMMON-INCLUDE .
	op normalizeType : K K -> K .
	op typedef : K K -> K .

	mb rule 
		< k > ['Pointer(T:Type) => pointerType(T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	--- move "Pointer" to where it belongs
	mb rule 
		[L:KLabel(T:Type,, 'Pointer(D:K)) => L:KLabel(pointerType(T:Type),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'Direct-Function-Declarator(X:Id,, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(functionType(T:Type, getList{K}(LL:List{Parameter})),, X:Id)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, D:Declarator[N:Nat]) 
		=> L:KLabel(arrayType(T:Type, N:Nat),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	
	mb rule
		[extern ~> T:Type => qualifiedType(T:Type, extern)]
		: KSentence [metadata "structural"] .
	--- for casts, at least
	--- mb rule
		--- [Pointer(T:Type) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .

	
	op arithConversion : K K -> K [metadata "strict"] .
	op arithConversion-int : K K -> K [metadata "strict"] .
	op integerPromotion : K -> K .

	--- fixme should only happen if arguments are arithmetic
	mb rule
		< k > [.K => arithConversion(V:Value, V':Value)] ~> L:KLabel(V:Value,, V':Value) ...</ k > 
		if false
		orBool L:KLabel ==Bool '_*_
		orBool L:KLabel ==Bool '_+_
		orBool L:KLabel ==Bool '_-_
		orBool L:KLabel ==Bool '_%_
		orBool L:KLabel ==Bool '_<_
		orBool L:KLabel ==Bool '_>_
		orBool L:KLabel ==Bool '_<=_
		orBool L:KLabel ==Bool '_>=_
		orBool L:KLabel ==Bool '_==_
		orBool L:KLabel ==Bool '_!=_
		: KSentence .
		
	---C99 6.3.1.8
	--- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	mb rule
		< k > [arithConversion(tv(V1:BaseValue, long-double), tv(V2:BaseValue, T2:Type)) => 
		converted(tv(V1:BaseValue, long-double), tv(V2:BaseValue, long-double))] ...</ k >
		: KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	mb rule
		< k > [arithConversion(tv(V1:BaseValue, double), tv(V2:BaseValue, T2:Type)) => 
		converted(tv(V1:BaseValue, double), tv(V2:BaseValue, double))] ...</ k >
		if T2:Type =/=Bool long-double
		: KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float. 53) For example, addition of a double _Complex and a float entails just the conversion of the float operand to double (and yields a double _Complex result).
	mb rule
		< k > [arithConversion(tv(V1:BaseValue, float), tv(V2:BaseValue, T2:Type)) => 
		converted(tv(V1:BaseValue, float), tv(V2:BaseValue, float))] ...</ k >
		if T2:Type =/=Bool long-double
		andBool T2:Type =/=Bool double
		: KSentence .
		
	--- Otherwise, the integer promotions are performed on both operands ...
	mb rule
		< k > [
			arithConversion(tv(V1:BaseValue, T1:Type), tv(V2:BaseValue, T2:Type)) 
			=> 
			arithConversion-int(integerPromotion(tv(V1:BaseValue, T1:Type)), integerPromotion(tv(V2:BaseValue, T2:Type)))
		] ...</ k >
		if T1:Type =/=Bool long-double andBool T2:Type =/=Bool long-double
		andBool T1:Type =/=Bool double andBool T2:Type =/=Bool double
		andBool T1:Type =/=Bool float andBool T2:Type =/=Bool float
		: KSentence .
	
	---C99 6.3.1.4:2 For objects or expressions with an integer type  whose integer conversion rank is less than or equal to the rank of int and unsigned int, and a bit field of type _Bool, int, signed int, or unsigned int, If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int.  These are called the integer promotions.  All other types are unchanged by the integer promotions.
	mb rule
		< k > [integerPromotion(tv(V:BaseValue, int)) => tv(V:BaseValue, int)] ...</ k >
		: KSentence .
	mb rule
		< k > [integerPromotion(tv(V:BaseValue, unsigned-int)) => tv(V:BaseValue, unsigned-int)] ...</ k >
		: KSentence .
	mb rule
		< k > [integerPromotion(tv(V:BaseValue, unsigned-long)) => tv(V:BaseValue, unsigned-long)] ...</ k >
		: KSentence .
	mb rule
		< k > [integerPromotion(tv(V:BaseValue, pointerType(T:Type))) => tv(V:BaseValue, pointerType(T:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [integerPromotion(tv(V:BaseValue, arrayType(T:Type, N:Nat))) => tv(V:BaseValue, arrayType(T:Type, N:Nat))] ...</ k >
		: KSentence .
	
	--- Then the following rules are applied to the promoted operands:
	
	--- If both operands have the same type, then no further conversion is needed.
	mb rule
		< k > [
			arithConversion-int(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type)) 
			=> 
			converted(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type))
		] ...</ k >
		: KSentence .	
	
	--- fixme not sure about this
	mb rule
		< k > [
			arithConversion-int(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type)) 
			=> 
			converted(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type))
		] ...</ k >
		: KSentence .	
	
	--- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
	
	--- fixme, hardcoded
	mb rule
		< k > [
			arithConversion-int(tv(V1:BaseValue, unsigned-int), tv(V2:BaseValue, int)) 
			=> 
			converted(tv(V1:BaseValue, unsigned-int), tv(V2:BaseValue, unsigned-int))
		] ...</ k >
		: KSentence .
	mb rule
		< k > [
			arithConversion-int(tv(V1:BaseValue, unsigned-long), tv(V2:BaseValue, int)) 
			=> 
			converted(tv(V1:BaseValue, unsigned-long), tv(V2:BaseValue, unsigned-long))
		] ...</ k >
		: KSentence .
	mb rule
		< k > [
			arithConversion-int(tv(V1:BaseValue, int), tv(V2:BaseValue, unsigned-long)) 
			=> 
			converted(tv(V1:BaseValue, unsigned-long), tv(V2:BaseValue, unsigned-long))
		] ...</ k >
		: KSentence .
	
	--- Otherwise...
	--- fixme left out cases
	
	
	----------------------------------------------------------------------
	--- mb rule 
		--- [Field(T:TogetherList, Pointer(D:Direct-Declarator)) => Field(Pointer(T:TogetherList), D:Direct-Declarator)]  
		--- : KSentence [metadata "structural"] .
	
	--- mb rule [Typedef(T:TogetherList, X:Typedef-Name) => typedef(normalizeType(T:TogetherList), X:Typedef-Name)] : KSentence .
	--- mb [function-prototype]: rule 
		--- < k > [Global(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List))) => .K] ...</ k >
		--- : KSentence .

	op HOLE : -> K .
	op locs : List{K} -> KResult .
	---Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)
	mb [start-declare]: rule
		< k > ['Declaration(T:Type,, X:Id) => declare(T:Type, X:Id)] ...</ k >
		: KSentence .
	
endm	

------------------------------------------------
---- C standard library
mod COMMON-C-STANDARD-LIBRARY is
	including COMMON-INCLUDE .
	
	op builtin : Id -> Value .
	
	--------------------------------------------
	mb [sqrt-is-value]: rule
		< k > [sqrt => builtin(sqrt)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(sqrt), I:Int) => truncRat(float2ratConversion(sqrtFloat(rat2floatConversion(I:Int))))] ...</ k >
	: KSentence .
	
	--------------------------------------------
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), N:Nat) => Loc:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [rand-is-value]: rule
		< k > [rand => builtin(rand)] ...</ k >
	: KSentence .
	mb [rand]: rule
		< k > [Apply(builtin(rand), .List{Expression}) => randomRandom(Loc:Nat)] ...</ k >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [free-is-value]: rule
		< k > [free => builtin(free)] ...</ k >
	: KSentence .
	
	mb [free]: rule
		< k > [Apply(builtin(free), Loc:Nat) => Apply(builtin(free), sNat(Loc:Nat))] ...</ k >
		< mem >...  [Loc:Nat |-> ? => .Map] ...</ mem >
		< malloced >... [Loc:Nat |-> sNat(N:Nat) => sNat(Loc:Nat) |-> N:Nat] ...</ malloced >
	: KSentence .
	mb [free-done]: rule
		< k > [Apply(builtin(free), Loc:Nat) => skipval] ...</ k >
		< malloced >... [Loc:Nat |-> 0 => .Map] ...</ malloced >
	: KSentence .
	--------------------------------------------
	mb [calloc-is-value]: rule
		< k > [calloc => builtin(calloc)] ...</ k >
	: KSentence .
	
	--- ignoring size for now
	--- fixme
	mb [calloc]: rule
		< k > [Apply(builtin(calloc), (N:Nat .,. Size:Nat)) => Loc:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> 0] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [memset-is-value]: rule
		< k > [memset => builtin(memset)] ...</ k >
	: KSentence .
	
	mb [memset]: rule
		< k > [Apply(builtin(memset), (Loc:Nat .,. N:Nat .,. Len:Nat)) => Loc:Nat] ...</ k >
		< mem > [M:Map => M:Map[N:Nat / Loc:Nat to (Loc:Nat +Nat Len:Nat)]] </ mem >
	: KSentence .
	--------------------------------------------
	mb [strlen-is-value]: rule
		< k > [strlen => builtin(strlen)] ...</ k >
	: KSentence .
	
	op strlen-aux : Nat Nat -> K .
	mb [strlen-start]: rule
		< k > [Apply(builtin(strlen), Loc:Nat) => strlen-aux(0, Loc:Nat)] ...</ k >
	: KSentence .
	
	mb [strlen-nz]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => strlen-aux(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strlen-z]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcpy-is-value]: rule
		< k > [strcpy => builtin(strcpy)] ...</ k >
	: KSentence .
	
	op strcpy-aux : Nat Nat Nat -> K .
	mb [strcpy-start]: rule
		< k > [Apply(builtin(strcpy), (Dest:Nat .,. Src:Nat)) => strcpy-aux(Src:Nat, Dest:Nat, Dest:Nat)] ...</ k >
	: KSentence .
	
	mb [strcpy-nz]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => strcpy-aux(sNat(Src:Nat), sNat(Dest:Nat), Orig:Nat)] ...</ k >
		< mem >... Src:Nat |-> N:Nat Dest:Nat |-> [? => N:Nat] ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strcpy-z]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => Orig:Nat] ...</ k >
		< mem >... Src:Nat |-> 0 Dest:Nat |-> [? => 0] ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcmp-is-value]: rule
		< k > [strcmp => builtin(strcmp)] ...</ k >
	: KSentence .
	
	op strcmp-aux : Nat Nat -> K .
	mb [strcmp-start]: rule
		< k > [Apply(builtin(strcmp), (Loc1:Nat .,. Loc2:Nat)) => strcmp-aux(Loc1:Nat, Loc2:Nat)] ...</ k >
	: KSentence .
	
	mb [strcmp-same-addy]: rule
		< k > [strcmp-aux(Loc:Nat, Loc:Nat) => 0] ...</ k >
		: KSentence .
	mb [strcmp-same]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => strcmp-aux(sNat(Loc1:Nat), sNat(Loc2:Nat))] ...</ k >
		< mem >... Loc1:Nat |-> N:Nat Loc2:Nat |-> N:Nat ...</ mem >
		if N:Nat =/=Bool 0
		: KSentence .
	mb [strcmp-done]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => 0] ...</ k >
		< mem >... Loc1:Nat |-> 0 Loc2:Nat |-> 0 ...</ mem >
		: KSentence .
	mb [strcmp-different]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => if N1:Nat >Nat N2:Nat then 1 else -1 fi] ...</ k >
		< mem >... Loc1:Nat |-> N1:Nat Loc2:Nat |-> N2:Nat ...</ mem >
		if N1:Nat =/=Bool N2:Nat
		: KSentence .
	--------------------------------------------
	mb [putchar-is-value]: rule
		< k > [putchar => builtin(putchar)] ...</ k >
	: KSentence .
	mb [putchar]: rule
		< k > [Apply(builtin(putchar), (N:Nat)) => N:Nat] ...</ k >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
	: KSentence .
	--------------------------------------------
	mb [printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [printf-start]: rule
		< k > [Apply(builtin(printf), (tv(Loc:Nat, ?) .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
		if notBool(N:Nat ==Bool asciiString("%")) 
		andBool notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	mb [printf-null]: rule
		< k > [printf-aux(0, 0, .List{Expression}) => 6] ...</ k >
		< output > [S:String => S:String +String "(null)"] </ output >
	: KSentence .
	
	mb [printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	mb [printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Int, 10)] </ output >
		if N:Nat ==Bool asciiString("d") 
	: KSentence .
	mb [printf-%s]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(S:Nat, ?) .,. L:List{Expression})) => 
			printf-aux(0, S:Nat, .List{Expression})
			~> printf-aux(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat ==Bool asciiString("s") 
	: KSentence .

	mb [printf-%s-done]: rule
		< k > [Len':Nat ~> printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => 
			printf-aux(Len:Nat +Nat Len':Nat, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .
	op bind : List{K} List{K} -> K .

	mb [void-to-id]: rule
		[Parameter-Type-List(Parameter-Declaration(void)) 
		=> Parameter-Type-List(.List{Parameter})] : KSentence [metadata "structural"] .
	
	--- empty binding
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, .List{K}) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	--- mb [bind-one]: rule 
		--- < k > [bind((V:Value .,. L:List{Expression}),, 
				--- Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, I:Id) ,., P:List{Parameter})) =>
			--- bind((.List{Expression} .,. L:List{Expression}),, 
				--- Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				--- ...</ k > 
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat)] ...</ locals >
		--- < types >... [.Map => I:Id |-> T:Type-Specifier] ...</ types >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < typedefs > TypeDefs:Map </ typedefs >
		--- if notBool($hasMapping(TypeDefs:Map, T:Type-Specifier))
		--- : KSentence .
	--- mb [bind-one-func-pointer]: rule 
		--- < k > [bind((V:Value .,. L:List{Expression}),, 
				--- Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter}))) ,., P:List{Parameter})) =>
			--- bind((.List{Expression} .,. L:List{Expression}),, 
				--- Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				--- ...</ k > 
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- : KSentence .
		
	--- mb [bind-one-typedef]: rule 
		--- < k > [bind(L:List{Expression},, 
				--- Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter})) =>
			--- bind(L:List{Expression},, 
				--- Parameter-Type-List(Parameter-Declaration(T':Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter}))]
				--- ...</ k > 
		--- < typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
		
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .
	--- mb [global-variable-declaration]: rule
		--- < k > [Global(Declaration(int, I:Id)) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> int] ...</ types >
		--- : KSentence .
	--- mb [global-pointer-declaration]: rule
		--- < k > [Global(Declaration(Pointer(T:Type-Specifier), I:Id)) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		--- : KSentence .
	--- mb [global-func-pointer-declaration]: rule
		--- < k > [Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)] ...</ types >
		--- : KSentence .	
		
	--- mb [global-variable-declaration-init]: rule
		--- < k > [Declaration(int, I:Id) = E:Expression => Global(Declaration(int, I:Id)) ~> Deref(&(I:Id)) := E:Expression ;] ...</ k >
		--- : KSentence .
	--- mb [global-pointer-declaration-init]: rule
		--- < k > [Declaration(Pointer(T:Type-Specifier), I:Id) = E:Expression => Global(Declaration(Pointer(T:Type-Specifier), I:Id)) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		--- : KSentence .
		
	--- mb [global-func-pointer-declaration-init]: rule
		--- < k > [Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)) = E:Expression => Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		--- : KSentence .
		
	mb [function-definition]: rule 
		< k > ['_`{_`}('Declaration(T:Type,, X:Id),, B:TogetherList)=> .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> Closure(X:Id, T:Type, B:TogetherList)] </ mem >
		< types >... [.Map => X:Id |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Type] ...</ typedefs >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
		
	mb [function-prototype]: rule 
		< k > ['Global('Declaration(functionType(K:K, L:List{K}),, I:Id)) => .K] ...</ k >
		: KSentence .
	mb [typedef-declaration]: rule
		< k > ['Global('Typedef(T:Type,, X:Typedef-Name)) => .K] ...</ k >
		< types >... [.Map => X:Typedef-Name |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		: KSentence .
		
	--- op initArray : List{K} List{K} -> K .
	--- mb [global-array-declaration-init]: rule
		--- < k > [Declaration(T:Type-Specifier, X:Id[N:Nat]) = { L:List{Expression} } => initArray(getList{K}(L:List{Expression}), sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat N:Nat))] ...</ k >
		--- < env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat N:Nat) |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat) +Nat N:Nat] </ nextLoc >
		--- < types >... [.Map => X:Id |-> T:Type-Specifier[N:Nat]] ...</ types >
		--- : KSentence .
		
	--- op initItem : K K -> K [metadata "strict(1)"] .
	--- mb [initArray-empty]: rule
		--- < k > [initArray((Item:K,, Items:List{K}), (Loc:K,, Locs:List{K})) => initItem(Item:K, Loc:K) ~> initArray(Items:List{K}, Locs:List{K})] ...</ k >
		--- : KSentence .
	--- mb [initArray-empty]: rule
		--- < k > [initArray(.List{K}, .List{K}) => .K] ...</ k >
		--- : KSentence .
		
	--- mb rule
		--- < k > [initItem(V:Value, Loc:K) => .K] ...</ k >
		--- < mem >... Loc:K |-> [? => V:Value] ...</ mem >
		--- : KSentence .
		
	--- mb [struct-declaration]: rule 
		--- < k > [Global(struct(X:Id, DS:TogetherList) ;) => addGlobalTypes(X:Id, structType(X:Id, DS:TogetherList))] ...</ k >
		--- ---< typedefs >... [.Map => struct(X:Id) |-> structstruct(X:Id, DS:TogetherList)] ...</ typedefs >
		--- : KSentence .
		mb [struct-declaration]: rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => .K] ...</ k >
		< typedefs >... [.Map => struct(X:Id) |-> structType(X:Id, DS:TogetherList)] ...</ typedefs >
		: KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, structType(X:Id, F:K)) => .K] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> structType(X:Id, F:K)] ...</ typedefs >
		--- : KSentence .
		
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, arrayType(T:Type, N:Nat)) => addGlobalTypes(E:Expression[0], T:Type)] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, pointerType(T:Type)) => addGlobalTypes(Deref(E:Expression), T:Type)] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, T:Typedef-Name) => addGlobalTypes(E:Expression, T':Type)] ...</ k >
		--- < typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> T:Base-Type] ...</ typedefs >
		--- : KSentence .
endm

mod COMMON-LOCAL-DECLARATION is
	including COMMON-INCLUDE .
	
	--- mb [declaration-using-typedef]: rule
		--- < k > ['Declaration(Kp:KProper,, I:Id) => Declaration(T':Type-Specifier, I:Id)] ...</ k >
		--- < typedefs >... Kp:KProper |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
				


	mb rule
		< k > [addTypes(E:Expression, arrayType(T:Type, N:Nat)) => addTypes(E:Expression[0], T:Type)] ...</ k >
		< types >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ types >
		: KSentence .
	mb rule
		< k > [addTypes(E:Expression, pointerType(T:Type)) => addTypes(Deref(E:Expression), T:Type)] ...</ k >
		< types >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ types >
		: KSentence .
	mb rule
		< k > [addTypes(E:Expression, structType(X:Id, F:K)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> structType(X:Id, F:K)] ...</ types >
		: KSentence .
	--- mb rule
		--- < k > [addTypes(E:Expression, struct(X:Id)) => .K] ...</ k >
		--- < types >... [.Map => E:Expression |-> struct(X:Id)] ...</ types >
		--- : KSentence .
	--- mb rule
		--- < k > [addTypes(E:Expression, T:Typedef-Name) => addTypes(E:Expression, T':Type)] ...</ k >
		--- < types >... T:Typedef-Name |-> T':Type ...</ types >
		--- : KSentence .
	mb rule
		< k > [addTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> T:Base-Type] ...</ types >
		: KSentence .
		
		
		
	--- op struct-aux : Id Id Nat -> K .
	--- --- need to initialize inside struct
	--- --- fixme
	--- mb [local-struct-declaration]: rule
		--- < k > [Len:Nat ~> declare(struct(X:Id), X':Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => X':Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat Len:Nat))] ...</ locals >
		--- < nextLoc > [Loc:Nat => (Loc:Nat +Nat Len:Nat)] </ nextLoc >
		--- < types >... [.Map => X':Id |-> struct(X:Id)] ...</ types >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		--- : KSentence .
		
	op allocate : K -> K [metadata "strict"] .
	mb rule
		< k > [declare(T:Type, X:Id)
			=> addTypes(X:Id, T:Type) ~> allocate(sizeof(T:Type))] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		---< types >... [.Map => X:Id |-> T:Type] ...</ types >
		: KSentence [print "Declaring " X:Id] .
	mb rule
		< k > [allocate(tv(Len:Nat, ?)) => .K] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat Len:Nat] </ nextLoc >
		: KSentence .
		
	--- mb [declaration-heat-array]: rule
		--- < k > [declare(T:Type-Specifier, '_`[_`](Kp:KProper,, N:Nat)) => declare(T:Type-Specifier[N:Nat], Kp:KProper) ~> declare(T:Type-Specifier, '_`[_`](HOLE,, N:Nat))] ...</ k >
		--- : KSentence .
	--- mb [declaration-cool-array]: rule
		--- < k > [Kr:KResult ~> declare(T:Type-Specifier, '_`[_`](HOLE,, N:Nat)) => declare-aux(T:Type-Specifier, '_`[_`](Kr:KResult,, N:Nat), .List{K})] ...</ k >
		--- : KSentence .
	--- --- pointer type, so "tail recursive" :)
	--- mb [declaration-heat-func-pointer]: rule
		--- < k > [declare(T:Type-Specifier, 'Direct-Function-Declarator('Pointer(Kp:KProper),, PTL:Parameter-Type-List)) => declare(funcptr(T:Type-Specifier, PTL:Parameter-Type-List), Kp:KProper)] ...</ k >
		--- : KSentence .

	--- mb rule
		--- < k > [declare-aux(T:Type-Specifier, '_`[_`](locs((ALoc:Nat,, Locs:List{K})),, N:Nat), Pre:List{K}) => declare-aux(T:Type-Specifier, '_`[_`](locs(Locs:List{K}),, N:Nat), (Loc:Nat to (Loc:Nat +Nat N:Nat),, Pre:List{K}))] ...</ k >
		--- < mem >... ALoc:Nat |-> [? => Loc:Nat] [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat N:Nat))] ...</ locals >
		--- < nextLoc > [Loc:Nat => (Loc:Nat +Nat N:Nat)] </ nextLoc >
		--- : KSentence .
	--- mb [declaration-array-done]: rule
		--- < k > [declare-aux(T:Type-Specifier, '_`[_`](locs(.List{K}),, N:Nat), Pre:List{K}) => locs(Pre:List{K})] ...</ k >
		--- : KSentence .
	

	
	--- --- these should become a single rule once declarations are finished being unified
	--- mb [declaration-id-array]: rule
		--- < k > [declare(T:Type-Specifier[N:Nat], I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> T:Type-Specifier[N:Nat]] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-func-pointer]: rule
		--- < k > [declare(funcptr(K1:K, K2:K), I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> funcptr(K1:K, K2:K)] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-pointer]: rule
		--- < k > [declare(Pointer(T:Type-Specifier), I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-base]: rule
		--- < k > [declare(int, I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> int] ...</ types >
		--- : KSentence .
		
	--- mb [local-struct-declaration-start]: rule
		--- < k > [declare(struct(X:Id), X':Id) => calcStructSize(DS:TogetherList) ~> declare(struct(X:Id), X':Id)] ...</ k >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		--- : KSentence .



endm

mod COMMON-EXPRESSIONS is
	including COMMON-INCLUDE .

	mb [pointerAddition]: rule [tv(V1:BaseValue, pointerType(T:Type)) +o V2:Value => tv(V1:BaseValue, pointerType(T:Type)) + (sizeof(T:Type) * V2:Value)] : KSentence  .
	
	---x ("_+o_").KProperLabel(("_`[_`]").KProperLabel("Id" arr(.List{K}),,"Rat" 0(.List{K})),,("tv").KResultLabel("Rat" 0(.List{K}),,"Base-Type" int(.List{K}))) 
	 
	---- [print E:Expression]

	--- fixme result needs type
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? * ? 
	=> (I1:Int *Int I2:Int) %i (sizeof(T:Type) *i 256) ~> makeType(T:Type)] ...</ k > : KSentence .
	
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? + ? 
	=> (I1:Int +Int I2:Int) %i (sizeof(T:Type) *i 256) ~> makeType(T:Type)] ...</ k > : KSentence .
	
	op makeType : K -> K .
	mb rule < k > [converted(tv(I1:Int, pointerType(T:Type)), tv(I2:Int, T':Type)) ~> ? + ? 
	=> (I1:Int +Int I2:Int) %i (sizeof(pointerType(T:Type)) *i 256) ~> makeType(pointerType(T:Type))] ...</ k > : KSentence .
	
	mb rule < k > [tv(I:Int, ?) ~> makeType(T:Type) => tv(I:Int, T:Type)] ...</ k > : KSentence .
	
	--- mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	--- mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	--- mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	--- mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	mb rule [tv(I1:Int, ?) *i tv(I2:Int, ?) => I1:Int *Int I2:Int] : KSentence .
	mb rule [tv(I1:Int, ?) %i tv(I2:Int, ?) => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- --- mb rule [- I => -Int I] : KSentence .
	
	--- fixme, restricted for pointers
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? < ? => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? <= ? => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? > ? => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? >= ? => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? == ? => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? != ? => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	--- mb rule [I1:Int < I2:Int => if (I1:Int <Int I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [I1:Int <= I2:Int => if (I1:Int <=Int I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [I1:Int > I2:Int => if (I1:Int >Int I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [I1:Int >= I2:Int => if (I1:Int >=Int I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [I1:Int == I2:Int => if (I1:Int ==Bool I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [I1:Int != I2:Int => if (I1:Int =/=Bool I2:Int) then 1 else 0 fi] : KSentence .
	--- --- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- --- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	--- mb rule [!(I:Int) => if (I:Int ==Bool 0) then 1 else 0 fi] : KSentence .
	
	--- mb rule [I:Int >> N:Nat => I:Int >>Int N:Nat] : KSentence .
	--- mb rule [I:Int << N:Nat => I:Int <<Int N:Nat] : KSentence .
	--- mb rule [I1:Int | I2:Int => I1:Int |Int I2:Int] : KSentence .
	--- mb rule [_&_(I1:Int, I2:Int) => I1:Int &Int I2:Int] : KSentence .
	--- mb rule [~ I:Int => ~Int I:Int] : KSentence .

	
endm

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including SIZEOF .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-LOCAL-DECLARATION .
	including COMMON-C-STANDARD-LIBRARY .
	including COMMON-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	including TYPES .
	
	--- mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	op assign : K K -> K .
	mb context assign(Deref([HOLE]), ?) : KSentence .

	op eval : Program -> Bag .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
		
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
	--- we're ignoring types for now
	--- mb rule [U(I:Int) => I:Int] : KSentence [metadata "structural"] .
	mb rule [UL(I:Int) => tv(I:Int, unsigned-long)] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-int => int] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-short => int] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-char => int] : KSentence [metadata "structural"] .
	--- mb rule [char => int] : KSentence [metadata "structural"] .
	--- mb rule [float => int] : KSentence [metadata "structural"] .
	--- mb rule [double => int] : KSentence [metadata "structural"] .
	
	--- skip labels
	mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).
		
	
	---C99 6.5.3.2 (p79) footnote 90) Thus, &*E == E; &(E1[E2]) == (E1 + E2)
	
	---C99 6.5.3.2 90) ... It is always true that if E is a function designator or an lvalue that is a valid operand of the u of the unary & operator, *&E is a function designator or an lvalue equal to E.
	
	--- mb rule [&(Deref(E:Expression)) => E:Expression] : KSentence [metadata "structural"] .
	--- mb rule [&(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression] : KSentence [metadata "structural"] .
	mb [for-assignment]: rule < k > [E1:Expression := E2:Expression => assign(Deref(&(E1:Expression)),  E2:Expression)] ...</ k > : KSentence .
	
	mb rule < k > [&(Deref(E:Expression)) => E:Expression] ...</ k > : KSentence [metadata "structural"] .
	mb rule < k > [&(E1:Expression[E2:Expression]) => E1:Expression +o E2:Expression] ...</ k > : KSentence [metadata "structural"] .
	mb rule < k > [E1:Expression[E2:Expression] => Deref(E1:Expression +o E2:Expression)] ...</ k > : KSentence [metadata "structural"] .
	
	---C99 6.5.3.2:4 The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
	--- also see 6.3.2.1:3 for why i made the result a pointerType
	mb rule < k > [Deref(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) => tv(Loc:Nat, pointerType(T:Type))] ...</ k > : KSentence [metadata "structural"] .
	
	***(
	
	arr[0][0] := 1;
	assign(Deref(&(arr[0][0])), 1)
	&(arr[0][0]) ~> assign(Deref(HOLE), 1)
	arr[0] +o 0 ~> assign(Deref(HOLE), 1)
	arr[0] + (sizeof(arr[0]) * 0) ~> assign(Deref(HOLE), 1)
	arr[0] ~> assign(Deref(HOLE), 1)
	tv(4, pointerType(int, 2))
	***)
	--- mb rule [sizeof(&(E1:Expression[E2:Expression])) => sizeof(E1:Expression +o E2:Expression)] : KSentence [metadata "structural"] .
	
	
	--- turn variables into references when appropriate
	--- mb [make-assign-ref]: rule < k > [I:Id := E:Expression => Deref(&(I:Id)) := E:Expression] ...</ k > : KSentence .
	--- mb [make-assign-arrow-ref]: rule < k > [(E1:Expression -> X:Id) := E2:Expression => Deref(&(E1:Expression -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	--- mb [make-assign-arrow-ref]: rule < k > [(E1:Expression . X:Id) := E2:Expression => Deref(&((& E1:Expression) -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	--- mb [make-call-ref]: rule < k > [Apply(I:Id, L:List{Expression}) => Apply(Deref(&(I:Id)), L:List{Expression})] ...</ k > : KSentence .
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
	--- mb [array-revision]: rule < k > [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] ...</ k > : KSentence .
	--- mb [make-assign-array-ref]: rule < k > [ E1:Expression[E2:Expression] := E:Expression => Deref(E1:Expression + E2:Expression) := E:Expression] ...</ k > : KSentence .
	
	--- remove empty global
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- fixme
	--- 6.5.16
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	mb [assign-mod]: rule [E1:Expression %= E2:Expression => E1:Expression := E1:Expression % E2:Expression] : KSentence .
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-lshift]: rule [E1:Expression <<= E2:Expression => E1:Expression := E1:Expression << E2:Expression] : KSentence .
	mb [assign-rshift]: rule [E1:Expression >>= E2:Expression => E1:Expression := E1:Expression >> E2:Expression] : KSentence .
	mb [assign-bit-and]: rule [E1:Expression &= E2:Expression => E1:Expression := _&_(E1:Expression,  E2:Expression)] : KSentence .
	mb [assign-bit-xor]: rule [E1:Expression ^= E2:Expression => E1:Expression := E1:Expression ^ E2:Expression] : KSentence .
	mb [assign-bit-or]: rule [E1:Expression |= E2:Expression => E1:Expression := E1:Expression | E2:Expression] : KSentence .
	

	----- end simple transformations -----

	op readFromMem : Nat Type K BaseValue -> K [metadata "strict(3)"] .
	--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => readFromMem(Loc:Nat, T:Base-Type, sizeof(T:Base-Type), 0)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> T:Base-Type ...</ types >
		: KSentence .
	mb rule
		< k > [readFromMem(Loc:Nat, T:Base-Type, tv(0, ?), N:Nat) 
		=> tv(N:Nat, T:Base-Type)] ...</ k >
		: KSentence .	
	mb rule
		< k > [readFromMem(Loc:Nat, T:Base-Type, tv(sNat(Len:Nat), T':Type), N:Nat) 
		=> readFromMem(sNat(Loc:Nat), T:Base-Type, tv(Len:Nat, T':Type), (N:Nat <<Nat 8) |Nat N':Nat)] ...</ k >
		< mem >... Loc:Nat |-> N':Nat ...</ mem >
		: KSentence .	
		

		
	---C99 6.3.2.1:3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
	mb rule
		< k > [X:Id => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> arrayType(T:Type, N:Nat) ...</ types >
		: KSentence .
		
	---C99 6.3.2.1:4 A function designator is an expression that has function type.  Except when it is the operand of the sizeof operator or the unary & operator, a function designator with type "function returning T" is converted to an expression that has type "pointer to a function returning T"
	mb [lookup-closure]: rule
		< k > [X:Id => tv(Loc:Nat, pointerType(functionType(K:K, L:List{K})))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> functionType(K:K, L:List{K}) ...</ types >
		: KSentence .

		
	--- mb [lookup]: rule
		--- < k > [I:Id => V:Value] ...</ k >
		--- < env >... I:Id |-> Loc:Nat ...</ env >
		--- < mem >... Loc:Nat |-> V:Value ...</ mem >
		--- : KSentence .
		
	op allocString : String -> K .

	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [.K => allocString(S:String)] ~> S:String ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > M:Map [.Map => S:String |-> tv(Loc:Nat, arrayType(char, lengthString(S:String) +Nat 1))] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => V:Value] ...</ k >
		< statics >... S:String |-> V:Value ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> charToAscii(firstChar(S:String))] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> 0] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
		
	--- mb [assign]: rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type)) => V:BaseValue] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:BaseValue] ...</ mem >
		--- : KSentence .
	mb [assign]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type)) => putInMem(Loc:Nat, V:BaseValue, T:Type, sizeof(T:Type)) ~> tv(V:BaseValue, T:Type)] ...</ k >
		: KSentence .
	op putInMem : Nat BaseValue Type K -> K [metadata "strict(4)"] .
	op putByteInMem : Nat BaseValue -> K .
	mb rule
		< k > [putInMem(Loc:Nat, V:BaseValue, T:Type, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, N:Nat, T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putByteInMem(Loc:Nat, N:Nat %Nat 256) ~> putInMem(sNat(Loc:Nat), N:Nat >>Nat 8, T:Type, tv(Len:Nat, J:Type))] ...</ k >
		: KSentence .
	mb rule
		< k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		< mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		: KSentence .
	
	--- mb rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type)) => V:BaseValue] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:BaseValue] ...</ mem >
		--- : KSentence .
		
	--- mb [assign]: rule
		--- < k > [Deref(Loc:Nat) := V:Value => V:Value] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:Value] ...</ mem >
		--- ---if N:Nat <Int 1000000000
		--- : KSentence .
	--- mb [assign]: rule
		--- < k > [Deref(Loc:Nat) := N:Nat => N:Nat] ...</ k >
		--- < mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		--- ---if N:Nat <Int 1000000000
		--- : KSentence .
		
	--- mb [equality]: rule
		--- < k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		--- : KSentence .
		
		
	---op evalDesignator : Expression -> K .
	
	mb [ref]: rule
		< k > [&(X:Id) => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		: KSentence .
	
	--- mb [ref]: rule
		--- < k > [&(I:Id) => Loc:Nat] ...</ k >
		--- < env >... I:Id |-> Loc:Nat ...</ env >
		--- : KSentence .
	
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(E1:Expression + getOffset(E1:Expression, X:Id))] ...</ k >
		--- : KSentence .
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(& (E1:Expression -> X:Id))] ...</ k >
		--- : KSentence .
	--- mb [dot]: rule
		--- < k > [E1:Expression . X:Id => (& E1:Expression) -> X:Id] ...</ k >
		--- : KSentence .
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(& (E1:Expression -> X:Id))] ...</ k >
		--- : KSentence .
		
	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
		
	op getOffset : K K -> Expression .
	--- mb [ref-arrow]: rule
		--- < k > [&(E1:Expression -> X:Id) => E1:Expression + getOffset(Deref(E1:Expression), X:Id)] ...</ k >
		--- : KSentence .
	--- mb [ref-dot]: rule
		--- < k > [&(E1:Expression . X:Id) => (& (E1:Expression)) + getOffset(E1:Expression, X:Id)] ...</ k >
		--- : KSentence .
	mb rule
		< k > [.K => evalToType] ~> E1:Expression -> X:Id ...</ k >
		[.Bag => < type > E1:Expression </ type >]
		: KSentence .
	mb [arrow-cool]: rule
		< k > [evalToType ~> E1:Expression -> X:Id => Deref(E1:Expression + getOffset(Deref(E1:Expression), X:Id)) ~> makeType(T:Type)] ...</ k >
		[< type > pointerType(structType(X':Id, (Fields1:SeqList ~> 'Field(T:Type,, X:Id) ~>  Fields2:SeqList))) </ type > => .Bag] 
		: KSentence .
	mb rule
		< k > [.K => evalToType] ~> &(E1:Expression . X:Id) ...</ k >
		[.Bag => < type > E1:Expression </ type >]
		: KSentence .
		
	---x ((((((((pointArr))) +o (((3))))) -> x)))
		
	mb [dot-cool]: rule
		< k > [evalToType ~> &(E1:Expression . X:Id) => (& (E1:Expression)) + getOffset(E1:Expression, X:Id) ~> makeType(pointerType(T:Type))] ...</ k >
		[< type > structType(X':Id, (Fields1:SeqList ~> 'Field(T:Type,, X:Id) ~>  Fields2:SeqList)) </ type > => .Bag] 
		: KSentence .
	
	----  ~> makeType(pointerType(T:Type))
	
		

	op HOLE : -> Expression .
	
	mb [getOffset-heat]: rule
		< k > [getOffset(E:Expression, X:Id) => evalToType ~> getOffset(HOLE, X:Id)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .

	--- fixme
	mb [getOffset-cool]: rule
		< k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		[< type > structType(X:Id, (Fields1:SeqList ~> 'Field(T:Type,, X':Id) ~>  Fields2:SeqList)) </ type > => .Bag]
		: KSentence .
	--- mb [getOffset-cool-func-pointer]: rule
		--- < k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- [< type > structType(X:Id, (Fields1:SeqList ~> Field(T:TogetherList, Direct-Function-Declarator(Pointer(X':Id), PTL:Parameter-Type-List)) ~>  Fields2:SeqList)) </ type > => .Bag]
		--- : KSentence .
	--- mb [getOffset-cool-func-pointer-array]: rule
		--- < k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- [< type > structType(X:Id, (Fields1:SeqList ~> Field(T:TogetherList, Direct-Function-Declarator(Pointer(X':Id[N:Nat]), PTL:Parameter-Type-List)) ~>  Fields2:SeqList)) </ type > => .Bag]
		--- : KSentence .

	mb [function-application-pre]: rule
		< k > [Apply(tv(Loc:Nat, pointerType(functionType(?, ?))), L:List{Expression}) 
		=> Apply(V:Value, L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [function-application]: rule
		< k > [
			Apply(Closure(X:Id, functionType(R:K, P:List{K}), B:K), L:List{Expression}) ~> K:K 
			=> 
			bind(getList{K}(L:List{Expression}), P:List{K}) ~> B:K
		] </ k >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< types > [T:Map => GT:Map] </ types >
		< typedefs > GT:Map </ typedefs >
		< loopStack > [LS:List => .List] </ loopStack >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
				< types > T:Map </ types >
				< loopStack > LS:List </ loopStack >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	
	--- mb rule < type > [Deref(& E:Expression) => E:Expression] ...</ type > : KSentence [metadata "structural"] .
	--- mb rule < type > [Deref(Pointer(T:TogetherList)) => T:TogetherList] ...</ type > : KSentence [metadata "structural"] .
	
	mb [evalToType-array-lookup]: rule
		< type > [E:Expression[?] => E:Expression[0]] ...</ type >
		: KSentence .
	mb [evalToType-exp-to-type]: rule
		< type > [E:Expression => T:Type] ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence .
	mb rule
		< type > [arrayType(T:Type, N:Nat) => pointerType(T:Type)] ...</ type >
		: KSentence .
	
	mb rule
		< type > [struct(X:Id, Fields:SeqList) => structType(X:Id, Fields:SeqList)] ...</ type >
		: KSentence .
	
	mb rule
		< type > [E:Expression +o ? => E:Expression] ...</ type >
		: KSentence .
	mb [deref-heat]: rule
		< type > ['Deref(Kp:KProper) => Kp:KProper ~> 'Deref(HOLE)] ...</ type >
		: KSentence .
	mb [deref-cool]: rule
		< type > [pointerType(T:Type) ~> 'Deref(HOLE) => T:Type] ...</ type >
		: KSentence .
	mb [pointer-heat]: rule
		< type > [pointerType(Kp:KProper) => Kp:KProper ~> pointerType(HOLE)] ...</ type >
		: KSentence .
	mb [pointer-cool]: rule
		< type > [Kr:KResult ~> pointerType(HOLE) => pointerType(Kr:KResult)] ...</ type >
		: KSentence .
	mb [dot-heat]: rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence .
	mb [dot-cool]: rule
		< type > [Kr:KResult ~> '_._(HOLE,, X:Id) => '_._(Kr:KResult,, X:Id)] ...</ type >
		: KSentence .
	mb [dot-lookup]: rule
		< type > ['_._(struct(SName:Id),, FName:Id) => T:TogetherList] ...</ type >
		< typedefs >... struct(SName:Id) |-> 'struct(SName:Id,, (Fields1:SeqList ~> Field(T:TogetherList, FName:Id) ~>  Fields2:SeqList)) ...</ typedefs >
		: KSentence .
	mb [typedef-lookup]: rule
		< type > [Kp:KProper => T:Type] ...</ type >
		< typedefs >... Kp:KProper |-> T:Type ...</ typedefs >
		: KSentence .
	
	mb [deref]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) => tv(I:Int, T:Type)] ...</ k >
		< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (tv(I:Int, int)) S:Statement else S':Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (tv(0, int)) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (tv(I:Int, int)) S:Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (tv(0, int)) S:Statement => .K] ...</ k >
		: KSentence .
		
		
	mb [cast-same]: rule
		['Cast(T:Type,, tv(V:BaseValue, T:Type)) => tv(V:BaseValue, T:Type)]
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
		
	--- fixme TOTALLY WRONG
	mb rule
		< k > ['Cast(T':Type,, tv(V:BaseValue, ?)) => tv(V:BaseValue, T':Type)] ...</ k > 
		: KSentence .
		
	--- throwing away casts now
	--- mb [cast-int]: rule
		--- [Cast(int, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-unsigned-long]: rule
		--- [Cast(unsigned-long, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-unsigned-int]: rule
		--- [Cast(unsigned-int, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-pointer-type]: rule
		--- [Cast(Pointer(T:Type-Specifier), I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-func-pointer-type]: rule
		--- [Cast(Pointer(T:Type-Specifier, T':Type-Specifier), I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-typedef]: rule
		--- < k > [Cast(T:Type-Specifier, I:Int) => Cast(T':Type-Specifier, I:Int)] ...</ k >
		--- < typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
		
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K ] </ k >
		< loopStack > [ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K)) => .List] ...</ loopStack >
		: KSentence .

	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	
	mb [post-increment]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) ++ => tv(V:Int, T:Type)] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => V:Int +Int 1] ...</ mem >
		: KSentence .	
	mb [post-decrement]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) -- => tv(V:Int, T:Type)] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => _-Int_(V:Int, 1)] ...</ mem >
		: KSentence .
		
	





	
endm
