--- $(value $var) gives what we want for pipestatus
--- why isn't K ~> K proper?
set print attribute on .
mod INCOMING-MODULES is
	including K .
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	including K-PROPER .
endm

mod COMMON-SEMANTIC-SYNTAX is
	including INCOMING-MODULES .
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult .
	op debugK : -> K .
	op discard : -> K .
	sort State .
	subsort String < State .
	
	sort Value .
	sort Type .
	sort BaseValue .
	sort Field .
	subsort Field < KResult .

	subsort Int Rat Float < BaseValue .
	subsort BaseValue < Expression .
	subsort Value < Expression .
	subsort Value < KResult .
	subsort Type < KResult .
	subsort Base-Type < Type .
	subsort TogetherList < Expression .
	op sizeof : Type -> Expression .
	op HOLE : -> Expression .
	op arrayType : Type Nat -> Type .
	op functionType : Type List{K} -> Type .
	op pointerType : Type -> Type .
	op structType : Id -> Type .
	op qualifiedType : Type K -> Type .
	op typedField : Type Id -> Field .
	op declare : K K -> K [metadata "strict(1)"] .
	op declare-aux : K K List{K} -> K .
	op converted : K K -> K .
	op evalToType : -> K .
	op interpret : K Type -> K .
	op allocate : K -> K [metadata "strict"] .
	op tv : BaseValue Type -> Value .
	op addTypes : K K -> K .
	op addGlobalTypes : K K -> K .
	op addGlobalTypes : K -> K .
	op Closure : K K K -> Value .
	op putInMem : Nat K Type K -> K [metadata "strict(2 4)"] .
	op putBytesInMem : Nat List{K} Type K -> K [metadata "strict(4)"] .
	op sizeofType : Type -> K .
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	op _to_ : Nat Nat -> List{K} . 
	op calcStructSize : List{KResult} -> K .
	op cast : K K -> K [metadata "strict"] .
			
	op integerTypes : -> Set .
	op unsignedIntegerTypes : -> Set .
	op typeof : Expression -> K .
endm

mod C-SETTINGS is
	including INCOMING-MODULES .
	including COMMON-SEMANTIC-SYNTAX .

	--- S 6.2.5 p.35 i.15.  "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.  37)... Irrespective of the choice made, char is a separate type from the other two and is not compatible with either
	--- cme: I'm not sure what consequence being a separate type entails, so for now it will just be rewritten to the chosen type
	mb rule [char => signed-char] : KSentence .
	
	---C99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented

	op numBytes : Type -> Nat .
	eq numBytes(signed-char) = 1 .
	eq numBytes(short-int) = 2 .
	eq numBytes(int) = 4 .
	eq numBytes(long-int) = 4 .
	eq numBytes(long-long-int) = 8 .
	
	eq numBytes(double) = 8 .
	
	
	op cfg:sizeut : -> Type .
	eq cfg:sizeut = unsigned-long-int .

	
	---- derived
	eq numBytes(unsigned-char) = numBytes(signed-char) .
	eq numBytes(unsigned-short-int) = numBytes(short-int) .
	eq numBytes(unsigned-int) = numBytes(int) .
	eq numBytes(unsigned-long-int) = numBytes(long-int) .
	eq numBytes(unsigned-long-long-int) = numBytes(long-long-int) .
	
	op numBits : Type -> Nat .
	eq numBits(T:Type) = numBytes(T:Type) *Nat 8 .
			
	op min : Type -> Int .
	op max : Type -> Int .
	eq min(signed-char) = -Int (2 ^Nat absInt(_-Int_(numBits(signed-char), 1))) .
	eq max(signed-char) = _-Int_(2 ^Nat absInt(_-Int_(numBits(signed-char), 1)), 1) .
	eq min(short-int) = -Int (2 ^Nat absInt(_-Int_(numBits(short-int), 1))) .
	eq max(short-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(short-int), 1)), 1) .
	eq min(int) = -Int (2 ^Nat absInt(_-Int_(numBits(int), 1))) .
	eq max(int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(int), 1)), 1) .
	eq min(long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-int), 1))) .
	eq max(long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-int), 1)), 1) .
	eq min(long-long-int) = -Int (2 ^Nat absInt(_-Int_(numBits(long-long-int), 1))) .
	eq max(long-long-int) = _-Int_(2 ^Nat absInt(_-Int_(numBits(long-long-int), 1)), 1) .
	
	eq min(unsigned-char) = 0 .
	eq max(unsigned-char) = _-Int_(2 ^Nat absInt(numBits(unsigned-char)), 1) .
	eq min(unsigned-short-int) = 0 .
	eq max(unsigned-short-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-short-int)), 1) .
	eq min(unsigned-int) = 0 .
	eq max(unsigned-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-int)), 1) .
	eq min(unsigned-long-int) = 0 .
	eq max(unsigned-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-int)), 1) .
	eq min(unsigned-long-long-int) = 0 .
	eq max(unsigned-long-long-int) = _-Int_(2 ^Nat absInt(numBits(unsigned-long-long-int)), 1) .
		
	mb rule < k > [sizeofType(T:Base-Type) => tv(numBytes(T:Base-Type), cfg:sizeut)] ...</ k > : KSentence .
	mb rule < k > [sizeofType(pointerType(?)) => tv(numBytes(unsigned-long-int), cfg:sizeut)] ...</ k > : KSentence .

	mb rule 
		< k > [T:Typedef-Name => T:Type] ...</ k >
		< types >... T:Typedef-Name |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	mb rule 
		< k > [struct(X:Id) => T:Type] ...</ k > 
		< types >... struct(X:Id) |-> T:Type ...</ types > 
		: KSentence [metadata "structural"] .
	
	--- — number of bits for smallest object that is not a bit-field (byte)
	--- CHAR_BIT 8
	--- — minimum value for an object of type signed char
	--- SCHAR_MIN -127 // -(27 - 1)
	--- — maximum value for an object of type signed char
	--- SCHAR_MAX +127 // 27 - 1
	--- — maximum value for an object of type unsigned char
	--- UCHAR_MAX 255 // 28 - 1
	--- — minimum value for an object of type char
	--- CHAR_MIN see below
	--- — maximum value for an object of type char
	--- CHAR_MAX see below
	--- — maximum number of bytes in a multibyte character, for any supported locale
	--- MB_LEN_MAX 1
	--- — minimum value for an object of type short int
	--- SHRT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type short int
	--- SHRT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned short int
	--- USHRT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type int
	--- INT_MIN -32767 // -(215 - 1)
	--- — maximum value for an object of type int
	--- INT_MAX +32767 // 215 - 1
	--- — maximum value for an object of type unsigned int
	--- UINT_MAX 65535 // 216 - 1
	--- — minimum value for an object of type long int
	--- LONG_MIN -2147483647 // -(231 - 1)
	--- — maximum value for an object of type long int
	--- LONG_MAX +2147483647 // 231 - 1
	--- — maximum value for an object of type unsigned long int
	--- ULONG_MAX 4294967295 // 232 - 1
	--- — minimum value for an object of type long long int
	--- LLONG_MIN -9223372036854775807 // -(263 - 1)
	--- — maximum value for an object of type long long int
	--- LLONG_MAX +9223372036854775807 // 263 - 1
	--- — maximum value for an object of type unsigned long long int
	--- ULLONG_MAX 18446744073709551615 // 264 - 1
	
	
endm

mod COMMON-INCLUDE is
	including INCOMING-MODULES .
	including C-SETTINGS .
	including COMMON-SEMANTIC-SYNTAX .
	
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence .
		

	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
		
		
	op _contains_ : Set K -> Bool .
	eq S:Set SetItem(K:K) contains K:K = true .
	ceq S:Set SetItem(K1:K) contains K2:K = S:Set contains K2:K 
		if K1:K =/=Bool K2:K .
	eq .Set contains K:K = false .

endm

mod SIZEOF is
	including COMMON-INCLUDE .

	mb rule
		< k > [sizeofType(arrayType(T:Type, N:Nat)) => sizeof(T:Type) * tv(N:Nat, cfg:sizeut)] ...</ k >
		: KSentence .
	
	---C99 6.2.6.1:26 ... Each unqualified type has several qualified versions of its type,40) corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers. The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements. ...
	mb rule
		< k > [sizeofType(qualifiedType(T:Type, ?)) => sizeof(T:Type)] ...</ k >
		: KSentence .
	--- mb [sizeof-typedef]: rule
		--- < k > [sizeof(T:Type) => sizeof(T':Type)] ...</ k >
		--- < typedefs >... T:Type |-> T':Type ...</ typedefs >
	--- : KSentence .
	
	mb rule
		< k > [sizeof(E:Expression) => evalToType ~> sizeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .
	mb rule
		< k > [evalToType ~> sizeof(HOLE) => sizeofType(T:Type)] ...</ k >
		[< type > T:Type </ type > => .Bag]
		---< typedefs > TD:Map </ typedefs >
		---if notBool($hasMapping(TD:Map, T:Type))
		: KSentence .
	
	mb rule
		< type > [E:Expression => T:Type] ...</ type >
		< types >... E:Expression |-> T:Type ...</ types >
		: KSentence .
	mb rule
		< type > ['_->_(Kp:KProper,, X:Id) => Kp:KProper ~> '_->_(HOLE,, X:Id)] ...</ type >
		: KSentence .
	mb rule
		< type > [T:Type ~> '_->_(HOLE,, X:Id) => '_->_(T:Type,, X:Id)] ...</ type >
		: KSentence .
	mb rule
		< type > ['_->_(pointerType(structType(S:Id)),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence .
	mb rule
		< type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		: KSentence .
	mb rule
		< type > [T:Type ~> '_._(HOLE,, X:Id) => '_._(T:Type,, X:Id)] ...</ type >
		: KSentence .
	mb rule
		< type > ['_._(structType(S:Id),, X:Id) => T:Type] ...</ type >
		< structs >... struct(S:Id) |-> (?:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
	: KSentence .
	mb rule
		< type > ['Pointer(Kp:KProper) => Kp:KProper ~> 'Pointer(HOLE)] ...</ type >
		: KSentence .
	mb rule
		< type > [T:Type ~> 'Pointer(HOLE) => 'Pointer(T:Type)] ...</ type >
		: KSentence .
	mb rule
		< type > ['_`[_`](Kp:KProper,, E:Expression) => Kp:KProper ~> Deref(HOLE)] ...</ type >
		: KSentence .
	mb rule
		< type > [T:Type ~> Deref(HOLE) => 'Deref(T:Type)] ...</ type >
		: KSentence .
	mb rule
		< type > ['Deref(arrayType(T:Type, ?)) => T:Type] ...</ type >
		: KSentence .
	mb rule
		< type > ['Deref(tv(?, pointerType(T:Type))) => T:Type] ...</ type >
		: KSentence .
	
	--- fixme only if E is not a type
	--- op arrlength : K -> Expression .
	--- mb rule
		--- < k > [sizeof(E:Expression[I:Int]) => sizeof(E:Expression) / arrlength(E:Expression)] ...</ k >
	--- : KSentence .
	--- mb rule
		--- < k > [arrlength(E:Expression) => arrlength(T:Type)] ...</ k >
		--- < types >... E:Expression |-> T:Type ...</ types >
	--- : KSentence .
	--- mb rule
		--- < k > [arrlength(arrayType(T:Type, N:Nat)) => tv(N:Nat, cfg:sizeut)] ...</ k >
	--- : KSentence .
	--- mb rule
		--- < k > [arrlength(E:Expression[I:Int]) => sizeof(E:Expression) / sizeof(E:Expression[I:Int])] ...</ k >
	--- : KSentence .
	--- mb rule
		--- < k > [arrlength(T:Base-Type) => tv(1, cfg:sizeut)] ...</ k >
	--- : KSentence .
	
	--- sizeof(w[0]) / length w
	--- arrLength(w[2])
	--- mb rule
		--- < k > [arrlength(TL:KLabel(?)) => tv(N:Nat, cfg:sizeut)] ...</ k >
		--- if TL:KLabel(?) =/=Bool 'arrayType
	--- : KSentence .
	
	
	--- mb [sizeof-pointer]: rule
		--- < k > [sizeof(Pointer(?)) => tv(numBytes(unsigned-long-int), cfg:sizeut)] ...</ k >
	--- : KSentence .
	mb [sizeof-struct]: rule
		< k > [sizeofType(structType(X:Id)) => calcStructSize(L:List{KResult})] ...</ k >
		< structs >... struct(X:Id) |-> L:List{KResult} ...</ structs >
	: KSentence .
	
	
	mb [calcStructSize]: rule
		< k > [calcStructSize((typedField(T:Type, X:Id),, L:List{KResult})) 
			=> '_+_(sizeof(T:Type),, calcStructSize(L:List{KResult}))] ...</ k >
		: KSentence .
	mb [calcStructSize-done]: rule
		[calcStructSize(.List{K}) => tv(0, cfg:sizeut)]
		: KSentence .	
	
	--- mb [sizeof-id]: rule
		--- < k > [sizeof(X:Id) => sizeof(T:Type)] ...</ k >
		--- < types >... X:Id |-> T:Type ...</ types >
	--- : KSentence .
	---- FIXME 
	--- mb [sizeof-array-lookup]: rule
		--- < k > [sizeof(X:Id[?]) => 1] ...</ k >
		--- < types >... X:Id |-> int[N:Nat] ...</ types >
	--- : KSentence .
	--- mb [sizeof-array]: rule
		--- < k > [sizeof(X:Id) => N:Nat] ...</ k >
		--- < types >... X:Id |-> int[N:Nat] ...</ types >
	--- : KSentence .

	--- mb [sizeof-pointer]: rule
		--- < k > [sizeof(Pointer(TD:Type-Specifier)) => 1] ...</ k >
	--- : KSentence .
	--- mb [sizeof-int]: rule
		--- < k > [sizeof(int) => 1] ...</ k >
	--- : KSentence .
	--- mb [sizeof-struct]: rule
		--- < k > [sizeof(struct(X:Id)) => calcStructSize(Fields:SeqList)] ...</ k >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, Fields:SeqList) ...</ typedefs >
	--- : KSentence .
endm

mod TYPES is
	including COMMON-INCLUDE .
	op normalizeType : K K -> K .
	op typedef : K K -> K .
	
	--- fixme ignoring qualifiers
	mb rule [qualifiedType(T:Type, ?) => T:Type] : KSentence [metadata "structural"] .
	
	mb rule [unsigned-short => unsigned-short-int] : KSentence .
	mb rule [unsigned-long => unsigned-long-int] : KSentence .
	mb rule [unsigned-long-long => unsigned-long-long-int] : KSentence .
	mb rule [short => short-int] : KSentence .
	mb rule [long => long-int] : KSentence .
	mb rule [long-long => long-long-int] : KSentence .
	
	mb rule
		< k > [typeof(E:Expression) => evalToType ~> typeof(HOLE)] ...</ k >
		[.Bag => < type > E:Expression </ type >]
		: KSentence .
	mb rule
		< k > [evalToType ~> typeof(HOLE) => T:Type] ...</ k >
		[< type > T:Type </ type > => .Bag]
		: KSentence .
	
	mb rule 
		['_`[_`](T:Type,, N:Nat) => arrayType(T:Type, N:Nat)]
		: KSentence [metadata "structural"] .
	mb rule 
		['Pointer(T:Type) => pointerType(T:Type)]
		: KSentence [metadata "structural"] .
		
	mb rule 
		< k > ['Pointer(T:Type,, 'Direct-Function-Declarator('Parameter-Type-List(LL:List{Parameter}))) 
		=> pointerType(functionType(T:Type, getList{K}(LL:List{Parameter})))] ...</ k >
		: KSentence [metadata "structural"] .
	
	mb rule 
		< k > ['Pointer(T:Type) => pointerType(T:Type)] ...</ k >
		: KSentence [metadata "structural"] .
	--- move "Pointer" to where it belongs
	mb rule 
		[L:KLabel(T:Type,, 'Pointer(D:K)) => L:KLabel(pointerType(T:Type),, D:K)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, 'Direct-Function-Declarator(X:Id,, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(functionType(T:Type, getList{K}(LL:List{Parameter})),, X:Id)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	mb rule
		[L:KLabel(T:Type,, 'Direct-Function-Declarator('Pointer(D:Declarator),, 'Parameter-Type-List(LL:List{Parameter}))) 
		=> L:KLabel(pointerType(functionType(T:Type, getList{K}(LL:List{Parameter}))),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
		
	--- op makeType : K -> K .	
	--- mb rule < k > [tv(I:Int, ?) ~> makeType(T:Type) => tv(I:Int, T:Type)] ...</ k > : KSentence 
	--- ---[print "type of to " I:Int " to " ]
	--- .	
		
	--- mb rule 
		--- [L:KLabel(T:Type,, 'Direct-Function-Declarator('Pointer(D:Declarator[N:Nat]),, 'Parameter-Type-List(LL:List{Parameter}))) 
		--- => L:KLabel(arrayType(T:Type, N:Nat),, 'Direct-Function-Declarator('Pointer(D:Declarator),, 'Parameter-Type-List(LL:List{Parameter})))]
		--- if false
		--- orBool L:KLabel ==Bool 'Declaration
		--- orBool L:KLabel ==Bool 'Field
		--- orBool L:KLabel ==Bool 'Parameter-Declaration
		--- orBool L:KLabel ==Bool 'Typedef
		--- : KSentence [metadata "structural"] .
	--- mb rule 
		--- [L:KLabel(T:Type,, 'Direct-Function-Declarator('Pointer(D:Declarator[N:Nat]),, 'Parameter-Type-List(LL:List{Parameter}))) 
		--- => L:KLabel(pointerType(functionType(T:Type, getList{K}(LL:List{Parameter}))),, X:Id)
		--- L:KLabel(pointerType(functionType(T:Type, getList{K}(LL:List{Parameter}))),, 'Direct-Function-Declarator('Pointer(D:Declarator),, 'Parameter-Type-List(LL:List{Parameter})))]
		--- if false
		--- orBool L:KLabel ==Bool 'Declaration
		--- orBool L:KLabel ==Bool 'Field
		--- orBool L:KLabel ==Bool 'Parameter-Declaration
		--- orBool L:KLabel ==Bool 'Typedef
		--- : KSentence [metadata "structural"] .
	mb rule 
		[L:KLabel(T:Type,, D:Declarator[N:Nat]) 
		=> L:KLabel(arrayType(T:Type, N:Nat),, D:Declarator)]
		if false
		orBool L:KLabel ==Bool 'Declaration
		orBool L:KLabel ==Bool 'Field
		orBool L:KLabel ==Bool 'Parameter-Declaration
		orBool L:KLabel ==Bool 'Typedef
		: KSentence [metadata "structural"] .
	
	--- fixme ignoring extern
	mb rule
		[extern => .K]
		: KSentence [metadata "structural"] .
	--- fixme ignoring static
	mb rule
		[static => .K]
		: KSentence [metadata "structural"] .
	--- mb rule
		--- [extern ~> T:Type => qualifiedType(T:Type, extern)]
		--- : KSentence [metadata "structural"] .
	--- mb rule
		--- [static ~> T:Type => qualifiedType(T:Type, static)]
		--- : KSentence [metadata "structural"] .
	--- for casts, at least
	--- mb rule
		--- [Pointer(T:Type) => pointerType(T:Type)]
		--- : KSentence [metadata "structural"] .

	
	op arithConversion : K K -> K [metadata "strict"] .
	op arithConversion-int : K K -> K [metadata "strict"] .
	op integerPromotion : K -> K .

	--- fixme should only happen if arguments are arithmetic
	--- mb rule
		--- < k > [.K => arithConversion(V:Value, V':Value)] ~> L:KLabel(V:Value,, V':Value) ...</ k > 
		--- if false
		--- orBool L:KLabel ==Bool '_*_
		--- orBool L:KLabel ==Bool '_/_
		--- orBool L:KLabel ==Bool '_+_
		--- orBool L:KLabel ==Bool '_-_
		--- orBool L:KLabel ==Bool '_%_
		--- orBool L:KLabel ==Bool '_<_
		--- orBool L:KLabel ==Bool '_>_
		--- orBool L:KLabel ==Bool '_<=_
		--- orBool L:KLabel ==Bool '_>=_
		--- orBool L:KLabel ==Bool '_==_
		--- orBool L:KLabel ==Bool '_!=_
		--- : KSentence .
	
		
	---C99 6.3.1.8
	--- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, long-double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, long-double), tv(V2:BaseValue, long-double))] ...</ k >
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, double), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, double), tv(V2:BaseValue, double))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- : KSentence .
		
	--- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float. 53) For example, addition of a double _Complex and a float entails just the conversion of the float operand to double (and yields a double _Complex result).
	--- mb rule
		--- < k > [arithConversion(tv(V1:BaseValue, float), tv(V2:BaseValue, T2:Type)) => 
		--- converted(tv(V1:BaseValue, float), tv(V2:BaseValue, float))] ...</ k >
		--- if T2:Type =/=Bool long-double
		--- andBool T2:Type =/=Bool double
		--- : KSentence .
		
	--- Otherwise, the integer promotions are performed on both operands ...
	--- mb rule
		--- < k > [
			--- arithConversion(tv(V1:BaseValue, T1:Type), tv(V2:BaseValue, T2:Type)) 
			--- => 
			--- arithConversion-int(integerPromotion(tv(V1:BaseValue, T1:Type)), integerPromotion(tv(V2:BaseValue, T2:Type)))
		--- ] ...</ k >
		--- if T1:Type =/=Bool long-double andBool T2:Type =/=Bool long-double
		--- andBool T1:Type =/=Bool double andBool T2:Type =/=Bool double
		--- andBool T1:Type =/=Bool float andBool T2:Type =/=Bool float
		--- : KSentence .
	
	---C99 6.3.1.4:2 For objects or expressions with an integer type  whose integer conversion rank is less than or equal to the rank of int and unsigned int, and a bit field of type _Bool, int, signed int, or unsigned int, If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int.  These are called the integer promotions.  All other types are unchanged by the integer promotions.
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, int)) => tv(V:BaseValue, int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, unsigned-int)) => tv(V:BaseValue, unsigned-int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, unsigned-long-int)) => tv(V:BaseValue, unsigned-long-int)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, pointerType(T:Type))) => tv(V:BaseValue, pointerType(T:Type))] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [integerPromotion(tv(V:BaseValue, arrayType(T:Type, N:Nat))) => tv(V:BaseValue, arrayType(T:Type, N:Nat))] ...</ k >
		--- : KSentence .
	
	--- Then the following rules are applied to the promoted operands:
	
	--- If both operands have the same type, then no further conversion is needed.
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, T:Type), tv(V2:BaseValue, T:Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- fixme not sure about this
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type)) 
			--- => 
			--- converted(tv(V1:BaseValue, pointerType(T:Type)), tv(V2:BaseValue, T':Base-Type))
		--- ] ...</ k >
		--- : KSentence .	
	
	--- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
	
	--- fixme, hardcoded
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, unsigned-int), tv(V2:BaseValue, int)) 
			--- => 
			--- converted(tv(V1:BaseValue, unsigned-int), tv(V2:BaseValue, unsigned-int))
		--- ] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, unsigned-long-int), tv(V2:BaseValue, int)) 
			--- => 
			--- converted(tv(V1:BaseValue, unsigned-long-int), tv(V2:BaseValue, unsigned-long-int))
		--- ] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, int), tv(V2:BaseValue, unsigned-long-int)) 
			--- => 
			--- converted(tv(V1:BaseValue, unsigned-long-int), tv(V2:BaseValue, unsigned-long-int))
		--- ] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [
			--- arithConversion-int(tv(V1:BaseValue, unsigned-long-int), tv(V2:BaseValue, unsigned-int)) 
			--- => 
			--- converted(tv(V1:BaseValue, unsigned-long-int), tv(V2:BaseValue, unsigned-long-int))
		--- ] ...</ k >
		--- : KSentence .
	
	--- Otherwise...
	--- fixme left out cases
	
	
	----------------------------------------------------------------------
	--- mb rule 
		--- [Field(T:TogetherList, Pointer(D:Direct-Declarator)) => Field(Pointer(T:TogetherList), D:Direct-Declarator)]  
		--- : KSentence [metadata "structural"] .
	
	--- mb rule [Typedef(T:TogetherList, X:Typedef-Name) => typedef(normalizeType(T:TogetherList), X:Typedef-Name)] : KSentence .
	--- mb [function-prototype]: rule 
		--- < k > [Global(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List))) => .K] ...</ k >
		--- : KSentence .


	op locs : List{K} -> KResult .
	---Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)
	mb [start-declare]: rule
		< k > ['Declaration(T:Type,, X:Id) => declare(T:Type, X:Id)] ...</ k >
		: KSentence .
	
endm	

------------------------------------------------
---- C standard library
mod COMMON-C-STANDARD-LIBRARY is
	including COMMON-INCLUDE .
	
	op builtin : Id -> Value .
	
	--------------------------------------------
	mb [sqrt-is-value]: rule
		< k > [sqrt => builtin(sqrt)] ...</ k >
	: KSentence .
	mb [sqrt]: rule
		< k > [Apply(builtin(sqrt), tv(F:Float, double)) => tv(sqrtFloat(F:Float), double)] ...</ k >
	: KSentence .
	
	--------------------------------------------
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), tv(N:Nat, ?)) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [rand-is-value]: rule
		< k > [rand => builtin(rand)] ...</ k >
	: KSentence .
	mb [rand]: rule
		< k > [Apply(builtin(rand), .List{Expression}) => tv(randomRandom(Loc:Nat), int)] ...</ k >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [free-is-value]: rule
		< k > [free => builtin(free)] ...</ k >
	: KSentence .
	
	mb [free]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => Apply(builtin(free), tv(sNat(Loc:Nat), pointerType(T:Type)))] ...</ k >
		< mem >...  [Loc:Nat |-> ? => .Map] ...</ mem >
		< malloced >... [Loc:Nat |-> sNat(N:Nat) => sNat(Loc:Nat) |-> N:Nat] ...</ malloced >
	: KSentence .
	mb [free-done]: rule
		< k > [Apply(builtin(free), tv(Loc:Nat, pointerType(T:Type))) => skipval] ...</ k >
		< malloced >... [Loc:Nat |-> 0 => .Map] ...</ malloced >
	: KSentence .
	--------------------------------------------
	mb [calloc-is-value]: rule
		< k > [calloc => builtin(calloc)] ...</ k >
	: KSentence .
	
	--- fixme ignoring size for now
	mb [calloc]: rule
		< k > ['Apply(builtin(calloc),, (tv(N:Nat, ?) .,. tv(Size:Nat, ?))) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat (N:Nat *Nat Size:Nat)) |-> 0] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat (N:Nat *Nat Size:Nat)] </ nextLoc >
	: KSentence .
	--------------------------------------------
	mb [memset-is-value]: rule
		< k > [memset => builtin(memset)] ...</ k >
	: KSentence .
	
	--- fixme should be checking and casting types
	--- fixme should be making sure N:Nat is a char
	mb [memset]: rule
		< k > [Apply(builtin(memset), (tv(Loc:Nat, pointerType(T:Type)) .,. tv(N:Nat, int) .,. tv(Len:Nat, ?))) => tv(Loc:Nat, pointerType(void))] ...</ k >
		< mem > [M:Map => M:Map[N:Nat / Loc:Nat to (Loc:Nat +Nat Len:Nat)]] </ mem >
	: KSentence .
	--------------------------------------------
	mb [strlen-is-value]: rule
		< k > [strlen => builtin(strlen)] ...</ k >
	: KSentence .
	
	op strlen-aux : Nat Nat -> K .
	mb [strlen-start]: rule
		< k > [Apply(builtin(strlen), tv(Loc:Nat, pointerType(?))) => strlen-aux(0, Loc:Nat)] ...</ k >
	: KSentence .
	
	mb [strlen-nz]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => strlen-aux(sNat(Len:Nat), sNat(Loc:Nat))] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strlen-z]: rule
		< k > [strlen-aux(Len:Nat, Loc:Nat) => tv(Len:Nat, cfg:sizeut)] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcpy-is-value]: rule
		< k > [strcpy => builtin(strcpy)] ...</ k >
	: KSentence .
	
	--- fixme ensure char
	op strcpy-aux : Nat Nat Nat -> K .
	mb [strcpy-start]: rule
		< k > [Apply(builtin(strcpy), (tv(Dest:Nat, pointerType(T:Type)) .,. tv(Src:Nat, pointerType(T:Type)))) => strcpy-aux(Src:Nat, Dest:Nat, Dest:Nat)] ...</ k >
	: KSentence .
	
	mb [strcpy-nz]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => strcpy-aux(sNat(Src:Nat), sNat(Dest:Nat), Orig:Nat)] ...</ k >
		< mem >... Src:Nat |-> N:Nat Dest:Nat |-> [? => N:Nat] ...</ mem >
		if notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [strcpy-z]: rule
		< k > [strcpy-aux(Src:Nat, Dest:Nat, Orig:Nat) => tv(Orig:Nat, pointerType(char))] ...</ k >
		< mem >... Src:Nat |-> 0 Dest:Nat |-> [? => 0] ...</ mem >
	: KSentence .
	--------------------------------------------
	mb [strcmp-is-value]: rule
		< k > [strcmp => builtin(strcmp)] ...</ k >
	: KSentence .
	
	op strcmp-aux : Nat Nat -> K .
	mb [strcmp-start]: rule
		< k > [Apply(builtin(strcmp), (tv(Loc1:Nat, pointerType(?)) .,. tv(Loc2:Nat, pointerType(?)))) => strcmp-aux(Loc1:Nat, Loc2:Nat)] ...</ k >
	: KSentence .
	
	mb [strcmp-same-addy]: rule
		< k > [strcmp-aux(Loc:Nat, Loc:Nat) => 0] ...</ k >
		: KSentence .
	mb [strcmp-same]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => strcmp-aux(sNat(Loc1:Nat), sNat(Loc2:Nat))] ...</ k >
		< mem >... Loc1:Nat |-> N:Nat Loc2:Nat |-> N:Nat ...</ mem >
		if N:Nat =/=Bool 0
		: KSentence .
	mb [strcmp-done]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => tv(0, int)] ...</ k >
		< mem >... Loc1:Nat |-> 0 Loc2:Nat |-> 0 ...</ mem >
		: KSentence .
	mb [strcmp-different]: rule
		< k > [strcmp-aux(Loc1:Nat, Loc2:Nat) => tv(if N1:Nat >Nat N2:Nat then 1 else -1 fi, int)] ...</ k >
		< mem >... Loc1:Nat |-> N1:Nat Loc2:Nat |-> N2:Nat ...</ mem >
		if N1:Nat =/=Bool N2:Nat
		: KSentence .
	--------------------------------------------
	mb [putchar-is-value]: rule
		< k > [putchar => builtin(putchar)] ...</ k >
	: KSentence .
	--- fixme doesn't cast to int
	mb [putchar]: rule
		< k > [Apply(builtin(putchar), tv(N:Nat, ?)) => tv(N:Nat, int)] ...</ k >
		< output > [S:String => S:String +String charString(N:Nat %Nat 256)] </ output >
	: KSentence .
	--------------------------------------------
	mb [lib-printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [lib-printf-start]: rule
		< k > [Apply(builtin(printf), (tv(Loc:Nat, pointerType(?)) .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [lib-printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat)] </ output >
		if notBool(N:Nat ==Bool asciiString("%")) 
		andBool notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [lib-printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	mb [lib-printf-null]: rule
		< k > [printf-aux(0, 0, .List{Expression}) => 6] ...</ k >
		< output > [S:String => S:String +String "(null)"] </ output >
	: KSentence .
	
	mb [lib-printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	mb [lib-printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(D:Int, ?) .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Int, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Int, 10)] </ output >
		if N:Nat ==Bool asciiString("d") 
	: KSentence .
	mb [lib-printf-%s]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (tv(S:Nat, pointerType(?)) .,. L:List{Expression})) => 
			printf-aux(0, S:Nat, .List{Expression})
			~> printf-aux(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if N:Nat ==Bool asciiString("s") 
	: KSentence .

	mb [lib-printf-%s-done]: rule
		< k > [tv(Len':Nat, int) ~> printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => 
			printf-aux(Len:Nat +Nat Len':Nat, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
endm

mod COMMON-PARAMETER-BINDING is
	including COMMON-INCLUDE .
	op bind : List{K} List{K} -> K .
	--- op bind : List{K} -> K .
	--- op evalList : List{K} -> K .
	---mb context bind(?:List{K}, (?:List{K},, [HOLE],, ?:List{K})) : KSentence .

	--- mb rule 
		--- < k > [evalList(L:List{KResult}) ~> bind(L':List{K}) => bind(L':List{K}, L:List{KResult})] ...</ k > 
		--- : KSentence .
	
	mb [void-to-id]: rule
		[Parameter-Type-List(Parameter-Declaration(void)) 
		=> Parameter-Type-List(.List{Parameter})] : KSentence [metadata "structural"] .
	
	--- empty binding
	mb [bind-empty]: rule 
		< k > [bind(.List{K}, .List{K}) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	--- fixme doesn't add all derived types from T:Type
	--- fixme not cleaning memory on return
	--- fixme would be nice to check types match, but argument names etc might not be identical
	mb rule
		< k > [bind((tv(V:BaseValue, arrayType(T:Type, ?)),, L:List{KResult}), PD:List{K})
			=> bind((tv(V:BaseValue, pointerType(T:Type)),, L:List{KResult}), PD:List{K})] ...</ k > : KSentence [metadata "structural"] .
			
	--- fixme can't this be done by heating bind?
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, D:Declarator),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, D:Declarator),, P:List{K}))] ...</ k >
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence .	
		
	mb [bind-one]: rule
		< k > [bind((tv(V:BaseValue, T:Type),, L:List{KResult}), ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))
			=> addTypes(X:Id, T':Type) ~> '_;(allocate(sizeof(T':Type))) ~> putInMem(Loc:Nat, tv(V:BaseValue, T:Type), T':Type, sizeof(T':Type)) ~> bind(L:List{KResult}, P:List{K})] ...</ k > 
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		: KSentence .
	mb rule
		< k > [bind(L:List{KResult}, ('Parameter-Declaration(T:Typedef-Name,, X:Id),, P:List{K}))
			=> bind(L:List{KResult}, ('Parameter-Declaration(T':Type,, X:Id),, P:List{K}))] ...</ k > 
		< typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		: KSentence .
		
	--- mb [bind-one-func-pointer]: rule 
		--- < k > [bind((V:Value .,. L:List{Expression}),, 
				--- Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), Parameter-Type-List(PTL:List{Parameter}))) ,., P:List{Parameter})) =>
			--- bind((.List{Expression} .,. L:List{Expression}),, 
				--- Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				--- ...</ k > 
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- : KSentence .
		
	--- mb [bind-one-typedef]: rule 
		--- < k > [bind(L:List{Expression},, 
				--- Parameter-Type-List(Parameter-Declaration(T:Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter})) =>
			--- bind(L:List{Expression},, 
				--- Parameter-Type-List(Parameter-Declaration(T':Type-Specifier, DFD:Direct-Declarator) ,., P:List{Parameter}))]
				--- ...</ k > 
		--- < typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
		
endm

mod COMMON-GLOBAL-DECLARATION is
	including COMMON-INCLUDE .
	
	mb rule
		< k > ['Global('Declaration(T:Type,, X:Id))
			=> addGlobalTypes(X:Id, T:Type) ~> '_;(allocate(sizeof(T:Type)))] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		if getKLabel(T:Type)=/=Bool 'functionType
		: KSentence .
		
	mb rule
		< k > ['Global('Declaration(TD:Typedef-Name,, D:Declarator))
			=> 'Global('Declaration(T:Type,, D:Declarator))] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence 
		.
	
	--- mb [global-variable-declaration]: rule
		--- < k > [Global(Declaration(int, I:Id)) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> int] ...</ types >
		--- : KSentence .
	--- mb [global-pointer-declaration]: rule
		--- < k > [Global(Declaration(Pointer(T:Type-Specifier), I:Id)) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		--- : KSentence .
	--- mb [global-func-pointer-declaration]: rule
		--- < k > [Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) => .K] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)] ...</ types >
		--- : KSentence .	
		
	mb [global-variable-declaration-init]: rule
		< k > ['_=_('Declaration(T:Type,, X:Id),, E:Expression) => 'Global('Declaration(T:Type,, X:Id)) ~> Deref(&(X:Id)) := E:Expression ;] ...</ k >
		: KSentence .
	--- mb [global-pointer-declaration-init]: rule
		--- < k > [Declaration(Pointer(T:Type-Specifier), I:Id) = E:Expression => Global(Declaration(Pointer(T:Type-Specifier), I:Id)) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		--- : KSentence .
		
	--- mb [global-func-pointer-declaration-init]: rule
		--- < k > [Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List)) = E:Expression => Global(Declaration(T:Type-Specifier, Direct-Function-Declarator(Pointer(I:Id), PTL:Parameter-Type-List))) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		--- : KSentence .
		
	mb [function-definition]: rule 
		< k > ['_`{_`}('Declaration(T:Type,, X:Id),, B:TogetherList)=> .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> Closure(X:Id, T:Type, B:TogetherList)] </ mem >
		< types >... [.Map => X:Id |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Type] ...</ typedefs >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb rule 
		< k > ['_`{_`}('Declaration(TD:Typedef-Name,, D:Declarator),, B:TogetherList) => '_`{_`}('Declaration(T:Type,, D:Declarator),, B:TogetherList)] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
		: KSentence .
		
	mb [function-prototype]: rule 
		< k > ['Global('Declaration(functionType(T:Type, L:List{K}),, I:Id)) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [Global(Typedef(T:TogetherList, X:Declarator)) => Typedef(T:TogetherList, X:Declarator)] ...</ k >
		: KSentence .
	mb [typedef-declaration]: rule
		< k > ['Typedef(T:Type,, X:Typedef-Name) => .K] ...</ k >
		< types >... [.Map => X:Typedef-Name |-> T:Type] ...</ types >
		< typedefs >... [.Map => X:Typedef-Name |-> T:Type] ...</ typedefs >
		: KSentence .
		
	mb rule 
		< k > [T:Type ~> addGlobalTypes(K:K) => addGlobalTypes(K:K, T:Type)] ...</ k >
		: KSentence .
		
	op initArray : List{K} Nat Type -> K .
	mb [global-array-declaration-init]: rule
		< k > ['_=`{_`}('Declaration(arrayType(T:Type, N:Nat),, X:Id),, L:List{Expression}) => '_;(allocate(sizeof(arrayType(T:Type, N:Nat)))) ~> initArray(getList{K}(L:List{Expression}), Loc:Nat, T:Type)] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => X:Id |-> Loc:Nat] ...</ genv >
		< nextLoc > Loc:Nat </ nextLoc >
		< types >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ types >
		< typedefs >... [.Map => X:Id |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		: KSentence .
		
	op initItem : K Nat Type -> K [metadata "strict(1)"] .
	mb [initArray]: rule
		< k > [initArray((Item:K,, Items:List{K}), Loc:Nat, T:Type) 
		=> initItem(Item:K, Loc:Nat, T:Type) ~> initArray(Items:List{K}, Loc:Nat, T:Type)] ...</ k >
		: KSentence .
	mb [initArray-empty]: rule
		< k > [initArray(.List{K}, ?, ?) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [tv(N:Nat, ?) ~> initArray(Items:List{K}, Loc:Nat, T:Type) 
		=> initArray(Items:List{K}, Loc:Nat +Nat N:Nat, T:Type) ] ...</ k >
		: KSentence 
		---[print N:Nat " bytes put in memory @ " Loc:Nat ]
		.
		
	--- putInMem(Loc:Nat, N:Int, T:Type, tv(sNat(Len:Nat), J:Type))
	---- NEXTLOCS AREN'T BEING SET PROPERLY
	mb rule
		< k > [initItem(tv(N:Nat, T:Type), Loc:Nat, T':Type) => putInMem(Loc:Nat, cast(T':Type, tv(N:Nat, T:Type)), T':Type, sizeof(T':Type)) ~> sizeof(T':Type)] ...</ k >
		: KSentence .
		
	--- mb [struct-declaration]: rule 
		--- < k > [Global(struct(X:Id, DS:TogetherList) ;) => addGlobalTypes(X:Id, structType(X:Id, DS:TogetherList))] ...</ k >
		--- ---< typedefs >... [.Map => struct(X:Id) |-> structstruct(X:Id, DS:TogetherList)] ...</ typedefs >
		--- : KSentence .
	
	op struct-aux : Id K List{KResult} -> K .
	---op partialType : Id -> Type .
	mb rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => struct-aux(X:Id, DS:TogetherList, .List{K}) ~> addGlobalTypes(X:Id)] ...</ k >
		< types >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ types >
		< typedefs >... [.Map => struct(X:Id) |-> structType(X:Id)] ...</ typedefs >
		: KSentence .
	mb rule 
		< k > [struct-aux(X:Id, (Field(T:TogetherList, D:Declarator) ~> K:K), L:List{KResult}) => Field(T:TogetherList, D:Declarator) ~> struct-aux(X:Id, K:K, L:List{KResult})] ...</ k >
		: KSentence .
	mb rule 
		< k > [typedField(T:Type, X:Id) ~> struct-aux(X':Id, K:K, L:List{KResult}) => struct-aux(X':Id, K:K, (L:List{KResult},, typedField(T:Type, X:Id)))] ...</ k >
		: KSentence .
	--- mb rule 
		--- < k > [struct-aux(X:Id, .K, L:List{KResult}) => structType(X:Id, L:List{KResult})] ...</ k >
		--- : KSentence .
	mb rule 
		< k > ['Field(T:Type,, X:Id) => typedField(T:Type, X:Id)] ...</ k >
		: KSentence .
		
  --- eq <_>_</_>(k,_~>_(_`(_`)(("struct").KProperLabel,_`,`,_(K1:K,Kcxt:KProper)),Rest:K),k)
    --- = <_>_</_>(k,_~>_(Kcxt:KProper,_~>_(_`(_`)(freezer("(\"struct\").KProperLabel(K1:K,,`[HOLE`]:K)"),_`(_`)(freezeVar("K1:K"),K1:K)),Rest:K)),k) [metadata "heating"] .	
		
	--- mb [struct-declaration]: rule 
		--- < k > [Global(struct(X:Id, DS:TogetherList) ;) => .K] ...</ k >
		--- < types >... [.Map => struct(X:Id) |-> structType(X:Id, DS:TogetherList)] ...</ types > 
		--- < typedefs >... [.Map => struct(X:Id) |-> structType(X:Id, DS:TogetherList)] ...</ typedefs >
		--- : KSentence .
	--- fixme gotta be a nicer way to do this
	mb rule
		< k > [struct-aux(X:Id, .K, L:List{KResult}) ~> addGlobalTypes(X:Id) => .K] ...</ k >
		< structs >... [.Map => struct(X:Id) |-> L:List{KResult}] ...</ structs >
		: KSentence .
	mb rule
		< k > [addGlobalTypes(X:Id, pointerType(T:Type)) => .K] ...</ k >
		< types >... [.Map => X:Id |-> pointerType(T:Type)] ...</ types >
		< typedefs >... [.Map => X:Id |-> pointerType(T:Type)] ...</ typedefs >
		: KSentence .
	mb rule
		< k > [addGlobalTypes(X:Id, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => X:Id |-> T:Base-Type] ...</ types >
		< typedefs >... [.Map => X:Id |-> T:Base-Type] ...</ typedefs >
		: KSentence .
		
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, arrayType(T:Type, N:Nat)) => addGlobalTypes(E:Expression[0], T:Type)] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, pointerType(T:Type)) => addGlobalTypes(Deref(E:Expression), T:Type)] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, T:Typedef-Name) => addGlobalTypes(E:Expression, T':Type)] ...</ k >
		--- < typedefs >... T:Typedef-Name |-> T':Type ...</ typedefs >
		--- : KSentence .
	--- mb rule
		--- < k > [addGlobalTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		--- < typedefs >... [.Map => E:Expression |-> T:Base-Type] ...</ typedefs >
		--- : KSentence .
endm

mod COMMON-LOCAL-DECLARATION is
	including COMMON-INCLUDE .
	
	--- mb [declaration-using-typedef]: rule
		--- < k > ['Declaration(Kp:KProper,, I:Id) => Declaration(T':Type-Specifier, I:Id)] ...</ k >
		--- < typedefs >... Kp:KProper |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
				


	mb rule
		< k > [addTypes(E:Expression, arrayType(T:Type, N:Nat)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> arrayType(T:Type, N:Nat)] ...</ types >
		: KSentence .
	mb rule
		< k > [addTypes(E:Expression, pointerType(T:Type)) => addTypes(Deref(E:Expression), T:Type)] ...</ k >
		< types >... [.Map => E:Expression |-> pointerType(T:Type)] ...</ types >
		: KSentence .
	mb rule
		< k > [addTypes(E:Expression, structType(X:Id)) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> structType(X:Id)] ...</ types >
		: KSentence .
	--- fixme?
	mb rule
		< k > [addTypes(E:Expression, functionType(T:Type, F:List{K})) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> functionType(T:Type, F:List{K})] ...</ types >
		: KSentence .
	--- mb rule
		--- < k > [addTypes(E:Expression, struct(X:Id)) => .K] ...</ k >
		--- < types >... [.Map => E:Expression |-> struct(X:Id)] ...</ types >
		--- : KSentence .
	--- mb rule
		--- < k > [addTypes(E:Expression, T:Typedef-Name) => addTypes(E:Expression, T':Type)] ...</ k >
		--- < types >... T:Typedef-Name |-> T':Type ...</ types >
		--- : KSentence .
	mb rule
		< k > [addTypes(E:Expression, T:Base-Type) => .K] ...</ k >
		< types >... [.Map => E:Expression |-> T:Base-Type] ...</ types >
		: KSentence .
		
		
		
	--- op struct-aux : Id Id Nat -> K .
	--- --- need to initialize inside struct
	--- --- fixme
	--- mb [local-struct-declaration]: rule
		--- < k > [Len:Nat ~> declare(struct(X:Id), X':Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => X':Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat Len:Nat))] ...</ locals >
		--- < nextLoc > [Loc:Nat => (Loc:Nat +Nat Len:Nat)] </ nextLoc >
		--- < types >... [.Map => X':Id |-> struct(X:Id)] ...</ types >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		--- : KSentence .
		

	mb rule
		< k > [declare(T:Type, X:Id)
			=> addTypes(X:Id, T:Type) ~> '_;(allocate(sizeof(T:Type)))] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< nextLoc > Loc:Nat </ nextLoc >
		---< types >... [.Map => X:Id |-> T:Type] ...</ types >
		: KSentence 
		--- [print "Declaring " X:Id] 
		.
	mb rule
		< k > [allocate(tv(Len:Nat, ?)) => Len:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat Len:Nat) |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat Len:Nat] </ nextLoc >
		: KSentence .
		
	--- mb [declaration-heat-array]: rule
		--- < k > [declare(T:Type-Specifier, '_`[_`](Kp:KProper,, N:Nat)) => declare(T:Type-Specifier[N:Nat], Kp:KProper) ~> declare(T:Type-Specifier, '_`[_`](HOLE,, N:Nat))] ...</ k >
		--- : KSentence .
	--- mb [declaration-cool-array]: rule
		--- < k > [Kr:KResult ~> declare(T:Type-Specifier, '_`[_`](HOLE,, N:Nat)) => declare-aux(T:Type-Specifier, '_`[_`](Kr:KResult,, N:Nat), .List{K})] ...</ k >
		--- : KSentence .
	--- --- pointer type, so "tail recursive" :)
	--- mb [declaration-heat-func-pointer]: rule
		--- < k > [declare(T:Type-Specifier, 'Direct-Function-Declarator('Pointer(Kp:KProper),, PTL:Parameter-Type-List)) => declare(funcptr(T:Type-Specifier, PTL:Parameter-Type-List), Kp:KProper)] ...</ k >
		--- : KSentence .

	--- mb rule
		--- < k > [declare-aux(T:Type-Specifier, '_`[_`](locs((ALoc:Nat,, Locs:List{K})),, N:Nat), Pre:List{K}) => declare-aux(T:Type-Specifier, '_`[_`](locs(Locs:List{K}),, N:Nat), (Loc:Nat to (Loc:Nat +Nat N:Nat),, Pre:List{K}))] ...</ k >
		--- < mem >... ALoc:Nat |-> [? => Loc:Nat] [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		--- < locals >... [.Bag => Bag(Loc:Nat to (Loc:Nat +Nat N:Nat))] ...</ locals >
		--- < nextLoc > [Loc:Nat => (Loc:Nat +Nat N:Nat)] </ nextLoc >
		--- : KSentence .
	--- mb [declaration-array-done]: rule
		--- < k > [declare-aux(T:Type-Specifier, '_`[_`](locs(.List{K}),, N:Nat), Pre:List{K}) => locs(Pre:List{K})] ...</ k >
		--- : KSentence .
	

	
	--- --- these should become a single rule once declarations are finished being unified
	--- mb [declaration-id-array]: rule
		--- < k > [declare(T:Type-Specifier[N:Nat], I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> T:Type-Specifier[N:Nat]] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-func-pointer]: rule
		--- < k > [declare(funcptr(K1:K, K2:K), I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> funcptr(K1:K, K2:K)] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-pointer]: rule
		--- < k > [declare(Pointer(T:Type-Specifier), I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		--- : KSentence .
	--- mb [declaration-id-base]: rule
		--- < k > [declare(int, I:Id) => locs(Loc:Nat)] ...</ k >
		--- < env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		--- < mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		--- < locals >... [.Bag => BagItem(Loc:Nat)] ...</ locals >
		--- < nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		--- < types >... [.Map => I:Id |-> int] ...</ types >
		--- : KSentence .
		
	--- mb [local-struct-declaration-start]: rule
		--- < k > [declare(struct(X:Id), X':Id) => calcStructSize(DS:TogetherList) ~> declare(struct(X:Id), X':Id)] ...</ k >
		--- < typedefs >... struct(X:Id) |-> struct(X:Id, DS:TogetherList) ...</ typedefs >
		--- : KSentence .



endm

***(
"i=0,p=16,*p=0,
i=1,p=17,*p=1,
i=2,(a+1)=20,
i=3,(a+1)=20,
i=4,(a+1)=20,
***)


mod COMMON-EXPRESSIONS is
	including COMMON-INCLUDE .

	--- mb [pointerAddition]: rule ['_+o_(K1:K,, K2:K) => '_+_(K1:K,, K2:K)] : KSentence  .
	--- mb [pointerSubtraction]: rule ['_-o_(K1:K,, K2:K) => '_-_(K1:K,, K2:K)] : KSentence  .
	--- mb [pointerAddition]: rule [tv(V1:BaseValue, pointerType(T:Type)) +o V2:Value => tv(V1:BaseValue, pointerType(T:Type)) + (sizeof(T:Type) * V2:Value)] : KSentence  .
	
	---x ("_+o_").KProperLabel(("_`[_`]").KProperLabel("Id" arr(.List{K}),,"Rat" 0(.List{K})),,("tv").KResultLabel("Rat" 0(.List{K}),,"Base-Type" int(.List{K}))) 
	 
	---- [print E:Expression]

	--- --- fixme not modding
	--- --- fixme result needs type
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? * ? 
	--- => tv(I1:Int *Int I2:Int, T:Type)] ...</ k > : KSentence 
	--- ---[print "mult " I1:Int " * " I2:Int]
	--- .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? / ? 
	--- => tv(I1:Int /Int I2:Int, T:Type)] ...</ k > : KSentence .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? % ? 
	--- => tv(I1:Int %Int I2:Int, T:Type)] ...</ k > : KSentence .
	
	--- --- fixme assumes that because the types are the same, isn't pointer arithmetic
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? + ? 
	--- => tv(I1:Int +Int I2:Int, T:Type)] ...</ k > : KSentence .
	
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? - ? 
	--- => tv(_-Int_(I1:Int, I2:Int), T:Type)] ...</ k > : KSentence .
	

	--- --- fixme integer type
	--- mb rule < k > [converted(tv(I1:Int, pointerType(T:Type)), tv(I2:Int, T':Type)) ~> ? + ? 
	--- => tv(I1:Int, pointerType(T:Type)) +i (sizeof(T:Type) * tv(I2:Int, T':Type))] ...</ k > : KSentence 
	--- ---[print "adding " I1:Int " +o " I2:Int]
	--- .
	--- mb rule < k > [converted(tv(I1:Int, pointerType(T:Type)), tv(I2:Int, T':Type)) ~> ? - ? 
	--- => tv(I1:Int, pointerType(T:Type)) -i (sizeof(T:Type) * tv(I2:Int, T':Type))] ...</ k > : KSentence .

	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_+_(tv(I1:Int, cfg:sizeut),, '_*_(sizeof(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if integerTypes contains T:Type
		andBool T':Type =/=Bool void
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) + tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_+_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if integerTypes contains T:Type
		: KSentence .
	--- fixme totally wrong
	mb rule [tv(I1:Int, pointerType(T':Type)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(T':Type), '_-_(tv(I1:Int, cfg:sizeut),, '_*_(sizeof(T':Type),, tv(I2:Int, cfg:sizeut))))]
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, pointerType(void)) - tv(I2:Int, T:Type) 
	=> cast(pointerType(void), '_-_(tv(I1:Int, cfg:sizeut),, tv(I2:Int, cfg:sizeut)))]
		if integerTypes contains T:Type
		: KSentence .
	--- fixme need to use defined type
	mb rule [tv(I1:Int, pointerType(T:Type)) - tv(I2:Int, pointerType(T:Type)) 
	=> tv(_-Int_(I1:Int, I2:Int), long-int)]
		: KSentence .
		
	--- fixme ignoring qualified types
	mb rule [cast(qualifiedType(T:Type, ?), V:Value) => cast(T:Type, V:Value)] 
		: KSentence .	
	
	mb rule [tv(I1:Int, T:Type) + tv(I2:Int, T:Type) => cast(T:Type, I1:Int +Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [_-_(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) => cast(T:Type, _-Int_(I1:Int,I2:Int))] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) * tv(I2:Int, T:Type) => cast(T:Type, I1:Int *Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) / tv(I2:Int, T:Type) => cast(T:Type, I1:Int /Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	mb rule [tv(I1:Int, T:Type) % tv(I2:Int, T:Type) => cast(T:Type, I1:Int %Int I2:Int)] 
		if integerTypes contains T:Type
		: KSentence .
	 
	
	--- mb rule [tv(I1:Int, T:Type) + tv(I2:Int, T:Type) => tv(I1:Int +Int I2:Int, T:Type)] 
		--- if integerTypes contains T:Type
		--- : KSentence .
	--- mb rule [_-_(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) => tv(_-Int_(I1:Int,I2:Int), T:Type)] 
		--- if integerTypes contains T:Type
		--- : KSentence .
		
	--- --- mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	--- --- mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	--- --- mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	--- --- mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- --- mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [tv(I1:Int, T:Type) +i tv(I2:Int, ?) => tv(I1:Int +Int I2:Int, T:Type)] : KSentence 
	--- ---[print "adding " I1:Int " + " I2:Int]
	--- .
	--- mb rule [tv(I1:Int, T:Type) -i tv(I2:Int, ?) => tv(_-Int_(I1:Int, I2:Int), T:Type)] : KSentence .
	--- mb rule [! tv(I:Int, T:Type) => tv(if (I:Int ==Bool 0) then 1 else 0 fi, int)] : KSentence .
	--- --- mb rule [tv(I1:Int, ?) *i tv(I2:Int, ?) => I1:Int *Int I2:Int] : KSentence .
	--- --- mb rule [tv(I1:Int, ?) %i tv(I2:Int, ?) => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- --- --- mb rule [- I => -Int I] : KSentence .
	
	--- --- fixme, restricted for pointers
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? < ? => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? <= ? => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? > ? => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? >= ? => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? == ? => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	--- mb rule < k > [converted(tv(I1:Int, T:Type), tv(I2:Int, T:Type)) ~> ? != ? => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi] ...</ k > : KSentence .
	
	mb rule [tv(I1:Int, T:Type) < tv(I2:Int, T:Type) => if (I1:Int <Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) <= tv(I2:Int, T:Type) => if (I1:Int <=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) > tv(I2:Int, T:Type) => if (I1:Int >Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) >= tv(I2:Int, T:Type) => if (I1:Int >=Int I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) == tv(I2:Int, T:Type) => if (I1:Int ==Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [tv(I1:Int, T:Type) != tv(I2:Int, T:Type) => if (I1:Int =/=Bool I2:Int) then tv(1, int) else tv(0, int) fi] : KSentence .
	mb rule [!(tv(I:Int, T:Type)) => if (I:Int ==Bool 0) then tv(1, int) else tv(0, int) fi] : KSentence .

	--- --- --- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- --- --- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	--- --- mb rule [!(I:Int) => if (I:Int ==Bool 0) then 1 else 0 fi] : KSentence .
	
	--- --- mb rule [I:Int >> N:Nat => I:Int >>Int N:Nat] : KSentence .
	--- --- mb rule [I:Int << N:Nat => I:Int <<Int N:Nat] : KSentence .
	--- --- mb rule [I1:Int | I2:Int => I1:Int |Int I2:Int] : KSentence .
	--- --- mb rule [_&_(I1:Int, I2:Int) => I1:Int &Int I2:Int] : KSentence .
	--- --- mb rule [~ I:Int => ~Int I:Int] : KSentence .

	
endm

mod COMMON-C-SEMANTICS is
	including COMMON-INCLUDE .
	including SIZEOF .
	including COMMON-GLOBAL-DECLARATION .
	including COMMON-LOCAL-DECLARATION .
	including COMMON-C-STANDARD-LIBRARY .
	including COMMON-EXPRESSIONS .
	including COMMON-PARAMETER-BINDING .
	including TYPES .
	
	--- mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	--- fixme problem with strict operator and context?
	---op assign : K K -> K [metadata "strict 2"] .
	op assign : K K -> K .
	mb context &([HOLE] -> X:Id) : KSentence .
	mb context assign(Deref([HOLE]), ?) : KSentence .
	mb context assign(?, [HOLE]) : KSentence .

	op eval : Program -> Bag .
	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
		
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
		
		
	---c99 6.4.4.1:5 The type of an integer constant is the first of the corresponding list in which its value can be represented.
***(
											Octal or Hexadecimal 
Suffix			Decimal Constant			Constant
------------------------------------------------------------------
none			int							int
				long int					unsigned int
				long long int				long int
											unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
u or U			unsigned int 				unsigned int
				unsigned long int 			unsigned long int
				unsigned long long int 		unsigned long long int
------------------------------------------------------------------
l or L			long int 					long int
				long long int 				unsigned long int
											long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long int 			unsigned long int
and l or L 		unsigned long long int 		unsigned long long int
------------------------------------------------------------------
ll or LL 		long long int				long long int
											unsigned long long int
------------------------------------------------------------------
Both u or U		unsigned long long int 		unsigned long long int
and ll or LL
------------------------------------------------------------------
***)
	---c99 6.4.4.1:6 If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value. If all of the types in the list for the constant are signed, the extended integer type shall be signed. If all of the types in the list for the constant are unsigned, the extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.
	---c99 6.2.5:4 ... There may also be implementation-defined extended signed integer types. ...
	
	mb rule < k > [I:Int => 
		if ((I:Int <=Int max(int)) andBool (I:Int >=Int min(int))) then tv(I:Int, int) else
			if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
				if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		] ...</ k > 
		: KSentence .
		
	mb rule < k > [U(I:Int) => 
		if ((I:Int <=Int max(unsigned-int)) andBool (I:Int >=Int min(unsigned-int))) then tv(I:Int, unsigned-int) else
			if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
				if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else 
					tv(I:Int, no-type)
				fi
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [L(I:Int) => 
		if ((I:Int <=Int max(long-int)) andBool (I:Int >=Int min(long-int))) then tv(I:Int, long-int) else
			if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [UL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-int)) andBool (I:Int >=Int min(unsigned-long-int))) then tv(I:Int, unsigned-long-int) else
			if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
				tv(I:Int, no-type)
			fi
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [LL(I:Int) => 
		if ((I:Int <=Int max(long-long-int)) andBool (I:Int >=Int min(long-long-int))) then tv(I:Int, long-long-int) else
			tv(I:Int, no-type)
		fi
		] ...</ k > 
		: KSentence .
	mb rule < k > [ULL(I:Int) => 
		if ((I:Int <=Int max(unsigned-long-long-int)) andBool (I:Int >=Int min(unsigned-long-long-int))) then tv(I:Int, unsigned-long-long-int) else
			tv(I:Int, no-type)
		fi
		] ...</ k > 
		: KSentence .
	
	--- we're ignoring types for now
	--- mb rule [U(I:Int) => tv(I:Int, unsigned-int)] : KSentence [metadata "structural"] .
	--- mb rule [UL(I:Int) => tv(I:Int, unsigned-long)] : KSentence [metadata "structural"] .
	--- mb rule [L(I:Int) => tv(I:Int, long)] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-int => int] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-short => int] : KSentence [metadata "structural"] .
	--- mb rule [unsigned-char => int] : KSentence [metadata "structural"] .
	--- mb rule [char => int] : KSentence [metadata "structural"] .
	--- mb rule [float => int] : KSentence [metadata "structural"] .
	--- mb rule [double => int] : KSentence [metadata "structural"] .
	
	--- skip labels
	mb [skip-label]: rule < k > [L:Id : S:Statement => S:Statement] ...</ k > : KSentence .
	
	--- dissolve blocks
	mb [dissolve-block]: rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- 6.3.2.2 Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have an array type is converted to the value stored in the designated object (and is no longer an lvalue).
		
	
	---C99 6.5.3.2 (p79) footnote 90) Thus, &*E == E; &(E1[E2]) == (E1 + E2)
	
	---C99 6.5.3.2 90) ... It is always true that if E is a function designator or an lvalue that is a valid operand of the u of the unary & operator, *&E is a function designator or an lvalue equal to E.
	
	--- mb rule [&(Deref(E:Expression)) => E:Expression] : KSentence [metadata "structural"] .
	--- mb rule [&(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression] : KSentence [metadata "structural"] .
	mb [for-assignment]: rule < k > [E1:Expression := E2:Expression => assign(Deref(&(E1:Expression)),  E2:Expression)] ...</ k > : KSentence .
	
	
	mb rule [&(Deref(E:Expression)) => E:Expression] : KSentence [metadata "structural"] .
	mb rule [&(E1:Expression[E2:Expression]) => E1:Expression + E2:Expression] : KSentence [metadata "structural"] .
	
	--- can't be done anywhere because same syntax as in declarations
	mb rule < k > [E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression)] ...</ k > : KSentence [metadata "structural"] .
	
***(
	todo	
	"Id" funcArr(.List{K}) |-> "Rat" 82(.List{K})
	"Id" funcArr(.List{K}) |-> pointerType(functionType(arrayType(int, 2), void))

	funcArr[0] := & main
	assign(Deref(&(funcArr[0])),  & main)
	&(funcArr[0]) ~> assign(Deref(HOLE),  & main)
	funcArr +o 0 ~> assign(Deref(HOLE),  & main)
	funcArr ~> HOLE +o 0 ~> assign(Deref(HOLE),  & main)

***)
	
	
	
	---C99 6.5.3.2:4 The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
	--- also see 6.3.2.1:3 for why i made the result a pointerType
	mb rule < k > [Deref(tv(Loc:Nat, pointerType(arrayType(T:Type, N:Nat)))) => tv(Loc:Nat, pointerType(T:Type))] ...</ k > : KSentence [metadata "structural"] .

	mb [lookup-function] : rule 
		< k > [Deref(tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
	: KSentence [metadata "structural"] .
	
	--- mb rule [sizeof(&(E1:Expression[E2:Expression])) => sizeof(E1:Expression +o E2:Expression)] : KSentence [metadata "structural"] .
	
	
	--- turn variables into references when appropriate
	--- mb [make-assign-ref]: rule < k > [I:Id := E:Expression => Deref(&(I:Id)) := E:Expression] ...</ k > : KSentence .
	--- mb [make-assign-arrow-ref]: rule < k > [(E1:Expression -> X:Id) := E2:Expression => Deref(&(E1:Expression -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	--- mb [make-assign-arrow-ref]: rule < k > [(E1:Expression . X:Id) := E2:Expression => Deref(&((& E1:Expression) -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	--- mb [make-call-ref]: rule < k > [Apply(I:Id, L:List{Expression}) => Apply(Deref(&(I:Id)), L:List{Expression})] ...</ k > : KSentence .
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
	--- mb [array-revision]: rule < k > [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] ...</ k > : KSentence .
	--- mb [make-assign-array-ref]: rule < k > [ E1:Expression[E2:Expression] := E:Expression => Deref(E1:Expression + E2:Expression) := E:Expression] ...</ k > : KSentence .
	
	--- remove empty global
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	--- fixme
	--- 6.5.16
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	mb [assign-mod]: rule [E1:Expression %= E2:Expression => E1:Expression := E1:Expression % E2:Expression] : KSentence .
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-lshift]: rule [E1:Expression <<= E2:Expression => E1:Expression := E1:Expression << E2:Expression] : KSentence .
	mb [assign-rshift]: rule [E1:Expression >>= E2:Expression => E1:Expression := E1:Expression >> E2:Expression] : KSentence .
	mb [assign-bit-and]: rule [E1:Expression &= E2:Expression => E1:Expression := _&_(E1:Expression,  E2:Expression)] : KSentence .
	mb [assign-bit-xor]: rule [E1:Expression ^= E2:Expression => E1:Expression := E1:Expression ^ E2:Expression] : KSentence .
	mb [assign-bit-or]: rule [E1:Expression |= E2:Expression => E1:Expression := E1:Expression | E2:Expression] : KSentence .
	

	----- end simple transformations -----

	op readFromMem : Nat Type K Nat Nat -> K [metadata "strict(3)"] .
	op readStructFromMem : Nat Type K List{K} -> K [metadata "strict(3)"] .
	op structVal : List{K} Type -> Value .
	
	--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => readFromMem(Loc:Nat, T:Base-Type, sizeof(T:Base-Type), 0, 0)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> T:Base-Type ...</ types >
		: KSentence .
	mb [lookup-struct]: rule
		< k > [I:Id => readStructFromMem(Loc:Nat, structType(S:Id), sizeof(structType(S:Id)), .List{K})] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> structType(S:Id) ...</ types >
		: KSentence .
	mb rule
		< k > [readFromMem(Loc:Nat, T:Type, tv(0, ?), ?,  N:Nat) 
		=> interpret(N:Nat, T:Type)] ...</ k >
		: KSentence 
		---[print "read " N:Nat " ending at " Loc:Nat] 
		.
	--- fixme floats
	mb rule
		< k > [readFromMem(Loc:Nat, double, ?, ?, ?) => tv(V:Float, double)] ...</ k >
		< mem >... Loc:Nat |-> V:Float ...</ mem >
		: KSentence 
		---[print "read " N:Nat " ending at " Loc:Nat] 
		.
	mb rule
		< k > [readStructFromMem(Loc:Nat, T:Type, tv(0, ?), L:List{K}) 
		=> structVal(L:List{K}, T:Type)] ...</ k >
		: KSentence 
		.

	mb rule [interpret(N:Nat, T:Type) => tv(N:Nat, T:Type)]
		if min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat
		: KSentence [metadata "structural"] .
		
	--- fixme not sure about this
	mb rule
		[interpret(N:Nat, T:Type) => tv(_-Int_(N:Nat, (2 ^Nat absInt(numBits(T:Type)))), T:Type)]
		if notBool(min(T:Type) <=Int N:Nat andBool max(T:Type) >=Int N:Nat)
		andBool (N:Nat >=Int max(T:Type))
		: KSentence .
	
	--- fixme not necessarily the case that pointers are unsigned-ints
	mb rule [interpret(N:Nat, pointerType(T:Type)) => tv(N:Nat, pointerType(T:Type))]
		if min(unsigned-int) <=Int N:Nat andBool max(unsigned-int) >=Int N:Nat
		: KSentence [metadata "structural"] .
		
	--- fixme maybe this shouldn't be how i handle struct values
	--- mb rule [interpret(N:Nat, structType(X:Id)) => tv(N:Nat, structType(X:Id))]
		--- : KSentence [metadata "structural"] .
	
	
	--- deh = - 34
	--- adh = - 83
	--- deh = 222
	--- adh = 173
	--- deadh = 57005
	mb rule
		< k > [readFromMem(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), Len:Nat, N:Nat)
		=> readFromMem(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), sNat(Len:Nat), N:Nat |Nat (N':Nat <<Nat (8 *Nat Len:Nat)))] ...</ k >
		< mem >... Loc:Nat |-> N':Nat ...</ mem >
		: KSentence 
		---[print "r@ " Loc:Nat ": " N':Nat] 
		.
	mb rule
		< k > [readStructFromMem(Loc:Nat, T:Type, tv(sNat(Left:Nat), T':Type), L:List{K})
		=> readStructFromMem(sNat(Loc:Nat), T:Type, tv(Left:Nat, T':Type), (L:List{K},, K:K))] ...</ k >
		< mem >... Loc:Nat |-> K:K ...</ mem >
		: KSentence 
		---[print "r@ " Loc:Nat ": " N':Nat] 
		.	
		
	mb [lookup-pointer]: rule
		< k > [I:Id => readFromMem(Loc:Nat, pointerType(T:Type), sizeof(pointerType(T:Type)), 0, 0)] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< types >... I:Id |-> pointerType(T:Type) ...</ types >
		: KSentence 
		---[print "reading " I:Id] 
		.
		

		
	---C99 6.3.2.1:3 Except when it is the operand of the sizeof operator or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.
	mb rule
		< k > [X:Id => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> arrayType(T:Type, N:Nat) ...</ types >
		: KSentence .
		
	---C99 6.3.2.1:4 A function designator is an expression that has function type.  Except when it is the operand of the sizeof operator or the unary & operator, a function designator with type "function returning T" is converted to an expression that has type "pointer to a function returning T"
	mb [lookup-closure]: rule
		< k > [X:Id => tv(Loc:Nat, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> functionType(T:Type, L:List{K}) ...</ types >
		: KSentence .
		
		
	--- mb rule
		--- < k > [X:Id => readFromMem(Loc:Nat, structType(X':Id, F:List{KResult}), sizeof(structType(X':Id, F:List{KResult})), 0, 0)] ...</ k >
		--- < env >... X:Id |-> Loc:Nat ...</ env >
		--- < types >... X:Id |-> structType(X':Id, F:List{KResult}) ...</ types >
		--- : KSentence .
	--- op lookupStruct : Nat K Type List{K} -> K [metadata "strict(2)"] .
	--- mb rule
		--- < k > [X:Id => lookupStruct(Loc:Nat, sizeof(X:Id), structType(X':Id, F:List{KResult}), .List{K})] ...</ k >
		--- < env >... X:Id |-> Loc:Nat ...</ env >
		--- < types >... X:Id |-> structType(X':Id, F:List{KResult}) ...</ types >
		--- : KSentence .
		
	--- mb [lookupStruct]: rule
		--- < k > [
			--- lookupStruct(Loc:Nat, tv(sNat(Len:Nat), T:Type), T':Type, L:List{K})
			--- =>
			--- lookupStruct(sNat(Loc:Nat), tv(Len:Nat, T:Type), T':Type, (L:List{K},, V:BaseValue))
		--- ] ...</ k >
		--- < mem >... Loc:Nat |-> V:BaseValue ...</ mem >
		--- : KSentence .
	--- mb [lookupStruct-finish]: rule
		--- < k > [
			--- lookupStruct(Loc:Nat, tv(0, ?), T:Type, L:List{K})
			--- =>
			--- tv(L:List{K}, T:Type)
		--- ] ...</ k >
		--- : KSentence .

		
	--- mb [lookup]: rule
		--- < k > [I:Id => V:Value] ...</ k >
		--- < env >... I:Id |-> Loc:Nat ...</ env >
		--- < mem >... Loc:Nat |-> V:Value ...</ mem >
		--- : KSentence .
		
	op allocString : String -> K .

	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [.K => allocString(S:String)] ~> S:String ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > M:Map [.Map => S:String |-> tv(Loc:Nat, arrayType(char, lengthString(S:String) +Nat 1))] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => tv(N:Nat, pointerType(T:Type))] ...</ k >
		< statics >... S:String |-> tv(N:Nat, arrayType(T:Type, ?)) ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> charToAscii(firstChar(S:String))] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> 0] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
		
	--- mb [assign]: rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type)) => V:BaseValue] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:BaseValue] ...</ mem >
		--- : KSentence .
		
		
	--- fixme bad types, like this due to partial types
	--- mb [assign]: rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:Int, T':Type)) 
		--- => putInMem(Loc:Nat, V:Int, T:Type, sizeof(T:Type)) ~> tv(V:Int, T':Type)] ...</ k >
		--- if T:Type =/=Bool T':Type
		--- : KSentence
		--- [print "Warning: assigning possibly wrong type"]
		--- ---[print "assigning " V:Int " to " Loc:Nat]
		--- .
	mb [assign]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:Int, T:Type)) 
		=> putInMem(Loc:Nat, tv(V:Int, T:Type), T:Type, sizeof(T:Type)) ~> tv(V:Int, T:Type)] ...</ k >
		: KSentence .
	--- fixme this is to get around L:List{K} not comparing equal
	mb [assign-fp]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(pointerType(functionType(T:Type, L:List{K}))))), tv(V:Int, pointerType(functionType(T:Type, L':List{K})))) 
		=> putInMem(Loc:Nat, tv(V:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L:List{K})), sizeof(pointerType(functionType(T:Type, L:List{K})))) ~> tv(V:Int, pointerType(functionType(T:Type, L:List{K})))] ...</ k >
		: KSentence .
		
	--- fixme floats might have requirements
	mb [assign-float]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(double))), tv(V:Float, double)) 
		=> tv(V:Float, double)] ...</ k >
		< mem > [M:Map => M:Map[V:Float / Loc:Nat]] </ mem > 
		: KSentence .
		
	op assertEqual : K K -> K [metadata "strict"] .
	mb [assign-struct]: rule
		< k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), structVal(L:List{K},T:Type))
		=> 
		---assertEqual(sizeof(T:Type), length(L:List{K})) ~> 
		putBytesInMem(Loc:Nat, L:List{K}, T:Type, sizeof(T:Type)) ~> structVal(L:List{K},T:Type)] ...</ k >
		: KSentence
		---[print "assigning " V:Int " to " Loc:Nat]
		.
	
	mb rule
		< k > [putBytesInMem(Loc:Nat, (K:K,, L:List{K}), T:Type, tv(sNat(Len:Nat), J:Type)) => putBytesInMem(sNat(Loc:Nat), (L:List{K}), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		< mem >... Loc:Nat |-> [? => K:K] ...</ mem >
		: KSentence .
	mb rule
		< k > [putBytesInMem(Loc:Nat, .List{K}, T:Type, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	
	op putByteInMem : Nat BaseValue -> K .
	mb rule
		< k > [putInMem(?, ?, ?, tv(0, ?)) => .K] ...</ k >
		: KSentence .
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L:List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type)) 
		=> putInMem(Loc:Nat, tv(N:Int, pointerType(functionType(T:Type, L':List{K}))), pointerType(functionType(T:Type, L':List{K})), tv(Len:Nat, J:Type))] ...</ k >
		: KSentence 
		.
	mb rule
		< k > [putInMem(Loc:Nat, tv(N:Int, T:Type), T:Type, tv(sNat(Len:Nat), J:Type)) 
		=> putByteInMem(Loc:Nat, ((N:Int %Int 256) +Int 256) %Int 256) ~> putInMem(sNat(Loc:Nat), tv(N:Int >>Int 8, T:Type), T:Type, tv(Len:Nat, J:Type))] ...</ k >
		: KSentence 
		.
	mb rule
		< k > [putByteInMem(Loc:Nat, N:Nat) => .K] ...</ k >
		< mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		: KSentence 
		---[print "w@ " Loc:Nat ": " N:Nat] 
		.
	
	--- mb rule
		--- < k > [assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type)) => V:BaseValue] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:BaseValue] ...</ mem >
		--- : KSentence .
		
	--- mb [assign]: rule
		--- < k > [Deref(Loc:Nat) := V:Value => V:Value] ...</ k >
		--- < mem >... Loc:Nat |-> [? => V:Value] ...</ mem >
		--- ---if N:Nat <Int 1000000000
		--- : KSentence .
	--- mb [assign]: rule
		--- < k > [Deref(Loc:Nat) := N:Nat => N:Nat] ...</ k >
		--- < mem >... Loc:Nat |-> [? => N:Nat] ...</ mem >
		--- ---if N:Nat <Int 1000000000
		--- : KSentence .
		
	--- mb [equality]: rule
		--- < k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		--- : KSentence .
		
		
	---op evalDesignator : Expression -> K .
	
	mb [ref]: rule
		< k > [&(X:Id) => tv(Loc:Nat, pointerType(T:Type))] ...</ k >
		< env >... X:Id |-> Loc:Nat ...</ env >
		< types >... X:Id |-> T:Type ...</ types >
		: KSentence .
	
	--- mb [ref]: rule
		--- < k > [&(I:Id) => Loc:Nat] ...</ k >
		--- < env >... I:Id |-> Loc:Nat ...</ env >
		--- : KSentence .
	
	--- fixme this is crazy
	--- if label not arrayType?
	op fixPointerType : Type -> Type .
	eq fixPointerType(T:Base-Type) = pointerType(T:Base-Type) .
	eq fixPointerType(arrayType(T:Type, ?)) = pointerType(T:Type) .
	eq fixPointerType(structType(X:Id)) = pointerType(structType(X:Id)) .
	eq fixPointerType(pointerType(T:Type)) = pointerType(pointerType(T:Type)) .
	
	--- fixme if T:Type is an array type, this is wrong
	mb [address-of-arrow]: rule
		< k > [&(tv(Base:Int, pointerType(structType(S:Id))) -> X:Id) => cast(fixPointerType(T:Type), '_+_( tv(Base:Int, pointerType(void)),, calcStructSize(L1:List{KResult})))] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
	
	mb [address-of-dot]: rule
		< k > [&(E:Expression . X:Id) => &((&(E:Expression)) -> X:Id)] ...</ k >
		: KSentence .
	
	mb [arrow]: rule
		< k > [tv(Base:Int, pointerType(structType(S:Id))) -> X:Id => Deref(tv(Base:Int, pointerType(structType(S:Id)))) . X:Id] ...</ k >
		: KSentence .

	op extractField : List{K} Type K K Nat Nat -> K [metadata "strict(3 4)"] .
	--- mb [dot]: rule
		--- < k > [tv(N:Nat, structType(S:Id)) . X:Id => extractField(N:Nat, T:Type, sizeof(T:Type), calcStructSize(L1:List{KResult}))] ...</ k >
		--- < structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, X:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence .
		
	--- fixme this one is a doosy
	
	op dot-aux : K Id K -> K [metadata "strict(3)"] .
	mb rule
		< k > [(E:Expression . F:Id) => dot-aux(E:Expression, F:Id, typeof(E:Expression . F:Id))] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, arrayType(?, ?)) => &(E:Expression . F:Id)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, T:Base-Type) => E:Expression ~> dot-aux(HOLE, F:Id, T:Base-Type)] ...</ k >
		: KSentence .
	mb rule
		< k > [dot-aux(E:Expression, F:Id, pointerType(T:Type)) => E:Expression ~> dot-aux(HOLE, F:Id, pointerType(T:Type))] ...</ k >
		: KSentence .
		
	--- fixme doesn't handle case where what we are looking up is a struct
	mb rule
		< k > [structVal(L:List{K}, structType(S:Id)) ~> dot-aux(HOLE, F:Id, T:Type) => extractField(L:List{K}, T:Type, sizeof(T:Type), calcStructSize(L1:List{KResult}), 0, 0)] ...</ k >
		< structs >... struct(S:Id) |-> (L1:List{KResult},, typedField(T:Type, F:Id),, ?:List{KResult}) ...</ structs >
		: KSentence .
		
	--- mb [dot-static]: rule
		--- < k > [X:Id . F:Id => &(X:Id . F:Id)] ...</ k >
		--- < types >... X:Id |-> structType(S:Id) ...</ types >
		--- < structs >... struct(S:Id) |-> (?:List{KResult},, typedField(arrayType(T:Type, ?), F:Id),, ?:List{KResult}) ...</ structs >
		--- : KSentence .
	--- mb [dot-heat]: rule
		--- < k > [E:Expression . F:Id => E:Expression ~> (HOLE . F:Id)] ...</ k >
		--- < types > T:Map </ types >
		--- if notBool($hasMapping(T:Map, E:Expression))
		--- : KSentence .
	--- mb [dot-heat]: rule
		--- < k > [E:Expression . F:Id => E:Expression ~> (HOLE . F:Id)] ...</ k >
		--- < types > T:Map </ types >
		--- if notBool($hasMapping(T:Map, E:Expression))
		--- : KSentence .
	--- mb [dot-heat]: rule
		--- < k > [X:Id . F:Id => X:Id ~> (HOLE . F:Id)] ...</ k >
		--- < types >... X:Id |-> structType(S:Id) ...</ types >
		--- < structs >... struct(S:Id) |-> (?:List{KResult},, 'typedField(TL:KLabel(?),, F:Id),, ?:List{KResult}) ...</ structs >
		--- if TL:KLabel =/=Bool 'arrayType
		--- : KSentence .
	--- mb [dot-cool]: rule
		--- < k > [V:Value ~> (HOLE . F:Id) => V:Value . F:Id] ...</ k >
		--- : KSentence .
		
	mb [extractField-shift]: rule
		< k > [extractField((K:K,, L:List{K}), T:Type, V:Value, tv(sNat(Offset:Nat), T':Type), 0, 0) => extractField(L:List{K}, T:Type, V:Value, tv(Offset:Nat, T':Type), 0, 0)] ...</ k >
		: KSentence .
	mb [extractField-grab]: rule
		< k > [extractField((N':Nat,, L:List{K}), T:Type, tv(sNat(Left:Nat), T':Type), tv(0, T':Type), N:Nat, Len:Nat) 
		=> extractField(L:List{K}, T:Type, tv(Left:Nat, T':Type), tv(0, T':Type), N:Nat |Nat (N':Nat <<Nat (8 *Nat Len:Nat)), sNat(Len:Nat))]
		...</ k > : KSentence .
	
		
	mb [extractField-done]: rule
		< k > [extractField(?, T:Type, tv(0, T':Type), tv(0, T':Type), N:Nat, ?) => interpret(N:Nat, T:Type)]
		...</ k >
		: KSentence .
	
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(E1:Expression + getOffset(E1:Expression, X:Id))] ...</ k >
		--- : KSentence .
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(E1:Expression) . X:Id] ...</ k >
		--- : KSentence .
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(& (E1:Expression -> X:Id))] ...</ k >
		--- : KSentence .
	--- mb [dot]: rule
		--- < k > [E1:Expression . X:Id => (& E1:Expression) -> X:Id] ...</ k >
		--- : KSentence .
	--- mb [arrow]: rule
		--- < k > [E1:Expression -> X:Id => Deref(& (E1:Expression -> X:Id))] ...</ k >
		--- : KSentence .
		
	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
		
	--- op getOffset : K K -> Expression .
	--- mb [ref-arrow]: rule
		--- < k > [&(E1:Expression -> X:Id) => E1:Expression + getOffset(Deref(E1:Expression), X:Id)] ...</ k >
		--- : KSentence .
	--- mb [ref-dot]: rule
		--- < k > [&(E1:Expression . X:Id) => (& (E1:Expression)) + getOffset(E1:Expression, X:Id)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [.K => evalToType] ~> E1:Expression -> X:Id ...</ k >
		--- [.Bag => < type > E1:Expression </ type >]
		--- : KSentence .
	--- mb [arrow-cool]: rule
		--- < k > [evalToType ~> E1:Expression -> X:Id => Deref(E1:Expression + getOffset(Deref(E1:Expression), X:Id)) ~> makeType(T:Type)] ...</ k >
		--- [< type > pointerType(structType(X':Id, (L:List{KResult},, typedField(T:Type, X:Id),,  L':List{KResult}))) </ type > => .Bag] 
		--- : KSentence .
	--- mb [arrow-cool]: rule
		--- < k > [evalToType ~> E1:Expression -> X:Id => Deref(E1:Expression + getOffset(Deref(E1:Expression), X:Id)) ~> makeType(T:Type)] ...</ k >
		--- [< type > pointerType(structType(X':Id, (L:List{KResult},, typedField(T:Type, X:Id),,  L':List{KResult}))) </ type > => .Bag] 
		--- : KSentence .
	--- mb [arrow-cool]: rule
		--- < k > [evalToType ~> E1:Expression -> X:Id => Deref(E1:Expression + getOffset(Deref(E1:Expression), X:Id)) ~> makeType(T:Type)] ...</ k >
		--- [< type > pointerType(structType(X':Id, (?,, typedField(T:Type, X:Id),,  ?))) </ type > => .Bag] 
		--- : KSentence .
	--- Error: The sanity checks phase of compilation failed for rule arrow-cool .
  --- Term
        --- structType(X':Id,(?:List{K},,typedField(T:Type,X:Id),,?:List{K}))
  --- does not parse to a sort but rather to kind
        --- `[State`,List`{K`}`,Builtins`] .
  --- Please resolve that before continuing.

  	---C99 6.5.2.3:4 86) If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.
	--- mb rule
		--- < k > [E1:Expression . X:Id => &(E1:Expression) -> X:Id] ...</ k >
		--- : KSentence .
  
  
	--- mb rule --- wrong because type is wrong
		--- < k > [&(E1:Expression . X:Id) => & E1:Expression + getOffset(E1:Expression, X:Id)] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [.K => evalToType] ~> &(E1:Expression . X:Id) ...</ k >
		--- [.Bag => < type > E1:Expression </ type >]
		--- : KSentence .
	--- mb rule
		--- < k > [.K => evalToType] ~> &(E1:Expression -> X:Id) ...</ k >
		--- [.Bag => < type > Deref(E1:Expression) </ type >]
		--- : KSentence .
		
	--- mb rule
		--- < k > [E1:Expression . X:Id  => Deref(&(E1:Expression . X:Id))] ...</ k >
		--- : KSentence .
	--- mb rule
		--- < k > [.K => evalToType] ~> E1:Expression . X:Id ...</ k >
		--- [.Bag => < type > E1:Expression </ type >]
		--- : KSentence .
		
	---x ((((((((pointArr))) +o (((3))))) -> x)))
		
	--- fixme compute types way too many times
	--- mb [dot-cool]: rule
		--- < k > [evalToType ~> &(E1:Expression . X:Id) => (& (E1:Expression)) +i getOffset(E1:Expression, X:Id) ~> makeType(pointerType(T:Type))] ...</ k >
		--- [< type > structType(X':Id, (L1:List{KResult},, typedField(T:Type, X:Id),,  L2:List{KResult})) </ type > => .Bag] 
		--- : KSentence .
	--- mb [arrow-cool]: rule
		--- < k > [evalToType ~> &(E1:Expression -> X:Id) => E1:Expression +i getOffset(Deref(E1:Expression), X:Id) ~> makeType(pointerType(T:Type))] ...</ k >
		--- [< type > structType(X':Id, (L1:List{KResult},, typedField(T:Type, X:Id),,  L2:List{KResult})) </ type > => .Bag] 
		--- : KSentence .
	--- fixme possibly do maketype in wrong place
	--- mb [dot-cool]: rule
		--- < k > [evalToType ~> E1:Expression . X:Id => Deref((& (E1:Expression)) + getOffset(E1:Expression, X:Id)) ~> makeType(T:Type)] ...</ k >
		--- [< type > structType(X':Id, (L1:List{KResult},, typedField(T:Type, X:Id),,  L2:List{KResult})) </ type > => .Bag] 
		--- : KSentence .
	
	----  ~> makeType(pointerType(T:Type))
	
		

	--- op HOLE : -> Expression .
	
	--- mb [getOffset-heat]: rule
		--- < k > [getOffset(E:Expression, X:Id) => evalToType ~> getOffset(HOLE, X:Id)] ...</ k >
		--- [.Bag => < type > E:Expression </ type >]
		--- : KSentence .

		
***(

 < k > ("evalToType").KProperLabel(.List{K}) ~> ("getOffset").KProperLabel(("HOLE").KProperLabel(.List{K}),,"Id" a(.List{K})) ~> freezer("(\"_+_\").KProperLabel(K1:K,,`[HOLE`]:K)")(freezeVar("K1:K")("Id" mys1(.List{K}))) ... </ k > 
  < type > ("structType").KResultLabel("Id" s1(.List{K}),,kList("wklist_")(("typedField").KResultLabel(("arrayType").KResultLabel(("structType").KResultLabel("Id" point(.List{K}),,kList("wklist_")(("typedField").KResultLabel("Base-Type"
    int(.List{K}),,"Id" x(.List{K})),,("typedField").KResultLabel("Base-Type" int(.List{K}),,"Id" y(.List{K})))),,"Rat" 2(.List{K})),,"Id" a(.List{K})))) ~> ("Deref").KProperLabel(("HOLE").KProperLabel(.List{K})) </ type > 


***)
		
		
	--- fixme
	--- mb [getOffset-cool]: rule
		--- < k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(L1:List{KResult})] ...</ k >
		--- [< type > structType(X:Id, (L1:List{KResult},, typedField(T:Type, X':Id),,  L2:List{KResult})) </ type > => .Bag]
		--- : KSentence .
	--- mb [getOffset-cool-func-pointer]: rule
		--- < k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- [< type > structType(X:Id, (Fields1:SeqList ~> Field(T:TogetherList, Direct-Function-Declarator(Pointer(X':Id), PTL:Parameter-Type-List)) ~>  Fields2:SeqList)) </ type > => .Bag]
		--- : KSentence .
	--- mb [getOffset-cool-func-pointer-array]: rule
		--- < k > [evalToType ~> getOffset(HOLE, X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- [< type > structType(X:Id, (Fields1:SeqList ~> Field(T:TogetherList, Direct-Function-Declarator(Pointer(X':Id[N:Nat]), PTL:Parameter-Type-List)) ~>  Fields2:SeqList)) </ type > => .Bag]
		--- : KSentence .

	mb [function-application-pre]: rule
		< k > [Apply(tv(Loc:Nat, pointerType(functionType(?, ?))), L:List{Expression}) 
		=> Apply(V:Value, L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [function-application]: rule
		< k > [
			Apply(Closure(X:Id, functionType(R:Type, P:List{K}), B:K), L:List{Expression}) ~> K:K 
			=> 
			bind(getList{K}(L:List{Expression}), P:List{K}) ~> B:K
		] </ k >
		< env > [E:Map => G:Map] </ env >
		< genv > G:Map </ genv >
		< locals > [L:Bag => .Bag] </ locals >
		< types > [T:Map => GT:Map] </ types >
		< typedefs > GT:Map </ typedefs >
		< loopStack > [LS:List => .List] </ loopStack >
		< callStack > [.List => List(
			< stackFrame > 
				< continuation > K:K </ continuation >
				< locals > L:Bag </ locals >
				< env > E:Map </ env >
				< types > T:Map </ types >
				< loopStack > LS:List </ loopStack >
			</ stackFrame >
			)] ...</ callStack >
		: KSentence .
	
	--- mb rule < type > [Deref(& E:Expression) => E:Expression] ...</ type > : KSentence [metadata "structural"] .
	--- mb rule < type > [Deref(Pointer(T:TogetherList)) => T:TogetherList] ...</ type > : KSentence [metadata "structural"] .
	
	--- fixme wrong, clearly need to have one typing system
	--- mb rule
		--- < type > [E1:Expression + E2:Expression => E1:Expression] ...</ type >
		--- : KSentence .
	
	--- mb [evalToType-array-lookup]: rule
		--- < type > [E:Expression[E1:Expression] => E:Expression[0]] ...</ type >
		--- if E1:Expression =/=Bool 0
		--- : KSentence .
	--- mb [evalToType-exp-to-type]: rule
		--- < type > [E:Expression => T:Type] ...</ type >
		--- < types >... E:Expression |-> T:Type ...</ types >
		--- : KSentence .
	
	--- mb [array-heat]: rule
		--- < type > ['_`[_`](Kp:KProper,, 0) => Kp:KProper ~> HOLE[0]] ...</ type >
		--- : KSentence .
	--- mb [array-cool]: rule
		--- < type > [pointerType(T:Type) ~> HOLE[?] => T:Type] ...</ type >
		--- : KSentence .	
	
	--- mb rule
		--- < type > [arrayType(T:Type, N:Nat) => pointerType(T:Type)] ...</ type >
		--- : KSentence .
	
	--- --- mb rule
		--- --- < type > [struct(X:Id, Fields:SeqList) => structType(X:Id, Fields:SeqList)] ...</ type >
		--- --- : KSentence .
	
	--- mb [deref-heat]: rule
		--- < type > ['Deref(Kp:KProper) => Kp:KProper ~> 'Deref(HOLE)] ...</ type >
		--- : KSentence .
	--- mb [deref-cool]: rule
		--- < type > [pointerType(T:Type) ~> 'Deref(HOLE) => T:Type] ...</ type >
		--- : KSentence .
	--- --- mb [pointer-heat]: rule
		--- --- < type > [pointerType(Kp:KProper) => Kp:KProper ~> pointerType(HOLE)] ...</ type >
		--- --- : KSentence .
	--- --- mb [pointer-cool]: rule
		--- --- < type > [Kr:KResult ~> pointerType(HOLE) => pointerType(Kr:KResult)] ...</ type >
		--- --- : KSentence .
	--- mb [dot-heat]: rule
		--- < type > ['_._(Kp:KProper,, X:Id) => Kp:KProper ~> '_._(HOLE,, X:Id)] ...</ type >
		--- : KSentence .
	--- mb [dot-cool]: rule
		--- < type > [Kr:KResult ~> '_._(HOLE,, X:Id) => '_._(Kr:KResult,, X:Id)] ...</ type >
		--- : KSentence .
	--- --- mb [dot-lookup]: rule
		--- --- < type > ['_._(structType(SName:Id, (L1:List{KResult},, typedField(T:Type, FName:Id),,  L2:List{KResult})),, FName:Id) => T:Type] ...</ type >
		--- --- : KSentence .
		
--- ***(
	--- structType(s1, typedField(arrayType(, 2), a)) . a
--- ***)
		
	--- mb [typedef-lookup]: rule
		--- < type > [Kp:KProper => T:Type] ...</ type >
		--- < typedefs >... Kp:KProper |-> T:Type ...</ typedefs >
		--- : KSentence .
	
	mb [deref]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Base-Type))) 
		=> readFromMem(Loc:Nat, T:Base-Type, sizeof(T:Base-Type), 0, 0)
		] ...</ k >
		: KSentence .
	mb [deref-pointer]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))) 
		=> readFromMem(Loc:Nat, pointerType(T:Type), sizeof(pointerType(T:Type)), 0, 0)
		] ...</ k >
		: KSentence .
	mb [deref-struct]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(structType(X:Id)))) 
		=> readStructFromMem(Loc:Nat, structType(X:Id), sizeof(structType(X:Id)), .List{K})
		] ...</ k >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement else S':Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (tv(0, ?)) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (tv(I:Int, ?)) S:Statement => S:Statement] ...</ k >
		if I:Int =/=Bool 0
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (tv(0, ?)) S:Statement => .K] ...</ k >
		: KSentence .


	eq integerTypes = Set(char,, signed-char,, unsigned-char,, short-int,, int,, long-int,, long-long-int,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	eq unsignedIntegerTypes = Set(unsigned-char,, unsigned-short-int,, unsigned-int,, unsigned-long-int,, unsigned-long-long-int) .
	
	mb rule [Cast(T:TogetherList, E:Expression) => cast(T:TogetherList, E:Expression)] : KSentence [metadata "structural rule"] .
	
	mb rule
		< k > [cast(T:Type, tv(I:Int, T:Type)) => tv(I:Int, T:Type)] ...</ k > 
		: KSentence .
	
	---c99 6.3.1.3:1 When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged. 
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => tv(I:Int, T:Type)] ...</ k > 
		if min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int andBool (integerTypes contains T':Type)
		: KSentence .
		
	---c99 6.3.1.3:2 Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(I:Int +Int max(T:Type) +Int 1, T':Type))] ...</ k > 
		if notBool(min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int andBool (integerTypes contains T':Type))
		andBool (unsignedIntegerTypes contains T:Type andBool I:Int <=Int min(T:Type))
		andBool (integerTypes contains T':Type)
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, T':Type)) => cast(T:Type, tv(_-Int_(I:Int, (max(T:Type) +Int 1)), T':Type))] ...</ k > 
		if notBool(min(T:Type) <=Int I:Int andBool max(T:Type) >=Int I:Int andBool (integerTypes contains T':Type))
		andBool (unsignedIntegerTypes contains T:Type andBool I:Int >=Int max(T:Type))
		andBool (integerTypes contains T':Type)
		: KSentence .
	
	---c99 6.3.1.3:3 Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.
	
	---C99 6.3.1.4:1 When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.52) The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (-1, Utype_MAX+1).
	--- fixme
	mb rule
		< k > [cast(T:Type, tv(V:Float, double)) => cast(T:Type, tv(truncRat(float2ratConversion(V:Float)), long-long-int))] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
	
	---C99 6.3.1.4:2 When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined.
	--- fixme not handling floats correctly
	mb rule
		< k > [cast(double, tv(I:Int, T:Type)) => tv(rat2floatConversion(I:Int), double)] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
	
	---- Cast(unsigned-long, Cast(Pointer(int), 0))
	
	--- fixme 6.3.2.3 not handling this correctly
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, T':Type)) => tv(I:Int, pointerType(T:Type))] ...</ k >
		if min(unsigned-int) <=Int I:Int andBool max(unsigned-int) >=Int I:Int andBool (integerTypes contains T':Type)
		: KSentence .
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(T':Type))) => cast(T:Type, tv(I:Int, unsigned-int))] ...</ k > 
		if integerTypes contains T:Type
		: KSentence .
		
	--- fixme not sure where it says this
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, arrayType(T:Type, ?))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(T:Type), tv(I:Int, pointerType(void))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		: KSentence .
	mb rule
		< k > [cast(pointerType(void), tv(I:Int, pointerType(T:Type))) => tv(I:Int, pointerType(void))] ...</ k > 
		: KSentence .
	--- possibly not true with other endiannesses
	--- mb rule
		--- < k > [cast(pointerType(T:Type), tv(I:Int, pointerType(?))) => tv(I:Int, pointerType(T:Type))] ...</ k > 
		--- : KSentence .
	--- fixme not sure about this either...
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(arrayType(T':Type, ?)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		: KSentence .
	--- fixme ridiculous.
	mb rule
		< k > [cast(T:Type, tv(I:Int, pointerType(structType(S:Id)))) 
		=> cast(T:Type, tv(I:Int, pointerType(T':Type)))] ...</ k > 
		< structs >... struct(S:Id) |-> (typedField(T':Type, ?),, ?:List{KResult}) ...</ structs >
		: KSentence .
	--- mb rule
		--- < k > [cast(structType(X:Id), tv(I:Int, pointerType(void))) => tv(I:Int, structType(X:Id))] ...</ k > 
		--- : KSentence .	
	
	

	--- mb [cast-same]: rule
		--- ['Cast(T:Type,, tv(V:BaseValue, T:Type)) => tv(V:BaseValue, T:Type)]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
		
	--- fixme TOTALLY WRONG
	--- mb rule
		--- < k > ['Cast(T':Type,, tv(V:BaseValue, ?)) => tv(V:BaseValue, T':Type)] ...</ k > 
		--- : KSentence .
		
	--- throwing away casts now
	--- mb [cast-int]: rule
		--- [Cast(int, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-unsigned-long]: rule
		--- [Cast(unsigned-long, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-unsigned-int]: rule
		--- [Cast(unsigned-int, I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-pointer-type]: rule
		--- [Cast(Pointer(T:Type-Specifier), I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-func-pointer-type]: rule
		--- [Cast(Pointer(T:Type-Specifier, T':Type-Specifier), I:Int) => I:Int]
		--- ---< env >... X:Id |-> Loc:Nat ...</ env >
		--- ---< mem >... Loc:Nat |-> I:Int ...</ mem >
		--- : KSentence .
	--- mb [cast-typedef]: rule
		--- < k > [Cast(T:Type-Specifier, I:Int) => Cast(T':Type-Specifier, I:Int)] ...</ k >
		--- < typedefs >... T:Type-Specifier |-> T':Type-Specifier ...</ typedefs >
		--- : KSentence .
		
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K ] </ k >
		< loopStack > [ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K)) => .List] ...</ loopStack >
		: KSentence .

	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Loc:Nat) => .Bag] ...</ locals >	
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< locals > [.Bag => L:Bag] </ locals >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	op postInc : K K Type -> K [metadata "strict(2)"] .
	op postDec : K K Type -> K [metadata "strict(2)"] .
	mb [post-increment-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) ++
		=> postInc(Loc:Nat, readFromMem(Loc:Nat, T:Type, sizeof(T:Type), 0, 0), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) + tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if integerTypes contains T:Type
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-increment]: rule
		< k > [postInc(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) + tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .
		
	mb [post-decrement-start]: rule
		< k > [Deref(tv(Loc:Nat, pointerType(T:Type))) --
		=> postDec(Loc:Nat, readFromMem(Loc:Nat, T:Type, sizeof(T:Type), 0, 0), T:Type)
		] ...</ k >
		: KSentence .
		
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, T:Type), T:Type)
		=> assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(I:Int, T:Type) - tv(1, T:Type)) ~> discard ~> tv(I:Int, T:Type)
		] ...</ k >
		if integerTypes contains T:Type
		: KSentence .
	--- fixme would be simpler if i did integer promotions etc.
	mb [post-decrement]: rule
		< k > [postDec(Loc:Nat, tv(I:Int, pointerType(T:Type)), pointerType(T:Type))
		=> assign(Deref(tv(Loc:Nat, pointerType(pointerType(T:Type)))), tv(I:Int, pointerType(T:Type)) - tv(1, int)) ~> discard ~> tv(I:Int, pointerType(T:Type))
		] ...</ k >
		: KSentence .
		
	--- mb [post-increment]: rule
		--- < k > [Deref(tv(Loc:Nat, pointerType(T:Type))) ++ => assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type) + tv(1, int)) ~> discard ~> tv(V:BaseValue, T:Type)] ...</ k >
		--- < mem >... Loc:Nat |-> V:BaseValue ...</ mem >
		--- : KSentence .
	--- mb [post-decrement]: rule
		--- < k > [Deref(tv(Loc:Nat, pointerType(T:Type))) -- => assign(Deref(tv(Loc:Nat, pointerType(T:Type))), tv(V:BaseValue, T:Type) - tv(1, int)) ~> discard ~> tv(V:BaseValue, T:Type)] ...</ k >
		--- < mem >... Loc:Nat |-> V:BaseValue ...</ mem >
		--- : KSentence .
		
	

	

	mb [discard]: rule
		< k > [V:Value ~> discard => .K] ...</ k >
		: KSentence .	

	
endm
