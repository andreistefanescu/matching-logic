--- clearly need to distinguish between parts of my config, i.e., not be flat

mod COMMON-C-SEMANTICS is
	including C-SYNTAX .
	including C-CONFIGURATION .
	including K-CONTEXTS .
	
	sort Value .
	sort Type . 
	subsort TogetherList < Type < Expression < K .
	
	op Closure : Function-Definition -> Value .
	
	mb context Deref([HOLE]) := ? : KSentence .
	mb context Deref([HOLE]) ++ : KSentence .
	mb context Deref([HOLE]) -- : KSentence .
	---mb context GlobalDeclaration(int, I:Id) = E:Expression
	
	subsort Int < Value < Expression KResult .
	---subsort Value < List{Expression} .
	
	----op val : Expression Type -> KLabel 
	
	
	op List : BagItem -> ListItem .
	op unknown : -> K .
	op skipval : -> KResult . 
	op closure : -> KLabel .

	

	op eval : Program -> Bag .

	
	----- start simple transformations -----
	--- massage application with no argument
	mb rule [Apply(E:Expression) => Apply(E:Expression, .List{Expression})] : KSentence .
	
	--- lists turn to their id
	---mb rule [_`,List`{Expression`}_(.List{K}) => .List{Expression}] : KSentence .
	
	--- replace sequencing with ~>
	mb rule [S1:Statement S2:Statement => S1:Statement ~> S2:Statement] : KSentence [metadata "structural"] .
	---mb rule [.K S:Statement => .K] : KSentence .
	
	--- remove _;
	--- mb rule [E:Expression ; => E:Expression] : KSentence .
	--- mb rule [D:Declaration ; => D:Declaration] : KSentence .
	
	--- we're ignoring types for now
	mb rule [U(I:Int) => I:Int] : KSentence [metadata "structural"] .
	mb rule [unsigned-int => int] : KSentence [metadata "structural"] .
	
	--- dissolve blocks
	mb rule < k > [Block(B:TogetherList) => B:TogetherList] ...</ k > : KSentence .

	--- dissolve expression statements that are finished evaluating
	mb [value-statement]: rule < k > [V:Value ; => .K] ...</ k > : KSentence .
	
	--- turn variables into references when appropriate
	mb [make-assign-ref]: rule < k > [I:Id := E:Expression => Deref(&(I:Id)) := E:Expression] ...</ k > : KSentence .
	mb [make-assign-arrow-ref]: rule < k > [(E1:Expression -> X:Id) := E2:Expression => Deref(&(E1:Expression -> X:Id)) := E2:Expression] ...</ k > : KSentence .
	mb [make-call-ref]: rule < k > [Apply(I:Id, L:List{Expression}) => Apply(Deref(&(I:Id)), L:List{Expression})] ...</ k > : KSentence .
	mb [make-postinc-ref]: rule < k > [I:Id ++ => Deref(&(I:Id)) ++] ...</ k > : KSentence .
	mb [make-postdec-ref]: rule < k > [I:Id -- => Deref(&(I:Id)) --] ...</ k > : KSentence .
	mb [array-revision]: rule < k > [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] ...</ k > : KSentence .
	--- mb [array-revision]: rule [ E1:Expression[E2:Expression] => Deref(E1:Expression + E2:Expression) ] : KSentence .--- i don't think i can safely do this because of the _[_] being overloaded
	mb [make-assign-array-ref]: rule < k > [ E1:Expression[E2:Expression] := E:Expression => Deref(E1:Expression + E2:Expression) := E:Expression] ...</ k > : KSentence .
	
	--- for now, just ignore global wrapper
	---mb [remove-global-marker]: rule [Global(D:Declaration ;) => D:Declaration ;] : KSentence .
	--- for now, just ignore globals
	---mb [remove-global-marker]: rule [Global(D:Declaration) => .K] : KSentence .
	---mb [remove-global-marker]: rule [Global(D:Declaration) => D:Declaration] : KSentence .
	mb [remove-global-marker-empty]: rule [Global() => .K] : KSentence .
	
	--- simplify compound assignments (if E1 op= E2, need to ensure E1 only gets evaluated once to be correct)
	mb [assign-plus]: rule [E1:Expression += E2:Expression => E1:Expression := E1:Expression + E2:Expression] : KSentence .
	mb [assign-times]: rule [E1:Expression *= E2:Expression => E1:Expression := E1:Expression * E2:Expression] : KSentence .
	mb [assign-subtract]: rule [E1:Expression -= E2:Expression => E1:Expression := E1:Expression - E2:Expression] : KSentence .
	mb [assign-divide]: rule [E1:Expression /= E2:Expression => E1:Expression := E1:Expression / E2:Expression] : KSentence .
	

	----- end simple transformations -----

	
	--- special case lookup for main, since genv hasn't been put into env yet
	--- mb [lookup-main]: rule
		--- < k > [main => V:Value] ...</ k >
		--- < env > .Map </ env >
		--- < genv >... main |-> Loc:Nat ...</ genv >
		--- < mem >... Loc:Nat |-> V:Value ...</ mem >
		--- : KSentence .
		
	--- generic lookup
	mb [lookup]: rule
		< k > [I:Id => V:Value] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
	
		
		
	mb [global-variable-declaration]: rule
		< k > [Global(Declaration(int, I:Id)) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> int] ...</ types >
		: KSentence .
	mb [global-pointer-declaration]: rule
		< k > [Global(Declaration(Pointer(T:Type-Specifier), I:Id)) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< genv >... [.Map => I:Id |-> Loc:Nat] ...</ genv >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		: KSentence .
	mb [global-variable-declaration-init]: rule
		< k > [Declaration(int, I:Id) = E:Expression => Global(Declaration(int, I:Id)) ~> Deref(&(I:Id)) := E:Expression ;] ...</ k >
		: KSentence .
	mb [global-pointer-declaration-init]: rule
		< k > [Declaration(Pointer(T:Type-Specifier), I:Id) = E:Expression => Global(Declaration(Pointer(T:Type-Specifier), I:Id)) ~> Deref(&(I:Id)) := E:Expression ; ] ...</ k >
		: KSentence .
	
	mb [variable-declaration]: rule
		< k > [Declaration(int, I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> int] ...</ types >
		---< sizes >... [.Map => I:Id |-> 1 ] ...</ sizes > 
		: KSentence .
	mb [pointer-declaration]: rule
		< k > [Declaration(Pointer(T:Type-Specifier), I:Id) => .K] ...</ k >
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(Pointer(T:Type-Specifier), I:Id))] ...</ locals >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		< types >... [.Map => I:Id |-> Pointer(T:Type-Specifier)] ...</ types >
		---< sizes >... [.Map => Pointer(I:Id) |-> 1 ] ...</ sizes > 
		: KSentence .
	mb [array-declaration]: rule
		< k > [Declaration(int, X:Id[I:Int]) => .K] ...</ k >
		< env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat absInt(I:Int)) |-> unknown] ...</ mem >
		< locals >... [.Bag => Bag(Declaration(int, X:Id[absInt(I:Int)]))] ...</ locals >
		< nextLoc > [Loc:Nat => (sNat(Loc:Nat) +Nat absInt(I:Int))] </ nextLoc >
		< types >... [.Map => X:Id |-> int[I:Int]] ...</ types >
		---< sizes >... [.Map => X:Id |-> I:Int] ...</ sizes > 
		if I:Int >=Int 0
		: KSentence .
	mb [struct-declaration]: rule 
		< k > [Global(struct(X:Id, DS:TogetherList) ;) => .K] ...</ k >
		< typedefs >... [.Map => X:Id |-> struct(X:Id, DS:TogetherList)] ...</ typedefs >
		: KSentence .
		
	op allocString : String -> K .
	
	op firstChar : String -> Char .
	op butFirstChar : String -> String .
	op charToAscii : String -> Nat .
	
	--- requires that nothing else happen to allocate memory
	mb [const-string-notfound]: rule
		< k > [S:String => allocString(S:String) ~> Loc:Nat] ...</ k >
		< nextLoc > Loc:Nat </ nextLoc >
		< statics > [M:Map => M:Map[Loc:Nat / S:String]] </ statics >
		if notBool($hasMapping(M:Map, S:String))
		: KSentence .
	mb [const-string-found]: rule
		< k > [S:String => Loc:Nat] ...</ k >
		< statics >... S:String |-> Loc:Nat ...</ statics >
		: KSentence .
	mb [alloc-string]: rule
		< k > [allocString(S:String) => allocString(butFirstChar(S:String))] ...</ k >
		< mem >... [.Map => Loc:Nat |-> charToAscii(firstChar(S:String))] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		if lengthString(S:String) >Int 0
		: KSentence .
	mb [alloc-empty-string]: rule
		< k > [allocString("") => .K] ...</ k >
		< mem >... [.Map => Loc:Nat |-> 0] ...</ mem >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	--- mb [const-empty-string]: rule
		--- < k > [S:String => butFirstChar(S:String)] ...</ k >
		--- --- < env >... [.Map => X:Id |-> Loc:Nat] ...</ env >
		--- --- < mem >... [.Map => Loc:Nat |-> sNat(Loc:Nat)  sNat(Loc:Nat) to (sNat(Loc:Nat) +Nat absInt(I:Int)) |-> unknown] ...</ mem >
		--- --- < locals >... [.Bag => Bag(Declaration(int, X:Id[absInt(I:Int)]))] ...</ locals >
		--- --- < nextLoc > [Loc:Nat => (sNat(Loc:Nat) +Nat absInt(I:Int))] </ nextLoc >
		--- --- < sizes >... [.Map => X:Id |-> I:Int] ...</ sizes > 
		--- if lengthString(S:String) >Int 0
		--- : KSentence .
		
		
	mb [firstChar]: rule
		[firstChar(S:String) => substrString(S:String, 0, 1)]
		: KSentence .
	mb [charToAscii]: rule
		[charToAscii(C:Char) => asciiString(C:Char)]
		: KSentence .
	mb [butFirstChar]: rule
		[butFirstChar(S:String) => substrString(S:String, 1, lengthString(S:String))]
		: KSentence .
	
	mb [function-prototype]: rule 
		< k > [Global(Declaration(DS:TogetherList, Direct-Function-Declarator(I:Id, PTL:Parameter-Type-List))) => .K] ...</ k >
		: KSentence .
	mb [typedef-declaration]: rule
		< k > [Global(Typedef(DS:TogetherList, X:Typedef-Name)) => .K] ...</ k >
		< typedefs >... [.Map => X:Typedef-Name |-> DS:TogetherList] ...</ typedefs >
		---< sizes >... [.Map => X:Typedef-Name |-> ] ...</ sizes >
		: KSentence .
		
	
	
	op _to_ : Nat Nat -> List{K} .  
	eq N:Nat to N:Nat = .List{K} .
	ceq N:Nat to N':Nat = (N:Nat,,((N:Nat +Nat 1) to N':Nat))
		if N:Nat <Nat N':Nat .
	
	mb rule 
		[Declaration(DS:TogetherList, Pointer(DFD:Direct-Declarator)) => Declaration(Pointer(DS:TogetherList), DFD:Direct-Declarator)]
		: KSentence [metadata "structural"] .
	mb rule 
		[Parameter-Declaration(DS:TogetherList, Pointer(DFD:Direct-Declarator)) => Parameter-Declaration(Pointer(DS:TogetherList), DFD:Direct-Declarator)]
		: KSentence [metadata "structural"] .
	mb rule 
		[Field(T:TogetherList, Pointer(D:Direct-Declarator)) => Field(Pointer(T:TogetherList), D:Direct-Declarator)]  
		: KSentence [metadata "structural"] .
	

	op bind : -> KLabel .

		
	--- empty binding
	mb [bind-empty-void]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(Parameter-Declaration(void))) => .K] ...</ k > 
		: KSentence .
	mb [bind-empty]: rule 
		< k > [bind(.List{Expression},, Parameter-Type-List(.List{Parameter})) => .K] ...</ k > 
		: KSentence .
	--- bind one
	--- consider same variable name
	mb [bind-one-int]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(int, I:Id) ,., P:List{Parameter})) =>
			bind((.List{Expression} .,. L:List{Expression}),, 
				Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(int, I:Id))] ...</ parameters >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
	mb [bind-one-int-pointer]: rule 
		< k > [bind((V:Value .,. L:List{Expression}),, 
				Parameter-Type-List(Parameter-Declaration(Pointer(int), I:Id) ,., P:List{Parameter})) =>
			bind((.List{Expression} .,. L:List{Expression}),, 
				Parameter-Type-List(.List{Parameter} ,., P:List{Parameter}))]
				...</ k > 
		< env >... [.Map => I:Id |-> Loc:Nat] ...</ env >
		< mem >... [.Map => Loc:Nat |-> V:Value] ...</ mem >
		< parameters >... [.Bag => Bag(Parameter-Declaration(Pointer(int), I:Id))] ...</ parameters >
		< nextLoc > [Loc:Nat => sNat(Loc:Nat)] </ nextLoc >
		: KSentence .
		

--- bind(("_`,List`{Expression`}_").KHybridLabel("Int" 2(.List{K})),, ("Parameter-Type-List").KProperLabel(("Parameter-Declaration").KProperLabel(("int").KProperLabel(.List{K}),,("n").KProperLabel(.List{
		
	mb [assign]: rule
		< k > [Deref(Loc:Nat) := V:Value => V:Value] ...</ k >
		< mem >... Loc:Nat |-> [? => V:Value] ...</ mem >
		: KSentence .
		
	mb [equality]: rule
		< k > [V:Value == V':Value => if (V:Value ==Bool V':Value) then 1 else 0 fi] ...</ k >
		: KSentence .
		
	mb [ref]: rule
		< k > [&(I:Id) => Loc:Nat] ...</ k >
		< env >... I:Id |-> Loc:Nat ...</ env >
		: KSentence .
	op getOffset : K K -> Expression .
	mb [ref-arrow]: rule
		< k > [&(E1:Expression -> X:Id) => E1:Expression + getOffset(E1:Expression, X:Id)] ...</ k >
		: KSentence .
		
	mb [arrow]: rule
		< k > [E1:Expression -> X:Id => Deref(E1:Expression + getOffset(E1:Expression, X:Id))] ...</ k >
		: KSentence .
		
	mb [getOffset-exp-to-type]: rule
		< k > [getOffset(E1:Expression, X:Id) => getOffset(T:Type, X:Id)] ...</ k >
		< types >... E1:Expression |-> T:Type ...</ types >
		: KSentence .
	mb [getOffset-typedef]: rule
		< k > [getOffset(Pointer(T:Type-Specifier), X:Id) => getOffset(T':Type, X:Id)] ...</ k >
		< typedefs >... T:Type-Specifier |-> T':Type ...</ typedefs >
		: KSentence .
	--- mb [getOffset-struct]: rule
		--- < k > [getOffset(struct(X:Id), X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- < typedefs >... X:Id |-> struct(X:Id, (Fields1:SeqList Field(T:TogetherList, X':Id))) ...</ typedefs >
		--- : KSentence .
	--- mb [getOffset-struct]: rule  ---- doesn't work
		--- < k > [getOffset(struct(X:Id), X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- < typedefs >... X:Id |-> struct(X:Id, (Fields1:SeqList Field(T:TogetherList, X':Id) Fields2:SeqList)) ...</ typedefs >
		--- : KSentence .
	mb [getOffset-struct]: rule  ---- works
		< k > [getOffset(struct(X:Id), X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		< typedefs >... X:Id |-> 'struct(X:Id,, (Fields1:SeqList ~> Field(T:TogetherList, X':Id) ~>  Fields2:SeqList)) ...</ typedefs >
		: KSentence .
		
	--- mb [getOffset-struct]: rule  ---- works
		--- < k > [getOffset(struct(X:Id), X':Id) => calcStructSize(Fields1:SeqList)] ...</ k >
		--- < typedefs >... X:Id |-> 'struct(X:Id,, ('__('__(Fields1:SeqList,, Field(T:TogetherList, X':Id)),,  Fields2:SeqList))) ...</ typedefs >
		--- : KSentence .
		
		
	--- < k > [sizeof(struct(X:Id)) => calcStructSize(Fields:SeqList)] ...</ k >
		--- < typedefs >... X:Id |-> struct(X:Id, Fields:SeqList) ...</ typedefs >
		
	mb [deref]: rule
		< k > [Deref(Loc:Nat) => V:Value] ...</ k >
		< mem >... Loc:Nat |-> V:Value ...</ mem >
		: KSentence .
		
	mb [if-then-else-true]: rule
		< k > [if (I:Int) S:Statement else S':Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-else-false]: rule
		< k > [if (0) S:Statement else S':Statement => S':Statement] ...</ k >
		: KSentence .
	
	mb [if-then-true]: rule
		< k > [if (I:Int) S:Statement => S:Statement] ...</ k >
		if notBool(I:Int ==Bool 0)
		: KSentence .
	mb [if-then-false]: rule
		< k > [if (0) S:Statement => .K] ...</ k >
		: KSentence .
		
	--- throwing away casts now
	mb [cast-int]: rule
		< k > [Cast(int, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-long]: rule
		< k > [Cast(unsigned-long, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-unsigned-int]: rule
		< k > [Cast(unsigned-int, I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
	mb [cast-pointer-type]: rule
		< k > [Cast(Pointer(T:Type-Specifier), I:Int) => I:Int] ...</ k >
		---< env >... X:Id |-> Loc:Nat ...</ env >
		---< mem >... Loc:Nat |-> I:Int ...</ mem >
		: KSentence .
		
	
	--------------- Start Expressions ---------------
	mb rule [I1:Int + I2:Int => I1:Int +Int I2:Int] : KSentence .
	mb rule [_-_(I1:Int,I2:Int) => _-Int_(I1:Int,I2:Int)] : KSentence .
	mb rule [I1:Int * I2:Int => I1:Int *Int I2:Int] : KSentence .
	mb rule [I1:Int / I2:Int => I1:Int /Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	mb rule [I1:Int % I2:Int => I1:Int %Int I2:Int] if I2:Int =/=Bool 0 : KSentence .
	--- mb rule [- I => -Int I] : KSentence .
	mb rule [I1:Int < I2:Int => if (I1:Int <Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int <= I2:Int => if (I1:Int <=Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int > I2:Int => if (I1:Int >Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int >= I2:Int => if (I1:Int >=Int I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int == I2:Int => if (I1:Int ==Bool I2:Int) then 1 else 0 fi] : KSentence .
	mb rule [I1:Int != I2:Int => if (I1:Int =/=Bool I2:Int) then 1 else 0 fi] : KSentence .
	--- mb rule [T1 and T2 => T1 andBool T2] : KSentence .
	--- mb rule [T1 or T2 => T1 orBool T2] : KSentence .
	mb rule [!(I:Int) => if (I:Int ==Bool 0) then 1 else 0 fi] : KSentence .
	--------------- End Expressions ---------------
	
	op loopMarked : -> Statement .
	op popLoop : -> K .
	
	mb [while-mark]: rule
		< k > [while (B:Expression) S:Statement ~> K:K
		=> (loopMarked while (B:Expression) S:Statement) ~> popLoop ~> K:K
		] </ k >
		< loopStack > [.List => ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K))] ...</ loopStack >
		: KSentence .
	mb [while]: rule
		< k > [loopMarked ~> while (B:Expression) S:Statement
		=> 
		if (B:Expression) Block(Block(S:Statement loopMarked) (while (B:Expression) S:Statement))
		] ...</ k >
		: KSentence .
	mb [popLoop]: rule
		< k > [popLoop => .K] ...</ k >
		< loopStack > [Li:ListItem => .List] ...</ loopStack >
		: KSentence .
	mb [while-break]: rule
		< k > [break ; ~> ? => K:K ] </ k >
		< loopStack > [ListItem(_~>_(_~>_((while (B:Expression) S:Statement), popLoop), K:K)) => .List] ...</ loopStack >
		: KSentence .
		
	mb [return-clean-local]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local-pointer]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-local-pointer]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-local-array]: rule 
		< k > return ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id[N:Nat])) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem > [M:Map Loc:Nat |-> Start:Nat => cleanMap(M:Map, Start:Nat, N:Nat)] </ mem >
		: KSentence .
	mb [return-value-clean-local]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id)) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-local-array]: rule 
		< k > return V:Value ; ...</ k >
		< locals >... [BagItem(Declaration(int, I:Id[N:Nat])) => .Bag] ...</ locals >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem > [M:Map Loc:Nat |-> Start:Nat => cleanMap(M:Map, Start:Nat, N:Nat)] </ mem >
		: KSentence .
		
	op cleanMap : Map Nat Nat -> Map .
	eq cleanMap((M:Map (N:Nat |-> ?)), N:Nat, sNat(N':Nat)) = cleanMap(M:Map, sNat(N:Nat), N':Nat) .
	eq cleanMap(M:Map, N:Nat, 0) = M:Map .
		
	mb [return-value-clean-params]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-value-clean-params-pointer]: rule 
		< k > return V:Value ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-params]: rule 
		< k > return ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(int, I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .
	mb [return-clean-params-pointer]: rule 
		< k > return ; ...</ k >
		< parameters >... [BagItem(Parameter-Declaration(Pointer(T:Type-Specifier), I:Id)) => .Bag] ...</ parameters >	
		< env >... I:Id |-> Loc:Nat ...</ env >
		< mem >... [Loc:Nat |-> ? => .Map] ...</ mem >
		: KSentence .

	mb [return]: rule 
		< k > [return ; ~> ? => skipval ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< parameters > [.Bag => P:Bag] </ parameters >
		< locals > [.Bag => L:Bag] </ locals >
		---< sizes > [S':Map => S:Map] </ sizes >
		< loopStack > [? => LS:List] </ loopStack >
		< types > [? => T:Map] </ types >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< parameters > P:Bag </ parameters >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					---< sizes > S:Map </ sizes >
					< loopStack > LS:List </ loopStack >
					< types > T:Map </ types >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	mb [return-value]: rule 
		< k > [return V:Value ; ~> ? => V:Value ~> K:K] </ k >
		< env > [? => E:Map] </ env >
		< parameters > [.Bag => P:Bag] </ parameters >
		< locals > [.Bag => L:Bag] </ locals >
		---< sizes > [S':Map => S:Map] </ sizes >
		< loopStack > [LS':List => LS:List] </ loopStack >
		< callStack >
			[List(
				< stackFrame >...
					< continuation > K:K </ continuation >
					< parameters > P:Bag </ parameters >
					< locals > L:Bag </ locals >
					< env > E:Map </ env >
					---< sizes > S:Map </ sizes >
					< loopStack > LS:List </ loopStack >
				</ stackFrame >
			) => .List]
		...</ callStack >
		: KSentence .
		
	
	mb [post-increment]: rule
		< k > [Deref(Loc:Nat) ++ => V:Int] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => V:Int +Int 1] ...</ mem >
		: KSentence .	
	mb [post-decrement]: rule
		< k > [Deref(Loc:Nat) -- => V:Int] ...</ k >
		< mem >... Loc:Nat |-> [V:Int => _-Int_(V:Int, 1)] ...</ mem >
		: KSentence .
		
	
	---- FIXME 
	mb [sizeof-array-lookup]: rule
		< k > [sizeof(X:Id[?]) => 1] ...</ k >
		< types >... X:Id |-> int[N:Nat] ...</ types >
	: KSentence .
	mb [sizeof-array]: rule
		< k > [sizeof(X:Id) => N:Nat] ...</ k >
		< types >... X:Id |-> int[N:Nat] ...</ types >
	: KSentence .
	mb [sizeof-typedef]: rule
		< k > [sizeof(TD:Typedef-Name) => sizeof(T:Type)] ...</ k >
		< typedefs >... TD:Typedef-Name |-> T:Type ...</ typedefs >
	: KSentence .
	mb [sizeof-pointer]: rule
		< k > [sizeof(Pointer(TD:Typedef-Name)) => 1] ...</ k >
	: KSentence .
	mb [sizeof-int]: rule
		< k > [sizeof(int) => 1] ...</ k >
	: KSentence .
	mb [sizeof-struct]: rule
		< k > [sizeof(struct(X:Id)) => calcStructSize(Fields:SeqList)] ...</ k >
		< typedefs >... X:Id |-> struct(X:Id, Fields:SeqList) ...</ typedefs >
	: KSentence .


	op calcStructSize : SeqList -> K .
	mb [calcStructSize-int]: rule
		< k > ['calcStructSize(Field(TD:Typedef-Name, D:Declarator) ~> DS:SeqList) 
			=> '_+_(sizeof(TD:Typedef-Name),, calcStructSize(DS:SeqList))] ...</ k >
		: KSentence .
	mb [calcStructSize-done]: rule
		['calcStructSize(.K) => 0]
		: KSentence .		
	
		
	--- op KtoNat : K -> Nat .
	--- eq KtoNat(N:Nat) = N:Nat .
	--- --- TODO 
	--- mb [calcStructSize-int]: rule
		--- ['calcStructSize(Field(int, D:Declarator) ~> DS:SeqList) 
			--- => KtoNat(calcStructSize(DS:SeqList)) +Nat 1]
		--- : KSentence .
	--- mb [calcStructSize-pointer]: rule
		--- ['calcStructSize(Field(Pointer(T:TogetherList), D:Declarator) ~> DS:SeqList) 
			--- => KtoNat(calcStructSize(DS:SeqList)) +Nat 1]
		--- : KSentence .


------------------------------------------------
---- C standard library
	---- op builtin : Id -> KResult . --- i want this :(
	op builtin : Id -> Value .
	mb [malloc-is-value]: rule
		< k > [malloc => builtin(malloc)] ...</ k >
	: KSentence .
	
	mb [malloc]: rule
		< k > [Apply(builtin(malloc), N:Nat) => Loc:Nat] ...</ k >
		< mem >... [.Map => Loc:Nat to (Loc:Nat +Nat N:Nat) |-> unknown] ...</ mem >
		< malloced >... [.Map => Loc:Nat |-> N:Nat] ...</ malloced >
		< nextLoc > [Loc:Nat => Loc:Nat +Nat N:Nat] </ nextLoc >
	: KSentence .
	
	mb [printf-is-value]: rule
		< k > [printf => builtin(printf)] ...</ k >
	: KSentence .
	
	op printf-aux : Nat Nat List{Expression} -> K .
	op printf-% : Nat Nat List{Expression} -> K .
	mb [printf-start]: rule
		< k > [Apply(builtin(printf), (Loc:Nat .,. L:List{Expression})) => printf-aux(0, Loc:Nat, L:List{Expression})] ...</ k >
	: KSentence .
	
	mb [printf-normal]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-aux(sNat(Len:Nat), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String charString(N:Nat)] </ output >
		if notBool(N:Nat ==Bool asciiString("%")) 
		andBool notBool(N:Nat ==Bool 0)
	: KSentence .
	mb [printf-done]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => Len:Nat] ...</ k >
		< mem >... Loc:Nat |-> 0 ...</ mem >
	: KSentence .
	
	mb [printf-%]: rule
		< k > [printf-aux(Len:Nat, Loc:Nat, L:List{Expression}) => printf-%(Len:Nat, sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		if (N:Nat ==Bool asciiString("%"))
	: KSentence .
	mb [printf-%d]: rule
		< k > [printf-%(Len:Nat, Loc:Nat, (D:Nat .,. L:List{Expression})) => printf-aux(Len:Nat +Nat lengthString(rat2stringConversion(D:Nat, 10)), sNat(Loc:Nat), L:List{Expression})] ...</ k >
		< mem >... Loc:Nat |-> N:Nat ...</ mem >
		< output > [S:String => S:String +String rat2stringConversion(D:Nat, 10)] </ output >
		if N:Nat ==Bool asciiString("d") 
	: KSentence .
	
endm
