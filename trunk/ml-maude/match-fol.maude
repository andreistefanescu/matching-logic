in match-math


mod ENV is inc PL-INT .
  sorts PVar Env .
  op _|->_ : PVar Int -> Env [prec 10] .
  op .Env : -> Env .
  op _;;_ : Env Env -> Env [prec 90 assoc comm id: .Env format(d sg! so d)] .
  op _[_<-_] : Env PVar Int -> Env .
  var X : PVar .  vars I I' : Int .  var Env : Env .
  eq (X |-> I' ;; Env)[X <- I] = (X |-> I ;; Env) .
  eq Env[X <- I] = (X |-> I ;; Env) [owise] .
endm


mod MATHEMATICAL-ENV is inc MATHEMATICAL-INT + ENV .
  sorts ?Env !Env FreeEnv Env++ .   --- sort Env already declared
  subsorts ?Env !Env FreeEnv Env < Env++ < MathObj++ .
  subsort ?Env < ?MathObj .
  subsort !Env < !MathObj .
  subsort FreeEnv < FreeMathObj .
  subsort Env < MathObj .
  op ?Env : Nat -> ?Env .
  op skolem : Nat ?Env -> FreeEnv [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op _|->_ : PVar Int++ -> Env [ditto] .
  op _;;_ : Env++ Env++ -> Env++ [ditto] .
  op _[_<-_] : Env++ PVar Int++ -> Env .

  var X : PVar .  vars I I' I1 I2 : Int++ .  var Env Env1 Env2 : Env++ .

  eq (X |-> I' ;; Env)[X <- I] = (X |-> I ;; Env) .
  eq Env[X <- I] = (X |-> I ;; Env) [owise] .

  eq (X |-> I1 ;; Env1) === (X |-> I2 ;; Env2) = (I1 === I2) /\ (Env1 === Env2) .
endm


mod HEAP is inc PL-INT .
--- concrete heaps
  sorts Heap LocType List{LocType} TypedObj .
  subsort LocType < List{LocType} .
  op .empty : -> List{LocType} .
  op _,_ : List{LocType} List{LocType} -> List{LocType} [assoc id: .empty prec 5] .
  op _:_ : Int LocType -> TypedObj [prec 0] .
  op _|->_ : Int TypedObj -> Heap [prec 10] .
  op _|->_ : Int List{LocType} -> Heap [prec 10] .
  op .Heap : -> Heap .
  op _**_ : Heap Heap -> Heap [assoc comm id: .Heap format(d nic! o d)] .
endm


mod MATHEMATICAL-HEAP is inc MATHEMATICAL-INT + HEAP .
  sorts ?Heap !Heap FreeHeap Heap++ .   --- sort Heap already declared
  subsorts ?Heap !Heap FreeHeap Heap < Heap++ < MathObj++ .
  subsort ?Heap < ?MathObj .
  subsort !Heap < !MathObj .
  subsort FreeHeap < FreeMathObj .
  subsort Heap < MathObj .
  op ?Heap : Nat -> ?Heap .
  op skolem : Nat ?Heap -> FreeHeap [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op _:_ : Int++ LocType -> TypedObj [ditto] .
*** for sort issues
  op _:_ : MathObj++ LocType -> TypedObj [ditto] .
***
  op _|->_ : Int++ TypedObj -> Heap++ [ditto] .
  op _|->_ : Int++ List{LocType} -> Heap++ [ditto] .
  op _**_ : Heap++ Heap++ -> Heap++ [ditto] .

  sort HeapPatternName .
  op ___ : HeapPatternName List{MathObj++} List{MathObj++} -> Heap++ [prec 0 format(d ++ d --)] .

  vars H H1 H2 : Heap++ .

--- not sure if really needed
 ceq (H ** H1 === H ** H2) = (H1 === H2) if H =/= .Heap .
endm


mod MATCH-ENV is inc MATHEMATICAL-OBJECT .
  sort MatchEnv .

  op _|m->_ : MathObj++ MathObj++ -> MatchEnv [prec 10] .
  op .MatchEnv : -> MatchEnv .
  op _;;_ : MatchEnv MatchEnv -> MatchEnv [prec 90 assoc comm id: .MatchEnv format(d sg! so d)] .
---  op _[_<-_] : MatchEnv MathObj++ MathObj++ -> MatchEnv .

  vars X Obj Obj' : MathObj++ .  var MatchEnv : MatchEnv .

---  eq (X |m-> Obj' ; MatchEnv)[X <- Obj] = (X |m-> Obj ; MatchEnv) .
---  eq MatchEnv[X <- Obj] = (X |m-> Obj ; MatchEnv) [owise] .
endm


mod K is
  sorts K KProper KResult .
  subsorts KProper KResult < K .
  op .K : -> K .
  op _~>_ : K K -> K [assoc id: .K format (d ni+b! o -) prec 100] .
endm


mod CONFIG is inc K + MATHEMATICAL-ENV + MATHEMATICAL-HEAP + MATCH-ENV .
  sorts ConfigItem Set{ConfigItem} .  subsort ConfigItem < Set{ConfigItem} .
  op .empty : -> Set{ConfigItem} .
  op error : -> [Set{ConfigItem}] .
  op __ : Set{ConfigItem} Set{ConfigItem} -> Set{ConfigItem} [assoc comm id: .empty] .
  op _===>_ : ConfigItem Set{ConfigItem} -> Set{ConfigItem} [frozen] .

  op <config>_</config> : Set{ConfigItem} -> ConfigItem [format(niy! o nyi! o)] .
  op <k>_</k> : K -> ConfigItem [format (nib! oni nib! o)] .
  op <env>_</env> : Env++ -> ConfigItem [format (nig! o g! o)] .
  op <heap>_</heap> : Heap++ -> ConfigItem [format (nci++! n+++i---o n--ic! o)] .
  op <form>_</form> : Formula -> ConfigItem [format(nim o m o)] .
  op <menv>_</menv> : MatchEnv -> ConfigItem [format (nig! o g! o)] .
  op <newSym>_</newSym> : Nat -> ConfigItem [format (ni d d d)] .
  op <newImpl>_</newImpl> : Nat -> ConfigItem [format (ni d d d)] .

  sort Result .
  op (_feasible and_infeasible paths) : Nat Nat -> Result [format(g! d d d d d o)] .
  op [|_|] : K -> Result [format(y! d d d d o)] .
  op [| _,_,_ |] : Nat Nat Set{ConfigItem} -> Result [strat(0 1 2 3)] .

  vars N M : Nat .  vars Cfg Cfgs : Set{ConfigItem} .  var CCFFGG : [Set{ConfigItem}] .
---  eq [| N, M, <config> <form> FalseFormula </form> Cfg </config> Cfgs |] = [| N, M +Int 1, Cfgs |] .
  eq [| N, M, <config> <form> FalseFormula </form> Cfg </config> CCFFGG |] = [| N, M +Int 1, CCFFGG |] .
---  eq [| N, M, <config> <k> .K </k> Cfg </config> Cfgs |] = [| N +Int 1, M, Cfgs |] .
  eq [| N, M, <config> <k> .K </k> Cfg </config> CCFFGG |] = [| N +Int 1, M, CCFFGG |] .
  eq [| N, M, .empty |] = N feasible and M infeasible paths .
endm


mod SUBST is inc BOOL + CONFIG + PL-META-TERM .
  sort Subst .
  op .Subst : -> Subst .
  op _,_ : Subst Subst -> Subst [assoc comm id: .Subst] .
  op _<-_ : MathObj++ MathObj++ -> Subst .
  op _<-_ : List{MathObj++} List{MathObj++} -> Subst .
  op _[_] : Set{ConfigItem} Subst -> Set{ConfigItem} [prec 0 strat(2 0)] .

  vars Obj Obj' Obj1 Obj1' Obj2 Obj2' : MathObj++ .  var ObjList ObjList' : List{MathObj++} .
  eq (Obj1, Obj2, ObjList) <- (Obj1', Obj2', ObjList') = (Obj1 <- Obj1'), (Obj2 <- Obj2'), (ObjList <- ObjList') .
  eq .empty <- .empty = .Subst .


  sort MetaSubst .
  op .MetaSubst : -> MetaSubst .
  op _,_ : MetaSubst MetaSubst -> MetaSubst [assoc comm id: .MetaSubst] .
  op _<-_ : Term Term -> MetaSubst .
  op upSubst : Subst -> MetaSubst .

  var Subst : Subst .
  eq upSubst((Obj <- Obj'),  Subst) = (upTerm(Obj) <- upTerm(Obj')), upSubst(Subst) .
  eq upSubst(.Subst) = .MetaSubst .


  op substTerm : TermList MetaSubst -> TermList .

  var MetaSubst : MetaSubst . var QC : Constant .  var QT QT' NT : Term .  var QTList : TermList .  var QTNeList : NeTermList .  vars Q : Qid .
  eq substTerm((QT : QTNeList), MetaSubst) = substTerm(QT, MetaSubst) : substTerm(QTNeList, MetaSubst) .
  eq substTerm(empty, MetaSubst) = empty .
  eq substTerm(QT, ((QT <- QT'), MetaSubst)) = QT' .
  eq substTerm('skolem[NT : QT], MetaSubst) = 'skolem[NT : QT] .
  eq substTerm(Q[QTList], MetaSubst) = Q[substTerm(QTList, MetaSubst)] [owise] .
  eq substTerm(QC, MetaSubst) = QC [owise] .

  var CFGs : Set{ConfigItem} .  var Phi : Formula .
  --- apply substitution on a configuration
  eq CFGs[Subst] = downTerm(substTerm(upTerm(CFGs), upSubst(Subst)), error) .
endm

mod SKOL is inc SUBST .
  op skolemize : Nat Set{ConfigItem} -> Set{ConfigItem} [strat(0)] .

  op skolemTerm : Term TermList -> TermList .
  var QC : Constant .  vars QT NT NT' : Term .  var QTList : TermList .  var QTNeList : NeTermList .  var Q : Qid .
  eq skolemTerm(NT, (QT : QTNeList)) = skolemTerm(NT, QT) : skolemTerm(NT, QTNeList) .
  eq skolemTerm(NT, empty) = empty .
  eq skolemTerm(NT, QC) = if substr(string(getType(QC)), 0, 1) ==Bool "?" then 'skolem[NT : QC] else QC fi .
  eq skolemTerm(NT, '?Int[QT]) = 'skolem[NT : '?Int[QT]] .
  eq skolemTerm(NT, '?IntSeq[QT]) = 'skolem[NT : '?IntSeq[QT]] .
  eq skolemTerm(NT, '?IntTree[QT]) = 'skolem[NT : '?IntTree[QT]] .
  eq skolemTerm(NT, '?IntTreeSeq[QT]) = 'skolem[NT : '?IntTreeSeq[QT]] .
  eq skolemTerm(NT, '?IntBag[QT]) = 'skolem[NT : '?IntBag[QT]] .
  eq skolemTerm(NT, '?Graph[QT]) = 'skolem[NT : '?Graph[QT]] .
  eq skolemTerm(NT, 'skolem[NT' : QT]) = 'skolem[NT' : QT] .
  eq skolemTerm(NT, Q[QTList]) = Q[skolemTerm(NT, QTList)] [owise] .

  var N : Nat .  var CFGs : Set{ConfigItem} .
  eq skolemize(N, CFGs) = downTerm(skolemTerm(upTerm(N), upTerm(CFGs)), error) .
endm

mod FOL= is inc MATHEMATICAL-DOMAIN + SUBST + SKOL .
--- FOL= is the proving heart of matching logic.  Provided that one had a "FOL= oracle" that can
--- prove any implications of the form "Pattern ===> Pattern1 Pattern2 ... PatternN" (the conclusion is a disjunction of patterns),
--- then one basically has a matching logic verifier.  Since we do not have such a magic oracle, we are going to mimic one.
--- We do it in a few steps.

  op derive : Int++ -> K .

  ops (_=menv=>_) (_=skol=>_) (_=env=>_) (_=heap=>_) (_=form=>_) (_=debug=>_) : ConfigItem ConfigItem -> Set{ConfigItem} [format(ni nr! o nini) strat(1 2 0)] .

  vars CFG CFG' CFG1 CFG2 : ConfigItem .  vars CFGs Cfg Cfg' Cfg1 Cfg2 : Set{ConfigItem} .
  var ?Obj : ?MathObj .  vars ?ObjList ?ObjList1 ?ObjList2 : List{?MathObj} .
  var !Obj : !MathObj .
  var FreeObj : FreeMathObj .
  vars Obj Obj' Obj1 Obj2 : MathObj++ .  vars ObjList ObjList1 ObjList2 : List{MathObj++} .
  var X : PVar .  vars P P' : Int++ .  var T : LocType .  var HPN : HeapPatternName .
  vars Env1 Env2 : Env++ .  vars H H1 H2 : Heap++ .  vars Phi Phi1 Phi2 : Formula .  vars MatchEnv MatchEnv1 MatchEnv2 : MatchEnv .
  var K : K .
  vars ?Subst !Subst FreeSubst : Subst .


--- Step -1: generate multiple cases, one for each pattern in the conclusion
--- leads to state explosion
  rl [FOL] : CFG ===> (CFG1 CFGs) => CFG =menv=> CFG1 .
  rl [FOL] : CFG ===> (CFG1 CFGs) => CFG ===> CFGs .
  eq [FOL] : CFG ===> .empty = <form> FalseFormula </form> <menv> .MatchEnv </menv> .


--- Step 0:
 ceq [FOL] : <config> <menv> MatchEnv </menv> Cfg1 </config> =menv=> <config> Cfg2 </config>
   = <config> <menv> .MatchEnv </menv> Cfg1[!Subst] </config> =skol=> <config> <menv> MatchEnv </menv> Cfg2[!Subst] </config>
   if !Subst := get!Subst(MatchEnv) .


--- Step 1: Skolemize the bound variables in the hypothesis and discard those in the conclusion
--- (recall that the bound variables are known to be bound from their sorts, so no need to keep them in the pattern)
--- discard also all the useless configuration bookeeping infrastructure, at this moment just the counter for new symbols in the hypothesis 
  eq [FOL] : <config> Cfg <newSym> M:Nat </newSym> <newImpl> N:Nat </newImpl> </config> =skol=> CFG
   = skolemize(N:Nat, <config> Cfg </config>) =env=> CFG .


--- Step 2: Eliminate the environments
  eq [FOL] : <config> <env> Env1 </env> <menv> MatchEnv </menv> Cfg1 </config>
   =env=> <config> <env> Env2 </env> <form> Phi2 </form> Cfg2 </config>
   = <config> <menv> MatchEnv ;; get!Equalities(Env1 === Env2) </menv> Cfg1 </config>
   =heap=> <config> <form> Phi2 /\ Env1 === Env2 </form> Cfg2 </config> .


--- Step 3: Get rid of variable equalities and propagate them via substitution
--- Step 3.0.1 : Get rid of bound variables equalities at any time
 ceq [FOL] : <config> <k> K </k> <form> Phi </form> Cfg2 <menv> MatchEnv </menv> </config>
   = <config> <k> K </k> (<form> Phi </form> Cfg2)[?Subst] <menv> MatchEnv </menv> </config>
   if ?Subst := get?Subst(Phi) /\ ?Subst =/= .Subst .
***(
--- Step 3.0.2 : Get rid of unbound variable equalities at any time
 ceq [FOL] : <config> <k> K </k> <form> Phi </form> Cfg </config> = <config> Cfg' </config>
  if !Subst := get!Subst(Phi) /\ !Subst =/= .Subst /\ <config> Cfg' </config> := <config> <k> K </k> <form> Phi </form> Cfg </config>[!Subst] .
***)

--- Step 3.1 : Get rid of proof tasks for bound variable equalities in the conclusion
 ceq [FOL] : CFG =heap=> <config> <form> Phi2 </form> Cfg2 <menv> MatchEnv </menv> </config>
   = CFG =heap=> <config> (<form> Phi2 </form> Cfg2)[?Subst] <menv> MatchEnv </menv> </config>
   if ?Subst := get?Subst(Phi2) /\ ?Subst =/= .Subst .
 ceq [FOL] : CFG =form=> <config> <form> Phi2 </form> Cfg2 <menv> MatchEnv </menv> </config>
   = CFG =form=> <config> (<form> Phi2 </form> Cfg2)[?Subst] <menv> MatchEnv </menv> </config>
   if ?Subst := get?Subst(Phi2) /\ ?Subst =/= .Subst .

--- Step 3.2 : Get rid of unbound variable equalities in the hypothesis
 ceq [FOL] :  <config> <menv> MatchEnv1 </menv> Cfg1 </config> =heap=> <config> <menv> MatchEnv2 </menv> Cfg2 </config>
   = <config> <menv> .MatchEnv </menv> Cfg1[!Subst] </config> =heap=> <config> <menv> MatchEnv2 ;; MatchEnv1 </menv> Cfg2[!Subst] </config>
   if MatchEnv1 =/= .MatchEnv /\ !Subst := get!Subst(MatchEnv1) .
 ceq [FOL] :  <config> <menv> MatchEnv1 </menv> Cfg1 </config> =form=> <config> <menv> MatchEnv2 </menv> Cfg2 </config>
   = <config> <menv> .MatchEnv </menv> Cfg1[!Subst] </config> =form=> <config> <menv> MatchEnv2 ;; MatchEnv1 </menv> Cfg2[!Subst] </config>
   if MatchEnv1 =/= .MatchEnv /\ !Subst := get!Subst(MatchEnv1) .

--- Step 3.3 : Get rid of unbound variable equalities in the hypothesis
 ceq [FOL] : <config> <form> Phi1 </form> Cfg1 <menv> MatchEnv1 </menv> </config> =heap=> <config> Cfg2 <menv> MatchEnv2 </menv> </config>
   = <config> (<form> Phi1 </form> Cfg1)[FreeSubst] <menv> MatchEnv1 </menv> </config> =heap=> <config> Cfg2[FreeSubst] <menv> MatchEnv2 </menv> </config>
   if FreeSubst := getFreeSubst(Phi1) /\ FreeSubst =/= .Subst .
 ceq [FOL] : <config> <form> Phi1 </form> Cfg1 <menv> MatchEnv1 </menv> </config> =form=> <config> Cfg2 <menv> MatchEnv2 </menv> </config>
   = <config> (<form> Phi1 </form> Cfg1)[FreeSubst] <menv> MatchEnv1 </menv> </config> =form=> <config> Cfg2[FreeSubst] <menv> MatchEnv2 </menv> </config>
   if FreeSubst := getFreeSubst(Phi1) /\ FreeSubst =/= .Subst .


--- Step 4: Stepwise, eliminate the heap, if any
--- Step 4.1: Eliminate a heap pattern
  eq <config> <heap> HPN(ObjList)(ObjList1) ** H1 </heap> <form> Phi1 </form> <menv> MatchEnv </menv> Cfg1 </config>
   =heap=> <config> <heap> HPN(ObjList)(ObjList2) ** H2 </heap> <form> Phi2 </form> Cfg2 </config>
   = <config> <heap> H1 </heap> <form> Phi1 </form> <menv> MatchEnv ;; get!Equalities(ObjList1 === ObjList2) </menv> Cfg1 </config>
   =heap=> <config> <heap> H2 </heap> <form> Phi2 /\ ObjList1 === ObjList2 </form> Cfg2 </config> .

--- Step 4.2 : Eliminate a location
  eq <config> <heap> P |-> Obj1 : T ** H1 </heap> <form> Phi1 </form> <menv> MatchEnv </menv> Cfg1 </config>
   =heap=> <config> <heap> P |-> Obj2 : T ** H2 </heap> <form> Phi2 </form> Cfg2 </config>
   = <config> <heap> H1 </heap> <form> Phi1 </form> <menv> MatchEnv ;; get!Equalities(Obj1 === Obj2) </menv> Cfg1 </config>
   =heap=> <config> <heap> H2 </heap> <form> Phi2 /\ Obj1 === Obj2 </form> Cfg2 </config> .

--- Step 4.3 : Eliminate a globally bounded variable in the hypothesis
  eq <config> <heap> H </heap> <menv> MatchEnv </menv> Cfg1 </config> =heap=> <config> <heap> !Obj </heap> Cfg2 </config>
   = <config> <menv> MatchEnv ;; !Obj |m-> H </menv> Cfg1 </config> =form=> <config> Cfg2 </config> .

--- Step 4.4 : Eliminate a heap frame
  eq <config> <heap> H:FreeHeap ** H1 </heap> Cfg1 </config> =heap=> <config> <heap> H:FreeHeap ** H2 </heap> Cfg2 </config>
   = <config> <heap> H1 </heap> Cfg1 </config> =heap=> <config> <heap> H2 </heap> Cfg2 </config> [owise] .

--- Step 4.5 : Eliminate the heap cell
  eq <config> <heap> .Heap </heap> <form> Phi1 </form> Cfg1 </config> =heap=> <config> <heap> .Heap </heap> <form> Phi2 </form> Cfg2 </config>
   = <config> <form> Phi1 </form> Cfg1 </config> =form=> <config> <form> Phi2 </form> Cfg2 </config> .


--- Step 5: Get rid of the formula implication task
  eq <config> <form> Phi1 </form> <menv> .MatchEnv </menv> </config> =form=> <config> <form> Phi2 </form> <menv> MatchEnv </menv> </config>
   = <form> Phi1 ===> Phi2 </form> <menv> MatchEnv </menv> [owise] .


--- helper operations
  op get?Subst : Formula -> Subst .
---  eq get?Subst(?Obj === Obj /\ Phi) = (?Obj <- Obj), get?Subst(Phi) .
 ceq get?Subst(?Obj === Obj /\ Phi) = (?Obj <- Obj), get?Subst(Phi) if not(?Obj :: Int++) or (Obj :: Int++) .
--- equation below should not be needed, but we have to add it because === cannot be commutative, due to a Maude bug
---  eq get?Subst(Obj === ?Obj /\ Phi) = (?Obj <- Obj), get?Subst(Phi) .
 ceq get?Subst(Obj === ?Obj /\ Phi) = (?Obj <- Obj), get?Subst(Phi) if not(?Obj :: Int++) or (Obj :: Int++) .
  eq get?Subst(Phi) = .Subst [owise] .

  op getFreeSubst : Formula -> Subst .
  eq getFreeSubst(FreeObj === Obj /\ Phi) = (FreeObj <- Obj), getFreeSubst(Phi) .
--- equation below should not be needed, but we have to add it because === cannot be commutative, due to a Maude bug
  eq getFreeSubst(Obj === FreeObj /\ Phi) = (FreeObj <- Obj), getFreeSubst(Phi) .
  eq getFreeSubst(Phi) = .Subst [owise] .

  op get!Equalities : Formula -> MatchEnv .
  eq get!Equalities(!Obj === Obj /\ Phi) = !Obj |m-> Obj ;; get!Equalities(Phi) .
  eq get!Equalities(Obj === !Obj /\ Phi) = !Obj |m-> Obj ;; get!Equalities(Phi) .
  eq get!Equalities(Phi) = .MatchEnv [owise] .

  op get!Subst : MatchEnv -> Subst .
  eq get!Subst(!Obj |m-> Obj ;; MatchEnv) = (!Obj <- Obj), get!Subst(MatchEnv) .
  eq get!Subst(.MatchEnv) = .Subst [owise] .


  op VALID : Formula -> Bool .
  eq VALID(TrueFormula) = true .

  op _? : Bool -> K .
  eq true ? = .K .
endm
