***(
    This file is part of the Matching Logic Verification Framework

    Copyright (C) 2009-2011 Grigore Rosu

    This file is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
***)


mod MATHEMATICAL-MULTISET-BUILTIN-MODULE
  is inc MATHEMATICAL-INT-BUILTIN-MODULE .

  sorts PEMSet FEMSet FreeMSet NeMSet MSet MSet++ NeMSet++ . 
  subsort NeMSet < MSet .
  subsort NeMSet++ MSet < MSet++ .
  subsort PEMSet FEMSet FreeMSet NeMSet < NeMSet++ .
  subsort PEMSet < PEMathObj .
  subsort FEMSet < FEMathObj .
  subsort FreeMSet < FreeMathObj .
  subsort MSet < MathObj .
  subsort MSet++ < MathObj++ .
 
  op ?MSet : Nat -> PEMSet .
  op !MSet : Nat -> FEMSet .
  op FreeMSet : Nat -> FreeMSet .
  op skolem : Nat PEMSet -> FreeMSet [ditto] .
  op co-skolem : Nat FreeMSet -> FEMSet [ditto] .

  op empty : -> MSet .
  op `{|_|`} : List{MathObj++} -> NeMSet++ [gather(&)] .
  ---op `{|_|`} : PEMathObj -> PEMSet [ditto] .
  ---op `{|_|`} : FEMathObj -> FEMSet [ditto] .
  ---op `{|_|`} : FreeMathObj -> FreeMSet [ditto] .
  op `{|_|`} : MathObj -> NeMSet [ditto] .
  op `{|_|`} : MathObj++ -> NeMSet++ [ditto] .
  op _U_ : MSet++ MSet++ -> MSet++ [assoc comm id: empty] .
  op _U_ : NeMSet++ MSet++ -> NeMSet++ [ditto] .
  op _U_ : MSet++ NeMSet++ -> NeMSet++ [ditto] .
  ---op _U_ : PEMSet PEMSet -> PEMSet [ditto] .
  ---op _U_ : FEMSet FEMSet -> FEMSet [ditto] .
  ---op _U_ : FreeMSet FreeMSet -> FreeMSet [ditto] .
  op _U_ : MSet MSet -> MSet [ditto] .
  op _U_ : NeMSet MSet -> NeMSet [ditto] .
  op _U_ : MSet NeMSet -> NeMSet [ditto] .
  op _U_ : NeMSet MSet++ -> NeMSet++ [ditto] .
  op _U_ : MSet++ NeMSet -> NeMSet++ [ditto] .
  op _U_ : NeMSet++ MSet -> NeMSet++ [ditto] .
  op _U_ : MSet NeMSet++ -> NeMSet++ [ditto] .
  op _U_ : MSet++ MSet -> MSet++ [ditto] .
  op _U_ : MSet MSet++ -> MSet++ [ditto] .
  op _U_ : NeMSet++ NeMSet -> NeMSet++ [ditto] .
  op _U_ : NeMSet NeMSet++ -> NeMSet++ [ditto] . 

  op size : MSet++ -> Int++ . 
  ops min max : MSet++ -> Int++ .
  op in : MathObj++ MSet++ -> AtomFormula .

  var Phi1 Phi2 : Formula .
  var I J K K1 K2 : Int++ .
  var Obj Obj1 Obj2 : MathObj++ .
  var ObjList : List{MathObj++} .
  var A A1 A2 : MSet++ .
  var NeA NeA1 NeA2 : NeMSet++ .

  eq {| Obj1, Obj2, ObjList |} = {| Obj1 |} U {| Obj2 |} U {| ObjList |} .
  eq {| .List{MathObj++} |} = empty .
  eq {| Obj |} U A === empty = FalseFormula .
  eq NeA U A1 === NeA U A2 = A1 === A2 .
  eq size(NeA1 U NeA2) = size(NeA1) +Int size(NeA2) .
  eq size(empty) = 0 .
  eq @(min(NeA1 U NeA2) +Int I >=Int 0)
   = @(min(NeA1) +Int I >=Int 0) /\ @(min(NeA2) +Int I >=Int 0) .
  eq min({| I |}) = I .
  eq min(empty) +Int I >=Int 0 = true .
  eq @((-Int max(NeA1 U NeA2)) +Int I >=Int 0)
   = @((-Int max(NeA1)) +Int I >=Int 0) /\
     @((-Int max(NeA2)) +Int I >=Int 0) .
  eq max({| I |}) = I .
  eq (-Int max(empty)) +Int I >=Int 0 = true .
  eq in(Obj, NeA1 U NeA2) = in(Obj, NeA1) \/ in(Obj, NeA2) . 
  eq in(Obj1, {| Obj2 |}) = Obj1 === Obj2 .
  eq in(Obj, empty) = FalseFormula .
  ---eq @(-Int I +Int min(A) >= 0) /\ Phi1 ===> ~(I in A) /\ Phi2 = ===> Phi2 .

  eq A1 U A === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> @(-Int max(A1) +Int I >=Int 0) /\ Phi2
   = A1 U A === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq A1 U A === A2 U {| J |} /\ @(min(A2) +Int -Int I >=Int 0) /\
     @(J +Int -Int I >=Int 0) /\ Phi1
     ===> @(min(A1) +Int -Int I >=Int 0) /\ Phi2
   = A1 U A === A2 U {| J |} /\ @(min(A2) +Int -Int I >=Int 0) /\
     @(J +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .

  eq {| K |} U A1 === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> @(-Int K +Int I >=Int 0) /\ Phi2
   = {| K |} U A1 === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq {| K |} U A1 === A2 U {| J |} /\ @(min(A2) +Int -Int I >=Int 0) /\
     @(J +Int -Int I >=Int 0) /\ Phi1
     ===> @(K +Int -Int I >=Int 0) /\ Phi2
   = {| K |} U A1 === A2 U {| J |} /\ @(min(A2) +Int -Int I >=Int 0) /\
     @(J +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .


***(
  eq A1 U A === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> @(-Int max(A1) +Int I >=Int 0) /\ Phi2
   = A1 === A2 U {| J |} /\ @(-Int max(A2) +Int I >=Int 0) /\
     @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> Phi2 .
***)

  ---eq @(-Int max(A) +Int J >=Int 0) /\ @(-Int J +Int I >=Int 0) /\
  ---   ~(I === J) /\ in(I, A)
  --- = FalseFormula .
  eq @(-Int max(A) +Int J >=Int 0) /\ @(-Int J +Int I >=Int 0) /\
     ~(I === J) /\ Phi1
     ===> ~ in(I, A) /\ Phi2
   = @(-Int max(A) +Int J >=Int 0) /\ @(-Int J +Int I >=Int 0) /\
     ~(I === J) /\ Phi1
     ===> Phi2 .
  ---eq @(min(A) +Int -Int J >=Int 0) /\ @(J +Int -Int I +Int -1 >=Int 0) /\
  ---   in(I, A)
  --- = FalseFormula .
  eq @(min(A) +Int -Int J >=Int 0) /\ @(J +Int -Int I +Int -1 >=Int 0) /\
     ~(I === J) /\ Phi1
     ===> ~ in(I, A) /\ Phi2
   = @(min(A) +Int -Int J >=Int 0) /\ @(J +Int -Int I +Int -1 >=Int 0) /\
     ~(I === J) /\ Phi1
     ===> Phi2 .

  op leq : MSet++ MSet++ -> AtomFormula .
  eq leq(NeA1 U NeA2, A) = leq(NeA1, A) /\ leq(NeA2, A) .
  eq leq(A, NeA1 U NeA2) = leq(A, NeA1) /\ leq(A, NeA2) .
  eq leq({| I |}, {| J |}) = @(J +Int -Int I >=Int 0) .
  eq leq(empty, A) = TrueFormula .
  eq leq(A, empty) = TrueFormula .

  eq A1 U A === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> leq(A1, {| I |}) /\ Phi2
   = A1 U A === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq A1 U A === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> leq({| I |}, A1) /\ Phi2
   = A1 U A === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .

  eq A1 U {| K |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> @(-Int K +Int I >=Int 0) /\ Phi2
   = A1 U {| K |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq A1 U {| K |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> @(-Int I +Int K >=Int 0) /\ Phi2
   = A1 U {| K |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .

  eq A1 U {| K |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ leq({| I |}, A) /\ Phi1
     ===> leq({| K |}, A) /\ Phi2
   = A1 U {| K |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0) /\ leq({| I |}, A) /\ Phi1
     ===> Phi2 .
  eq A1 U {| K |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ leq(A, {| I |}) /\ Phi1
     ===> leq(A, {| K |}) /\ Phi2
   = A1 U {| K |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0) /\ leq(A, {| I |}) /\ Phi1
     ===> Phi2 .

  eq A1 U {| K1 |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0)
     /\ @(K2 +Int -Int I >=Int 0) /\ Phi1
     ===> @(K2 +Int -Int K1 >=Int 0) /\ Phi2
   = A1 U {| K1 |} === A2 U {| J |} /\ leq(A2, {| I |})
     /\ @(-Int J +Int -1 +Int I >=Int 0)
     /\ @(K2 +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq A1 U {| K1 |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0)
     /\ @(I +Int -Int K2 >=Int 0) /\ Phi1
     ===> @(K1 +Int -Int K2 >=Int 0) /\ Phi2
   = A1 U {| K1 |} === A2 U {| J |} /\ leq({| I |}, A2)
     /\ @(J +Int -Int I >=Int 0)
     /\ @(I +Int -Int K2 >=Int 0) /\ Phi1
     ===> Phi2 .

  eq leq(A, {| I |}) /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> leq(A, {| J |}) /\ Phi2
   = leq({| I |}, A) /\ @(J +Int -Int I >=Int 0) /\ Phi1
     ===> Phi2 .
  eq leq({| I |}, A) /\ @(I +Int -Int J >=Int 0) /\ Phi1
     ===> leq({| J |}, A) /\ Phi2
   = leq({| I |}, A) /\ @(I +Int -Int J >=Int 0) /\ Phi1
     ===> Phi2 .
endm

