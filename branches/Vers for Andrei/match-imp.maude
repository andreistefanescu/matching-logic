in match-hp

mod IMP is inc FOL= .
  subsort PVar < KProper .
  subsort Int++ < KResult .

  var Env' : Env .
  
  eq  [| K |] = [| 0,0,<config>
                            <k> K </k>
                            <env> .Env </env>
                            <heap> .Heap </heap>
                            <form> TrueFormula </form>
                            <menv> .MatchEnv </menv>
                            <newSym> 0 </newSym>
                            <newImpl> 0 </newImpl>
                </config> |] .

  eq <k> X ~> K </k> <env> X |-> I ;; Env </env> = <k> I ~> K </k> <env> X |-> I ;; Env </env> .

  op _+_ : K K -> KProper [prec 33 gather(e E)] .  ops ([]+_) (_+[]) : K -> K .
  eq <k> Kp + K ~> Rest </k> = <k> Kp ~> [] + K ~> Rest </k> .
  eq <k> V1 ~> [] + K ~> Rest </k> = <k> V1 + K ~> Rest </k> .
  eq <k> V1 + Kp ~> Rest </k> = <k> Kp ~> V1 + [] ~> Rest </k> .
  eq <k> V2 ~> V1 + [] ~> Rest </k> = <k> V1 + V2 ~> Rest </k> .
  eq I1 + I2 = I1 +Int I2 .

  op _-_ : K K -> KProper [prec 33 gather(e E)] .  ops ([]-_) (_-[]) : K -> K .
  eq <k> Kp - K ~> Rest </k> = <k> Kp ~> [] - K ~> Rest </k> .
  eq <k> V1 ~> [] - K ~> Rest </k> = <k> V1 - K ~> Rest </k> .
  eq <k> V1 - Kp ~> Rest </k> = <k> Kp ~> V1 - [] ~> Rest </k> .
  eq <k> V2 ~> V1 - [] ~> Rest </k> = <k> V1 - V2 ~> Rest </k> .
---  eq I1 - I2 = #(_-_(I1,I2)) .
  eq I1 - I2 = I1 +Int (-Int I2) .

  op _/_ : K K -> KProper [prec 33 gather(e E)] .  ops ([]/_) (_/[]) : K -> K .
  eq <k> Kp / K ~> Rest </k> = <k> Kp ~> [] / K ~> Rest </k> .
  eq <k> V1 ~> [] / K ~> Rest </k> = <k> V1 / K ~> Rest </k> .
  eq <k> V1 / Kp ~> Rest </k> = <k> Kp ~> V1 / [] ~> Rest </k> .
  eq <k> V2 ~> V1 / [] ~> Rest </k> = <k> V1 / V2 ~> Rest </k> .
  eq I1 / I2 = I1 /Int I2 .
  
  op _>_ : K K -> KProper [prec 35] .  ops ([]>_) (_>[]) : K -> K .
  eq <k> Kp > K ~> Rest </k> = <k> Kp ~> [] > K ~> Rest </k> .
  eq <k> V1 ~> [] > K ~> Rest </k> = <k> V1 > K ~> Rest </k> .
  eq <k> V1 > Kp ~> Rest </k> = <k> Kp ~> V1 > [] ~> Rest </k> .
  eq <k> V2 ~> V1 > [] ~> Rest </k> = <k> V1 > V2 ~> Rest </k> .
  eq I1 > I2 = ?(I1 >Int I2) .

  op _==_ : K K -> KProper [prec 35] .  ops ([]==_) (_==[]) : K -> K .
  eq <k> Kp == K ~> Rest </k> = <k> Kp ~> [] == K ~> Rest </k> .
  eq <k> V1 ~> [] == K ~> Rest </k> = <k> V1 == K ~> Rest </k> .
  eq <k> V1 == Kp ~> Rest </k> = <k> Kp ~> V1 == [] ~> Rest </k> .
  eq <k> V2 ~> V1 == [] ~> Rest </k> = <k> V1 == V2 ~> Rest </k> .
  eq I1 == I2 = ?(I1 =Int= I2) .

  op _!=_ : K K -> KProper [prec 35] .  eq K1 != K2 = !(K1 == K2) .
  op !_ : K -> KProper [prec 5] .  eq ! K = if(K) 0 else 1 .
  op _&&_ : K K -> KProper [gather(e E) prec 55] .  eq K1 && K2 = if(K1) K2 else 0 .
  op _||_ : K K -> KProper [gather(e E) prec 59] .  eq K1 || K2 = if(K1) 1 else K2 .

  op *_ : K -> KProper [prec 10] .  op *[] : -> K .
  eq <k> * Kp ~> Rest </k> = <k> Kp ~> *[] ~> Rest </k> .
  eq <k> V ~> *[] ~> Rest </k> = <k> * V ~> Rest </k> .
  eq <k> * I ~> Rest </k> <heap> I |-> J : T ** H </heap> = <k> J ~> Rest </k> <heap> I |-> J : T ** H </heap> .
  eq <k> * I ~> Rest </k> <heap> H </heap> = <k> derive(I) ~> * I ~> Rest </k> <heap> H </heap> [owise] .

  op _=_ : K K -> KProper [prec 40] .
  op _=@ : K -> K .
  op *@=_ : K -> K .
  eq <k> * Kp = K ~> Rest </k> = <k> Kp ~> *@= K ~> Rest </k> .
  eq <k> V ~> *@= K ~> Rest </k> = <k> * V = K ~> Rest </k> .
  eq <k> K = Kp ~> Rest </k> = <k> Kp ~> K =@ ~> Rest </k> .
  eq <k> V ~> K =@ ~> Rest </k> = <k> K = V ~> Rest </k> .

  eq <k> X = I ~> Rest </k> <env> Env </env> = <k> Rest </k> <env> Env[X <- I] </env> .
  eq <k> * I = J ~> Rest </k> <heap> I |-> J' : T ** H </heap> = <k> Rest </k> <heap> I |-> J : T ** H </heap> .
  eq <k> * I = J ~> Rest </k> <heap> H </heap> = <k> derive(I) ~> * I = J ~> Rest </k> <heap> H </heap> [owise] .

  op NULL : -> KProper .  eq NULL = 0 .
  op __ : K K -> K [assoc prec 100] .  eq K1 K2 = (K1 ~> K2) .
  op _; : K -> K [prec 99] .  eq K ; = K .
  op {} : -> K .  eq {} = .K .
  op {_} : K -> K .  eq {K} = K .
  op if__ : K K -> KProper [prec 93] .  eq if (K) K1 = if (K) K1 else .K .

  op alloc_ : List{LocType} -> KProper [prec 0] .
  eq <k> alloc(LocTypeList) ~> Rest </k> <heap> H </heap> <newSym> N </newSym>
  = <k> ?Int(N) ~> Rest </k> <heap> ?Int(N) |-> LocTypeList ** H </heap> <newSym> N +Int 1 </newSym> .
  eq <heap> I |-> (T, LocTypeList) ** H </heap> <newSym> N </newSym>
  = <heap> I |-> ?Int(N) : T ** (I + 1) |-> LocTypeList ** H </heap> <newSym> N +Int 1 </newSym> .
  eq <heap> I |-> (.empty).List{LocType} ** H </heap> = <heap> H </heap> .

  op free_ : K -> K .  op free([]) : -> K .
  eq <k> free(Kp) ~> Rest </k> = <k> Kp ~> free([]) ~> Rest </k> .
  eq <k> V ~> free([]) ~> Rest </k> = <k> free(V) ~> Rest </k> .
  eq <k> free(I) ~> Rest </k> <heap> (I +Int I') |-> J : T ** H </heap>
  = <k> free(I) ~> Rest </k> <heap> H </heap> .
  eq <k> free(I) ~> Rest </k> <heap> I |-> J : T ** H </heap>
  = <k> free(I) ~> Rest </k> <heap> H </heap> .
  eq <k> free(I) ~> Rest </k> <heap> H </heap> = <k> Rest </k> <heap> H </heap> [owise] .

  op if`(_`)_else_ : K K K -> KProper [prec 95] .  op if`([]`)_else_ : K K -> K .
  eq <k> (if(Kp) K1 else K2) ~> Rest </k> = <k> Kp ~> (if([]) K1 else K2) ~> Rest </k> .
  eq <k> V ~> (if([]) K1 else K2) ~> Rest </k> = <k> if(V) K1 else K2 ~> Rest </k> .
--- ceq if(# I) K1 else K2 = K1 if I =/= 0 .
---  eq if(# 0) K1 else K2 = K2 .
  rl <config> <k> (if(I) K1 else K2) ~> Rest </k> <form> Phi </form> Cfg </config>
  => <config> <k> K1 ~> Rest </k> <form> Phi /\ ~(I === 0) </form> Cfg </config>
     <config> <k> K2 ~> Rest </k> <form> Phi /\ I === 0 </form> Cfg </config> .

  op while__ : K K -> K .
---  eq <k> while(K1)K2 ~> Rest </k> = <k> (if(K1){K2 ; while(K1)K2} else .K) ~> Rest </k> .
  eq <config> <k> invariant Cfg ~> while(K1)K2 ~> Rest </k> Cfg' </config>
   = <config> <k> assert Cfg ~> if(K1)(K2 ~> assert Cfg) else Rest </k> Cfg' </config> .
   
  ops invariant_ assume_ assert_ : Set{ConfigItem} -> K [prec 99 strat(0) format(r! +++i i---)] .

  eq <config> <k> assume <config> <form> Phi </form> Cfg </config> CFGs ~> Rest </k> <form> Phi' </form> <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg' </config>
   = <config> <k> Rest </k> <form> Phi /\ Phi' </form>[get!Subst(MatchEnv)] <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg[get!Subst(MatchEnv)] <newSym> 0 </newSym> </config>
     <config> <k> assume CFGs ~> Rest </k> <form> Phi' </form> <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg' </config> .
  eq <config> <k> assume .empty ~> Rest </k> Cfg' </config> = .empty .

 crl <config> <k> assert Cfg' ~> Rest </k> <menv>  MatchEnv </menv> <newImpl> N:Nat </newImpl> Cfg </config>
  => <config> <k> assume Cfg' ~> Rest </k> <menv> MatchEnv' </menv> <newImpl> N:Nat +Nat 1 </newImpl> skolemize(N:Nat, Cfg) </config>
  if <config> Cfg <menv> MatchEnv </menv> <newImpl> N:Nat </newImpl> </config> ===> Cfg'
  => <config> <form> TrueFormula </form> <menv> MatchEnv' </menv> </config> . --- [print MatchEnv'] .

  op breakpoint : -> K .
  op watch : -> K .
 ceq <config> <k> watch ~> Rest </k> Cfg </config> = <config> <k> Rest </k> Cfg </config>
  if Cfg' := <config> <k> Rest </k> Cfg </config> [print "\n===CFG===\n" Cfg' "\n===\n"] .

---good for debugging, but a bit slower than the above
---  eq <config> <k> assert Phi ~> Rest </k> Cfg </config>
---   = <config> <k> VALID(<config> Cfg </config> ===> Phi) ? ~> assume Phi ~> Rest </k> Cfg </config> .

  var X : PVar .  vars V V1 V2 : KResult .  vars K K1 K2 Rest : K .  var Kp : KProper .
  var Env : Env++ .  var H H' : Heap++ .  var T : LocType .  var LocTypeList : List{LocType} .
  var N : Nat .  vars I I' I1 I2 J J' : Int++ .
  var Cfg Cfg' Cfg'' CFGs : Set{ConfigItem} .
  var ?ObjList : List{?MathObj} .
  var Phi Phi' : Formula .
  vars MatchEnv MatchEnv' : MatchEnv .
--- ====================================================================================================================================
  sorts Decl Signature Name List{PVar} .
  subsort PVar < List{PVar} .
  subsorts Decl Signature < K .
  
  op _`(`) : Name -> Signature .
  op _`(_`) : Name List{PVar} -> Signature .
  op .var : -> List{PVar} .
  op _|_ : List{PVar} List{PVar} -> List{PVar} [assoc id: .var] .
  op rename`(_;_,_`) : List{PVar} List{PVar} ConfigItem -> ConfigItem .
  op generate!`(_`) : ConfigItem -> ConfigItem .
  ops computeAssume_ computeAssert_ : ConfigItem -> K .
  op pre__`{_`}post_ : ConfigItem Signature K ConfigItem -> Decl .
  op validated`(_,_,_`) : Signature ConfigItem ConfigItem -> K .
  op preprocess`(_`) : K -> K .
  op declarations`(_`) : K -> K .
  op hasDecl`(_`) : K -> Bool .
  op //unprocessed : -> K .
   
  vars PreCfg PostCfg PreCfg' PostCfg' : Set{ConfigItem} . vars CfgItem CfgItem' CfgItem1 CfgItem2 : ConfigItem .
  vars ArgList ArgList' : List{PVar} .  vars PV PV' PV1 PV2 : PVar .
  vars FName FName' : Name .  var Rest' : K . var Signat : Signature .
  var count : Nat . vars DL : K .
  
  eq hasDecl(Rest) = false [owise] .
  eq hasDecl(Rest ~> pre PreCfg Signat {Computations:K} post PostCfg ~> Rest') = true .
  
  eq preprocess(//unprocessed ~> Rest) = preprocess(declarations(.K) ~> Rest) .
  eq preprocess(declarations(DL) ~> Rest ~> pre PreCfg Signat {Computations:K} post PostCfg ~> Rest' ) 
  = preprocess(declarations(DL ~> pre PreCfg Signat {Computations:K} post PostCfg ) ~> Rest ~> Rest' ) .
 ceq preprocess(declarations(DL) ~> Rest) = (DL ~> Rest) if (hasDecl(Rest) =/= true) .
  
  
  eq rename(ArgList ; ArgList' , CfgItem) = CfgItem [owise] .
 ceq rename(PV | ArgList ; PV' | ArgList' , CfgItem) = rename(ArgList ; ArgList' , rename(PV ; PV',CfgItem)) if (PV =/= PV') /\ (ArgList =/= ArgList').
 ceq rename(PV ; PV',<config> <env> Env ;; PV |-> I:Int++ ;; Env' </env> Cfg </config>) 
   = <config> <env> Env ;; PV' |-> I:Int++ ;; Env' </env> Cfg </config> if (PV =/= PV') .

  eq <config> <k> //unprocessed ~> Rest </k> Cfg' </config> = <config> <k> preprocess(//unprocessed ~> Rest) </k> Cfg' </config> .
   
  eq <config> <k> validated(Signat,PreCfg,PostCfg) ~> Rest </k> Cfg' </config> = <config> <k> .K </k> Cfg' </config> .
   
  eq <config> <k> pre PreCfg FName () {K} post PostCfg ~> Rest </k> Cfg' </config>
   = <config> <k> assume PreCfg ~> K ~> assert PostCfg ~> Rest ~> validated(FName (),PreCfg,PostCfg) </k> Cfg' </config> [print "\n Trying to prove " FName "()\n"] .
  
  eq <config> <k> pre PreCfg FName (ArgList) {K} post PostCfg ~> Rest </k> Cfg' </config>
   = <config> <k> assume PreCfg ~> K ~> assert PostCfg ~> Rest ~> validated(FName(ArgList),PreCfg,PostCfg) </k> Cfg' </config> [print "\n Trying to prove " FName "with the follwing args: " ArgList "\n"] .
   
  eq <config> <k> FName () ~> Rest ~> validated(FName (),PreCfg,PostCfg) ~> Rest' </k> Cfg' </config>
   = <config> <k> assert PreCfg ~> assume PostCfg ~> Rest ~> validated(FName (),PreCfg,PostCfg) ~> Rest' </k> Cfg' </config> [print "\n Calling " FName "\n"] .
   
   eq <config> <k> FName(ArgList) ~> Rest ~>  validated(FName(ArgList'),PreCfg,PostCfg) ~> Rest' </k> Cfg' </config>
   = <config> <k> computeAssert (rename(ArgList' ; ArgList, PreCfg)) ~> computeAssume(rename(ArgList' ; ArgList, PostCfg)) ~> Rest ~>  validated(FName(ArgList'),PreCfg,PostCfg) ~> Rest' </k> Cfg' </config> .
   eq <config> <k> computeAssert (Cfg) ~> Rest </k> Cfg' </config> 
    = <config> <k> assert (Cfg) ~> Rest </k> Cfg' </config> . 
   eq <config> <k> computeAssume (Cfg) ~> Rest </k> Cfg' </config> 
    = <config> <k> assume (Cfg) ~> Rest </k> Cfg' </config> . 
  
  --- variable replacement
  --- Step 1
  --- gather all the variables and generate substitutes for them
  ***(
  op !a_ : Nat -> !Int .
  op !A_ : Nat -> !IntSeq .
  op !T_ : Nat -> !IntTree .
  op counter(_) : Nat -> K .
   
    )***
   
--- ===================================================================================================================================
endm

eof 

  eq <config> <k> FName(ArgList) ~> Rest ~>  validated(FName(ArgList'),PreCfg,PostCfg) ~> Rest' </k> Cfg' </config>
   = <config> <k> workingOn(rename(ArgList' ; ArgList , PreCfg) , rename(ArgList' ; ArgList , PostCfg) ) ~> Rest ~>  validated(FName(ArgList'),PreCfg,PostCfg) ~> Rest' ~> counter( 0 ) </k> Cfg' </config> .
  eq <config> <k> workingOn(PreCfg , PostCfg) ~> Rest </k> Cfg' </config>
   = <config> <k> replace(generatePairs( getFreeVars(PreCfg,PostCfg) ) , PreCfg , PostCfg) ~> Rest </k> Cfg' </config> .