in ../../../match-imp

mod TEST is inc IMP + QUEUE .
  ops l a b h t e : -> PVar .
  ops ?a ?b ?h ?t ?e ?n ?u ?v ?l : -> ?Int .
  op l0 : -> FreeInt .
  op L : -> FreeIntSeq .
  ops ?A ?A' ?B ?B' ?C ?L : -> ?IntSeq .
  

  op pListMergeSort : -> K .
  eq pListMergeSort = (
    assume <config> <env> l |-> l0 ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(l0)(L) </heap> <form> TrueFormula </form> </config> ;
    if (l != NULL && *(l + 1)) {
        --- split the list in two
        a = NULL ;
        b = NULL ;
        *(*(l + 1)) = *(*(l + 1)) ;
        invariant <config> <env> l |-> l0 ;; a |-> 0 ;; b |-> 0 ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> l0 |-> ?v : node ** (l0 +Int 1) |-> ?n : next ** ?n |-> ?u : node ** (?n +Int 1) |-> ?l : next ** list(?l)(?L) </heap>
---                            <form> ~(l0 === 0) /\ L === ?v :: ?u :: ?L </form> </config>
---                         little extra help, assert ~(?n === 0)
                           <form> ~(l0 === 0) /\ ~(?n === 0) /\ L === ?v :: ?u :: ?L </form> </config>
                  <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> list(?a)(?A) ** list(?b)(?B) ** list(?l)(?L) </heap>
                           <form> list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?L) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        while (l != NULL) {
            e = l ;
            l = * (e + 1)
            * (e + 1) = a ;
            a = e ;
            if (l != NULL) {
                e = l ;
                l = * (e + 1)
                * (e + 1) = b ;
                b = e ;
            }
            
        }

        --- sort the first half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?a)(?A) ** list(?b)(?B) </heap>
                    <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0) </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;

        --- sort the second half
        assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B) </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') </form> </config> ;
        assume <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                        <heap> list(?a)(?A') ** list(?b)(?B') </heap> <form> list2bag(L) === list2bag(?A) &' list2bag(?B) /\ ~(?a === 0) /\ ~(?b === 0)
                            /\ list2bag(?A) === list2bag(?A') /\ isSorted(?A') /\ list2bag(?B) === list2bag(?B') /\ isSorted(?B') </form> </config> ;

        --- merge the two halves
        h = 0 ;
        t = 0 ;
        --- little extra help to unfold the queue heap pattern
        * a = * a ;
        * b = * b ;
        invariant <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                           <heap> queue(?h,?t)(?C) ** list(?a)(?A) ** list(?b)(?B) </heap>
                           <form> ((~(?a === 0) /\ ~(?b === 0)) \/ (~(?h === 0) /\ ~(?t === 0)))
                               /\ list2bag(L) === list2bag(?A) &' list2bag(?B) &' list2bag(?C)
                               /\ @(min(list2bag(?A)) >=Int max(list2bag(?C))) /\ @(min(list2bag(?B)) >=Int max(list2bag(?C)))
                               /\ isSorted(?A) /\ isSorted(?B) /\ isSorted(?C) </form> </config> ;
        while (a != 0 && b != 0) {
            if (* b > * a) {
                e = a ;
                a = *(a + 1) ;
            }
            else {
                e = b ;
                b = *(b + 1) ;
            }

            if (h != 0) {
                *(t + 1) = e ;
            }
            else {
                h = e ;
            }
            t = e ;
        }

        if (a != 0) {
            *(t + 1) = a ;
        }
        else {
            *(t + 1) = b ;
        }

        l = h ;
    }
    assert <config> <env> l |-> ?l ;; a |-> ?a ;; b |-> ?b ;; h |-> ?h ;; t |-> ?t ;; e |-> ?e </env>
                    <heap> list(?l)(?L) </heap> <form> list2bag(L) === list2bag(?L) /\ isSorted(?L) </form> </config> ;
  ) .
endm

rew [| pListMergeSort |] .