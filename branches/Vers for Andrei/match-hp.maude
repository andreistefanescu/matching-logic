in match-fol

mod LOCATION is inc FOL= .
  ops node next prev left right head tail : -> LocType .
endm

mod LIST is inc LOCATION .
  var N : Nat .  var P P' I Q : Int++ .  var Rest : K .  var Alpha Beta : IntSeq++ .  var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  
  op list : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> list(P)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** list(?Int(N +Int 1))(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> list(0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** list(P')(Alpha) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)((I :: Alpha)) ** H </heap> Cfg </config> =heap=> CFG .


  op lseg : -> HeapPatternName .
  
 ceq <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === Q) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** lseg(?Int(N +Int 1),Q)(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === Q) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> lseg(P,P)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  eq <heap> lseg(P,0)(Alpha) ** H </heap> = <heap> list(P)(Alpha) ** H </heap> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** lseg(P',Q)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** list(P')(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .

endm


mod DOUBLE-LINKED-LIST is inc LOCATION .
  var N : Nat .  var P P' P1 I Q Q' Q1 Q2 : Int++ .  var Rest : K .  var Alpha Beta : IntSeq++ .  var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
    
  ops dlist dlseg : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1,Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** (P +Int 2) |-> Q1 : prev ** dlseg(?Int(N +Int 1),Q)(P1,P,?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === P +Int 2) .
 ceq <config> <k> derive(Q') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1,Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(Q') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> Q |-> ?Int(N) : node ** (P +Int 1) |-> P1 : next ** (P +Int 2) |-> ?Int(N +Int 1) : prev ** dlseg(P,?Int(N +Int 1))(Q,Q1,?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) /\ (Alpha === ?IntSeq(N +Int 2) :: ?Int(N)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> Q' === Q \/ Q' === Q +Int 1 \/ Q' === Q +Int 2) .

  eq <heap> dlseg(P,Q)(P,Q1,Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (Q === Q1) /\ Alpha === epsilon </form> .
  eq <heap> dlseg(P,Q)(P1,Q,Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (P === P1) /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q1 : next ** (P +Int 2) |-> Q2 : prev ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,P)(Q1,Q2,I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> dlseg(P,Q')(P',P1,Alpha) ** dlseg(P',Q)(Q1,Q',Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,Q)(Q1,P1,Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .
  
    eq dlist(P,Q)(Alpha) = dlseg(P,Q)(0,0,Alpha) .

endm


mod QUEUE is inc LIST .
  var N : Nat .  var P P' I I' Q Q' : Int++ .  var Rest : K .  var Alpha Beta : IntSeq++ .  var H : Heap++ .
  var Phi : Formula . var Cfg : Set{ConfigItem} .  var CFG : ConfigItem . 
    
  op queue : -> HeapPatternName .

  ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : head ** (P +Int 1) |-> ?Int(N +Int 1) : tail ** queue(?Int(N), ?Int(N +Int 1))(Alpha) ** H </heap>
              <form> Phi /\ ~(P === 0) </form> <newSym> N +Int 2 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> queue(0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> 0 : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(epsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : head ** (P +Int 1) |-> Q : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(epsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> Q' : tail ** queue(Q,Q')(Alpha) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(Alpha) ** H </heap> Cfg </config> =heap=> CFG .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P,Q)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Q === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(?IntSeq(N)) ** Q |-> ?Int(N +Int 1) : node ** (Q +Int 1) |-> ?Int(N +Int 2) : next ** H </heap>
              <form> Phi /\ ~(P === 0) /\ ~(Q === 0) /\ (Alpha === ?IntSeq(N) :: ?Int(N +Int 1)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === Q \/ P' === Q +Int 1) .

  eq <heap> queue(P,0)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ P === 0 /\ Alpha === epsilon </form> .
  eq <heap> queue(0,Q)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Q === 0 /\ Alpha === epsilon </form> .

  rl <config> <heap> Q |-> I : node ** (Q +Int 1) |-> Q' : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(Q,Q)(I) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(Alpha) ** queue(P',Q)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P,Q)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .
endm


mod TREE is inc LOCATION .
  var N : Nat .  var P P' Q Q' I : Int++ .  var Rest : K .  var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  var Sigma Tau : IntTree++ .
    
  op tree : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree(P)(Tau) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Tau === upsilon) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : left ** (P +Int 2) |-> ?Int(N +Int 2) : right
                ** tree(?Int(N +Int 1))(?IntTree(N +Int 3)) ** tree(?Int(N +Int 2))(?IntTree(N +Int 4)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Tau === ?IntTree(N +Int 3) [ ?Int(N) ] ?IntTree(N +Int 4)) </form> <newSym> N +Int 5 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree(0)(Tau) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Tau === upsilon </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> 0 : right ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(upsilon [ I ] upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> 0 : right ** tree(Q)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(Tau [ I ] upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> Q : right ** tree(Q)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(upsilon [ I ] Tau) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> Q' : right ** tree(Q)(Tau) ** tree(Q')(Sigma) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(Tau [ I ] Sigma) ** H </heap> Cfg </config> =heap=> CFG .

endm

mod TREE-LIST is inc TREE .
  var N : Nat .  var P P' Q Q' I : Int++ .  var Rest : K . var H : Heap++ .
  var Phi : Formula . var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  var Sigma Tau : IntTree++ .  var Alpha' Beta' : IntTreeSeq++ .
    
  op tree-list : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree-list(P)(Alpha') ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha' === epsilon') </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** tree(?Int(N))(?IntTree(N +Int 2)) ** tree-list(?Int(N +Int 1))(?IntTreeSeq(N +Int 3)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ (Alpha' === ?IntTree(N +Int 2) ::' ?IntTreeSeq(N +Int 3)) /\ ~(?Int(N) === 0) </form> <newSym> N +Int 4 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree-list(0)(Alpha') ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha' === epsilon' </form> .

  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(upsilon) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** tree(I)(Tau) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(Tau) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> P' : next ** tree-list(P')(Alpha') ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(upsilon ::' Alpha') ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** tree(I)(Tau) ** tree-list(P')(Alpha') ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(Tau ::' Alpha') ** H </heap> Cfg </config> =heap=> CFG .
endm


mod ARRAY is inc LOCATION .
  var N : Nat .  var P P' P1 P2 Q Q' Q1 Q2 I I' J L R L' R' B E : Int++ .  var Rest : K .  var Alpha Beta : IntSeq++ .  var H H' : Heap++ .
  var Phi : Formula . var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  
  op array : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> array(P,B,E)(Alpha) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Alpha === epsilon) </form> <newSym> N </newSym> Cfg </config>
---     <config> <k> derive(P') ~> Rest </k> <heap> array(P,B,E)(Alpha) ** H </heap> <form> Phi /\ ~(P === 0) /\ ~(@(I >= B) /\ @(E > I)) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ ~(P === 0) /\ ~(@(I >=Int B) /\ @(E >Int I)) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> (P +Int I) |-> ?Int(N) : node ** array(P,B,I)(?IntSeq(N +Int 1)) ** array(P,I +Int 1,E)(?IntSeq(N +Int 2)) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ @(I >=Int B) /\ @(E >Int I) /\ (Alpha === ?IntSeq(N +Int 1) :: ?Int(N) :: ?IntSeq(N +Int 2)) </form> <newSym> N +Int 3 </newSym> Cfg </config>
---    if VALID(Phi ===> P' === P /\ I' === I) .
    if P +Int I := P' .

  eq <heap> array(0,B,E)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  eq <heap> array(P,B,B)(Alpha) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Alpha === epsilon </form> .

  rl <config> <heap> (P +Int I) |-> J : node ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> array(P,I,I +Int 1)(J) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> array(P,B,I)(Alpha) ** array(P,I,E)(Beta) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> array(P,B,E)(Alpha :: Beta) ** H </heap> Cfg </config> =heap=> CFG .
endm

---============================================================================================================================================================
mod MEM-LIST is inc LOCATION .
  var N : Nat .  var P P' I Q : Int++ .  var Rest : K . var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  
  op list : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> list(P)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** list(?Int(N +Int 1))(.empty) ** H </heap>
              <form> Phi /\ ~(P === 0) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> list(0)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** list(P')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .


  op lseg : -> HeapPatternName .
  
 ceq <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === Q) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** lseg(?Int(N +Int 1),Q)(.empty) ** H </heap>
              <form> Phi /\ ~(P === Q) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> lseg(P,P)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi </form> .

  eq <heap> lseg(P,0)(.empty) ** H </heap> = <heap> list(P)(.empty) ** H </heap> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(.empty) ** lseg(P',Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> lseg(P,Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(.empty) ** list(P')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .
  ops list`(_`) lseg`(_`) : List{MathObj++} -> Heap++ .
  eq list(P) = list(P)(.empty) .
  eq lseg(P,Q) = lseg(P,Q)(.empty) .
endm


mod MEM-DOUBLE-LINKED-LIST is inc LOCATION .
  var N : Nat .  var P P' P1 I Q Q' Q1 Q2 : Int++ .  var Rest : K . var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
    
  ops dlist dlseg : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** (P +Int 2) |-> Q1 : prev ** dlseg(?Int(N +Int 1),Q)(P1,P) ** H </heap> <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === P +Int 2) .
 ceq <config> <k> derive(Q') ~> Rest </k> <heap> dlseg(P,Q)(P1,Q1) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(Q') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === P1) /\ (Q === Q1) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> Q |-> ?Int(N) : node ** (P +Int 1) |-> P1 : next ** (P +Int 2) |-> ?Int(N +Int 1) : prev ** dlseg(P,?Int(N +Int 1))(Q,Q1) ** H </heap>
              <form> Phi /\ ~(P === P1) /\ ~(Q === Q1) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> Q' === Q \/ Q' === Q +Int 1 \/ Q' === Q +Int 2) .

  eq <heap> dlseg(P,Q)(P,Q1) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (Q === Q1) </form> .
  eq <heap> dlseg(P,Q)(P1,Q) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ (P === P1) </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q1 : next ** (P +Int 2) |-> Q2 : prev ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,P)(Q1,Q2) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> dlseg(P,Q')(P',P1) ** dlseg(P',Q)(Q1,Q') ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> dlseg(P,Q)(Q1,P1) ** H </heap> Cfg </config> =heap=> CFG .
  
    eq dlist(P,Q)(.empty) = dlseg(P,Q)(0,0) .
  op dlist`(_`) : List{MathObj++} -> Heap++ .
  eq dlist(P) = dlist(P)(.empty) .
endm


mod MEM-QUEUE is inc MEM-LIST .
  var N : Nat .  var P P' I I' Q Q' : Int++ .  var Rest : K . var H : Heap++ .
  var Phi : Formula . var Cfg : Set{ConfigItem} .  var CFG : ConfigItem . 
    
  op queue : -> HeapPatternName .

  ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : head ** (P +Int 1) |-> ?Int(N +Int 1) : tail ** queue(?Int(N), ?Int(N +Int 1))(.empty) ** H </heap>
              <form> Phi /\ ~(P === 0) </form> <newSym> N +Int 2 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> queue(0)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi </form> .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> 0 : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : head ** (P +Int 1) |-> Q : tail ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> Q : head ** (P +Int 1) |-> Q' : tail ** queue(Q,Q')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> queue(P,Q)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) /\ (Q === 0) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> derive(P') ~> Rest </k> <heap> lseg(P,Q)(.empty) ** Q |-> ?Int(N +Int 1) : node ** (Q +Int 1) |-> ?Int(N +Int 2) : next ** H </heap>
              <form> Phi /\ ~(P === 0) /\ ~(Q === 0) </form> <newSym> N +Int 3 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1 \/ P' === Q \/ P' === Q +Int 1) .

  eq <heap> queue(P,0)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ P === 0 </form> .
  eq <heap> queue(0,Q)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi /\ Q === 0 </form> .

  rl <config> <heap> Q |-> I : node ** (Q +Int 1) |-> Q' : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(Q,Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> lseg(P,P')(.empty) ** queue(P',Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> queue(P,Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG .
  op queue`(_`) : List{MathObj++} -> Heap++ .
  eq queue(P) = queue(P)(.empty) .
  eq queue(P,Q) = queue(P,Q)(.empty) .
endm


mod MEM-TREE is inc LOCATION .
  var N : Nat .  var P P' Q Q' I : Int++ .  var Rest : K .  var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
    
  op tree : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree(P)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : left ** (P +Int 2) |-> ?Int(N +Int 2) : right
                ** tree(?Int(N +Int 1))(.empty) ** tree(?Int(N +Int 2))(.empty) ** H </heap>
              <form> Phi /\ ~(P === 0) </form> <newSym> N +Int 5 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree(0)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi </form> .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> 0 : right ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> 0 : right ** tree(Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : left ** (P +Int 2) |-> Q : right ** tree(Q)(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> Q : left ** (P +Int 2) |-> Q' : right ** tree(Q)(.empty) ** tree(Q')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .
  op tree`(_`) : List{MathObj++} -> Heap++ .
  eq tree(P) = tree(P)(.empty) .
endm

mod MEM-TREE-LIST is inc MEM-TREE .
  var N : Nat .  var P P' Q Q' I : Int++ .  var Rest : K .  var H : Heap++ .
  var Phi : Formula .  var Cfg : Set{ConfigItem} .  var CFG : ConfigItem .
  var Alpha' Beta' : IntTreeSeq++ .
    
  op tree-list : -> HeapPatternName .

 ceq <config> <k> derive(P') ~> Rest </k> <heap> tree-list(P)(.empty) ** H </heap> <form> Phi </form> <newSym> N </newSym> Cfg </config>
   = <config> <k> derive(P') ~> Rest </k> <heap> H </heap> <form> Phi /\ (P === 0) </form> <newSym> N </newSym> Cfg </config>
     <config> <k> Rest </k> <heap> P |-> ?Int(N) : node ** (P +Int 1) |-> ?Int(N +Int 1) : next ** tree(?Int(N))(.empty) ** tree-list(?Int(N +Int 1))(.empty) ** H </heap>
              <form> Phi /\ ~(P === 0) /\ ~(?Int(N) === 0) </form> <newSym> N +Int 4 </newSym> Cfg </config>
    if VALID(Phi ===> P' === P \/ P' === P +Int 1) .

  eq <heap> tree-list(0)(.empty) ** H </heap> <form> Phi </form> = <heap> H </heap> <form> Phi </form> .
  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> 0 : next ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> 0 : next ** tree(I)(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> 0 : node ** (P +Int 1) |-> P' : next ** tree-list(P')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .

  rl <config> <heap> P |-> I : node ** (P +Int 1) |-> P' : next ** tree(I)(.empty) ** tree-list(P')(.empty) ** H </heap> Cfg </config> =heap=> CFG
  => <config> <heap> tree-list(P)(.empty) ** H </heap> Cfg </config> =heap=> CFG .
  op tree-list`(_`) : List{MathObj++} -> Heap++ .
  eq tree-list(P) = tree-list(P)(.empty) .
endm

---======================================================================================================================================================

mod HP is inc DOUBLE-LINKED-LIST + QUEUE + TREE + TREE-LIST + ARRAY .
endm

mod MEM-HP is inc MEM-LIST + MEM-DOUBLE-LINKED-LIST + MEM-QUEUE + MEM-TREE + MEM-TREE-LIST .
endm