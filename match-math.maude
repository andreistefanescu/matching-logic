in pl-builtins

mod MATHEMATICAL-OBJECT is including PL-BUILTINS .
***(
Sort-- stands for the common subsort
?Sort stands for bound symbolic mathematical objects
!Sort stands for unbound symbolic mathematical objects
FreeSort stands for unbound symbolic mathematical objects
Sort stands for ground, non-symbolic mathematical objects
Sort++ stands for all the above
***)
  sort MathObj-- ?MathObj !MathObj FreeMathObj MathObj MathObj++ .
  sort List{?MathObj} List{MathObj++} .
  sort Set{MathObj--} Set{?MathObj} Set{!MathObj} Set{FreeMathObj} Set{MathObj++} .
  subsort MathObj-- < ?MathObj !MathObj FreeMathObj MathObj < MathObj++ .
  subsort ?MathObj < List{?MathObj} Set{?MathObj} .
  subsort !MathObj < Set{!MathObj} .
  subsort FreeMathObj < Set{FreeMathObj} .
  subsort MathObj++ < List{MathObj++} Set{MathObj++} .
  subsort List{?MathObj} < List{MathObj++} .
  subsort Set{MathObj--} < Set{?MathObj} Set{!MathObj} Set{FreeMathObj} < Set{MathObj++} .

  op .empty : -> List{?MathObj} .
  op _,_ : List{?MathObj} List{?MathObj} -> List{?MathObj} [assoc id: .empty] .
  op _,_ : List{MathObj++} List{MathObj++} -> List{MathObj++} [ditto] .
  op errorObj : -> [MathObj++] .

  op .emptySet : -> Set{MathObj++} .
  op _&_ : Set{MathObj++} Set{MathObj++} -> Set{MathObj++} [assoc comm id: .emptySet] .

  var Obj : MathObj++ .
  eq Obj & Obj = Obj .

***(
  op .emptySet : -> Set{MathObj--} .
  op _&&&&_ : Set{MathObj--} Set{MathObj--} -> Set{MathObj--} [assoc comm id: .emptySet] .
  op _&&&&_ : Set{?MathObj} Set{?MathObj} -> Set{?MathObj} [ditto] .
  op _&&&&_ : Set{!MathObj} Set{!MathObj} -> Set{!MathObj} [ditto] .
  op _&&&&_ : Set{FreeMathObj} Set{FreeMathObj} -> Set{FreeMathObj} [ditto] .
  op _&&&&_ : Set{MathObj++} Set{MathObj++} -> Set{MathObj++} [ditto] .  
***)
  op skolem : Nat ?MathObj -> FreeMathObj [strat(0)] .
endm

mod FORMULA is including PL-BOOL + MATHEMATICAL-OBJECT .
  sorts Truth Atom NtFormula Formula .
  subsort Atom < NtFormula .
  subsorts Truth NtFormula < Formula .
  

  ops TrueFormula FalseFormula : -> Truth .
  op @_ : Bool -> Atom [prec 0] .
  op _/\_ : NtFormula Formula -> NtFormula [prec 55 assoc comm id: TrueFormula] .
  op _/\_ : Formula Formula -> Formula [ditto] .
  op ~_ : Bool -> Bool [prec 0] .
  op ~_ : Atom -> Atom [prec 0] .
  op ~_ : Formula -> NtFormula [ditto] .
  op _\/_ : NtFormula Formula -> NtFormula [prec 59 assoc comm id: FalseFormula] .
  op _\/_ : Formula Formula -> Formula [ditto] .
  op _===>_ : Formula Formula -> NtFormula [prec 61] .
---  op _===_ : MathObj++ MathObj++ -> NtFormula [comm] .
--- we really want === to be commutative, but it currently cannot, due to a Maude garbage collection bug
  op _===_ : MathObj++ MathObj++ -> Atom .
  op _===_ : List{MathObj++} List{MathObj++} -> Atom [ditto] .

  vars Obj Obj1 Obj1' Obj2 Obj2' : MathObj++ .
  vars ObjList1 ObjList2 : List{MathObj++} .
  var Atom : Atom .
  vars NtPhi NtPhi1 NtPhi2 NtPhi' : NtFormula .
  vars Phi Phi1 Phi2 Phi' : Formula .

  eq  @ true =  TrueFormula .
  eq @ false = FalseFormula .

  eq (Obj1,Obj1',ObjList1) === (Obj2,Obj2',ObjList2) = (Obj1 === Obj2) /\ (Obj1' === Obj2') /\ (ObjList1 === ObjList2) .
  eq Obj === Obj = TrueFormula .
  eq .empty === .empty = TrueFormula .

--- bad, bad eq
  eq Atom /\ Phi1 ===> Atom /\ Phi2 = Atom /\ Phi1 ===> Phi2 .

  eq ~(~(Phi)) = Phi .

  eq Phi ===>  TrueFormula = TrueFormula .
  eq Phi ===> FalseFormula = Phi .
---  leads to in infinite rewriting
---  eq FalseFormula ===> Phi = TrueFormula .
  eq  TrueFormula ===> Phi = Phi .

  eq  TrueFormula \/ NtPhi =  TrueFormula .
  eq FalseFormula /\ NtPhi = FalseFormula .

  eq NtPhi /\ NtPhi = NtPhi .
  eq NtPhi \/ NtPhi = NtPhi .

  eq NtPhi /\ ~(NtPhi) = FalseFormula .
  eq NtPhi \/ ~(NtPhi) =  TrueFormula .

  eq  TrueFormula \/  TrueFormula =  TrueFormula .
  eq FalseFormula /\ FalseFormula = FalseFormula .

  eq  ~(TrueFormula) = FalseFormula .
  eq ~(FalseFormula) =  TrueFormula .

  eq Phi ===> (NtPhi1 \/ NtPhi2) = (Phi ===> NtPhi1) \/ (Phi ===> NtPhi2) .

--- bad, bad eq
  eq NtPhi /\ (NtPhi1 \/ NtPhi2) ===> NtPhi' = (NtPhi /\ NtPhi1 ===> NtPhi') \/ (NtPhi /\ NtPhi2 ===> NtPhi') [owise] .

--- very, very bad eqs
---   eq NtPhi /\ (NtPhi1 \/ NtPhi2) = (NtPhi /\ NtPhi1) \/ (NtPhi /\ NtPhi2) .
---   eq (NtPhi1 \/ NtPhi2) ===> Phi = (NtPhi1 ===> Phi) \/ (NtPhi2 ===> Phi) .
endm


mod MATHEMATICAL-INT is inc MATHEMATICAL-OBJECT + FORMULA + PL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?Int !Int FreeInt Int++ .   --- sort Int already defined
  subsorts ?Int !Int FreeInt Int < Int++ < MathObj++ .
  subsort ?Int < ?MathObj .
  subsort !Int < !MathObj .
  subsort FreeInt < FreeMathObj .
  subsort Int < MathObj .

  op ?Int : Nat -> ?Int .
  op skolem : Nat ?Int -> FreeInt [ditto] .

--- define operations to be used symbolically, as well as desired properties
  ops _+Int_ _-Int_ _*Int_ _/Int_ : Int++ Int++ -> Int++ [ditto] .
  ops _<=Int_ _<Int_ _>=Int_ _>Int_ : Int++ Int++ -> Bool [ditto] .
  op -Int_ : Int++ -> Int++ [ditto] .
  op _=Int=_ : Int++ Int++ -> Bool .
  op ? : Bool -> Int++ .

  vars I J K I1 I2 J1 J2 N : Int++ .  var B : Bool .
  vars Phi Phi1 Phi2 : Formula .

  eq @ (I =Int= J) = I === J .

  eq I +Int (-Int I) = 0 .
  eq 0 +Int I = I .
  eq I *Int (I1 +Int I2) = (I *Int I1) +Int (I *Int I2) .
  eq (-Int I) *Int J = -Int (I *Int J) .
  eq -Int (-Int I) = I .
  eq 1 *Int I = I .
  eq I -Int J = I +Int (-Int J) .
  eq -Int (I +Int J) = (-Int I) +Int (-Int J) .
  eq I +Int (J /Int 2) = (I +Int I +Int J) /Int 2 .

  eq I +Int K === J +Int K = I === J .
 ceq I1 === J1 /\ Phi1 ===> I2 === J2 /\ Phi2 = I1 === J1 /\ Phi1 ===> Phi2 if (-Int I1) +Int (-Int I2) +Int J1 +Int J2 ==Bool 0 .

  eq I <=Int J = J >=Int I .
  eq I <Int J = J >Int I .
  eq I >Int J = I +Int (-Int 1) >=Int J . 
 ceq I >=Int J = I +Int (-Int J) >=Int 0 if J =/= 0 .
  eq ~(@(I >=Int 0)) = @((-Int I) +Int (-Int 1) >=Int 0) .

 ceq @(I >=Int 0) /\ @(J >=Int 0) = (I === 0) if I +Int J ==Bool 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) = @(I >=Int 0) if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ Phi1 ===> @(J >=Int 0) /\ Phi2 = @(I >=Int 0) /\ Phi1 ===> Phi2 if (-Int I) +Int J >=Int 0 .
 ceq @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> @(K >=Int 0) /\ Phi2 = @(I >=Int 0) /\ @(J >=Int 0) /\ Phi1 ===> Phi2 if (-Int I) +Int (-Int J) +Int K >=Int 0 .

  eq (?(B) === 0) = ~(@ B) .  eq (?(B) === 1) = @ B .
--- the next two equations should not be needed; they are there because of a Maude bug wrt commutativity of ===
  eq (0 === ?(B)) = ~(@ B) .  eq (1 === ?(B)) = @ B .

  eq (I:Int === J:Int) = @(I:Int ==Bool J:Int) .
endm


mod MATHEMATICAL-INT-SEQUENCE is inc MATHEMATICAL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?IntSeq !IntSeq FreeIntSeq IntSeq IntSeq++ .
  subsort ?Int < ?IntSeq .
  subsort !Int < !IntSeq .
  subsort FreeInt < FreeIntSeq .
  subsort Int < IntSeq .
  subsort Int++ < IntSeq++ .
  subsorts ?IntSeq !IntSeq FreeIntSeq IntSeq < IntSeq++ < MathObj++ .
  subsort ?IntSeq < ?MathObj .
  subsort !IntSeq < !MathObj .
  subsort FreeIntSeq < FreeMathObj .
  subsort IntSeq < MathObj .
  op ?IntSeq : Nat -> ?IntSeq .
  op skolem : Nat ?IntSeq -> FreeIntSeq [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op epsilon : -> IntSeq .
  op _::_ : IntSeq++ IntSeq++ -> IntSeq++ [assoc id: epsilon] .
  op rev : IntSeq++ -> IntSeq++ .
  op len : IntSeq++ -> Int++ .
  op isFiltered : IntSeq++ Int++ -> Atom .
  op hasOnly : IntSeq++ Int++ -> Atom .
  op sort : IntSeq++ -> IntSeq++ .

  vars I I' : Int++ .  vars A A' A'' : IntSeq++ .
  vars pre pre1 pre2 post post1 post2 : IntSeq++ .

 ceq A :: A' === A :: A'' = A' === A'' if A =/= epsilon .
 ceq A' :: A === A'' :: A = A' === A'' if A =/= epsilon .
 ceq I :: A === I' :: A' = I === I' /\ A === A' if A =/= epsilon orBool A' =/= epsilon .
 ceq A :: I === A' :: I' = I === I' /\ A === A' if A =/= epsilon orBool A' =/= epsilon .
  eq rev(I :: A) = rev(A) :: I .
  eq rev(epsilon) = epsilon .
 ceq len(A :: A') = len(A) +Int len(A') if A =/= epsilon /\ A' =/= epsilon .
  eq len(I) = 1 .
  eq len(epsilon) = 0 .


 ceq isFiltered(A :: A', I) = isFiltered(A, I) /\ isFiltered(A', I) if A =/= epsilon /\ A' =/= epsilon .
  eq isFiltered(epsilon, I) = TrueFormula .
  eq isFiltered(I,I') = ~(I === I') .
  
 ceq hasOnly(A :: A', I) = hasOnly(A, I) /\ hasOnly(A', I) if A =/= epsilon /\ A' =/= epsilon .
  eq hasOnly(epsilon, I) = FalseFormula .
  eq hasOnly(I,I') = I === I' .
  
 --- ceq sort(pre :: I :: I' :: post) = sort(pre :: I' :: I :: post) if (I' <Int I) .
  --- eq sort(A) = A [owise] .

  eq (A:IntSeq === A':IntSeq) = @(A:IntSeq ==Bool A':IntSeq) .
endm


mod MATHEMATICAL-INT-TREE is inc MATHEMATICAL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?IntTree !IntTree FreeIntTree IntTree IntTree++ .
  subsorts ?IntTree !IntTree FreeIntTree IntTree < IntTree++ < MathObj++ .
  subsort ?IntTree < ?MathObj .
  subsort !IntTree < !MathObj .
  subsort FreeIntTree < FreeMathObj .
  subsort IntTree < MathObj .
  op ?IntTree : Nat -> ?IntTree .
  op skolem : Nat ?IntTree -> FreeIntTree [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op upsilon : -> IntTree .
  op _`[_`]_ : IntTree++ Int++ IntTree++ -> IntTree++ .
  op mirror : IntTree++ -> IntTree++ .

  var I I' : Int++ .  var T TL TR TL' TR' : IntTree++ .

  eq TL [ I ] TR === TL' [ I' ] TR' = I === I' /\ TL === TL' /\ TR === TR' .
  eq mirror(TL [ I ] TR) = mirror(TR) [ I ] mirror(TL) .
  eq mirror(upsilon) = upsilon .
  
  ops maximum minimum : IntTree++ -> Int++ .
 ceq maximum(TL [ I ] TR) = maximum( TR ) if TR =/= upsilon . --- the argument will always be the left subtree
  eq maximum(TL [ I ] upsilon) = I .
 ceq minimum(TL [ I ] TR) = minimum( TL ) if TL =/= upsilon . --- the argument will always be the right subtree
  eq minimum(upsilon [ I ] TR) = I .
  
  op isBSTree : IntTree++ -> Atom .
  op isBSTreeNode : IntTree++ -> Atom .
  op checkBST : Atom -> Bool .
  
  eq isBSTreeNode( upsilon [ I ] upsilon) = TrueFormula .
 ceq isBSTreeNode( TL [ I ] TR) = @(I >Int maximum(TL)) /\ @(minimum(TR) >=Int I) if TL =/= upsilon /\ TR =/= upsilon .
 ceq isBSTreeNode( TL [ I ] upsilon) = @(I >Int maximum(TL)) if TL =/= upsilon .
 ceq isBSTreeNode( upsilon [ I ] TR) = @(minimum(TR) >=Int I ) if TR =/= upsilon .
  
  eq isBSTree(TL [ I ] TR) = isBSTree(TL) /\ isBSTree(TR) /\ isBSTreeNode(TL [ I ] TR) .
  eq isBSTree(upsilon) = TrueFormula .
  
 ceq checkBST(A:Atom) = false if A:Atom =/= TrueFormula .
 ceq checkBST(A:Atom) = true if A:Atom =/= FalseFormula  .
 
  op isInTree : Int++ IntTree++ -> Int++ .
 ceq isInTree(I, TL [ I' ] TR) = isInTree(I , TL) if I <Int I' .
 ceq isInTree(I, TL [ I' ] TR) = isInTree(I , TR) if I >Int I' .
 ceq isInTree(I, TL [ I' ] TR) = 1 if I ==Bool I' .
  eq isInTree(I,upsilon) = 0 .
 
  op contains : IntTree++ IntTree++ -> Atom .
 ceq contains(TL [ I ] TR , TL' [ I' ] TR') = contains( TL , TL' [ I' ] TR') \/ contains(TR , TL' [ I' ] TR') if I =/= I' .
  eq contains(TL [ I ] TR , TL [ I ] TR) = TrueFormula .
  eq contains(T, upsilon) = TrueFormula .
    
endm


mod MATHEMATICAL-INT-TREE-SEQUENCE is inc MATHEMATICAL-INT-TREE .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?IntTreeSeq !IntTreeSeq FreeIntTreeSeq IntTreeSeq IntTreeSeq++ .
  subsort ?IntTree < ?IntTreeSeq .
  subsort !IntTree < !IntTreeSeq .
  subsort FreeIntTree < FreeIntTreeSeq .
  subsort IntTree < IntTreeSeq .
  subsort IntTree++ < IntTreeSeq++ .
  subsorts ?IntTreeSeq !IntTreeSeq FreeIntTreeSeq IntTreeSeq < IntTreeSeq++ < MathObj++ .
  subsort ?IntTreeSeq < ?MathObj .
  subsort !IntTreeSeq < !MathObj .
  subsort FreeIntTreeSeq < FreeMathObj .
  subsort IntTreeSeq < MathObj .
  op ?IntTreeSeq : Nat -> ?IntTreeSeq .
  op skolem : Nat ?IntTreeSeq -> FreeIntTreeSeq [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op epsilon' : -> IntTreeSeq .
  op _::'_ : IntTreeSeq++ IntTreeSeq++ -> IntTreeSeq++ [assoc id: epsilon'] .
  op rev' : IntTreeSeq++ -> IntTreeSeq++ .
  op len' : IntTreeSeq++ -> IntTree++ .

  var T : IntTree++ .  var A A' A'' : IntTreeSeq++ .

 ceq A ::' A' === A ::' A'' = A' === A'' if A =/= epsilon' .
 ceq A' ::' A === A'' ::' A = A' === A'' if A =/= epsilon' .
  eq rev'(epsilon') = epsilon' .
  eq rev'(T ::' A) = rev'(A) ::' T .
  eq len'(epsilon') = 0 .
  eq len'(A ::' T ::' A') = len'(A) +Int T +Int len'(A') .
endm


mod MATHEMATICAL-INT-BAG is inc MATHEMATICAL-INT .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?IntBag !IntBag FreeIntBag IntBag IntBag++ .
  subsort ?Int < ?IntBag .
  subsort !Int < !IntBag .
  subsort FreeInt < FreeIntBag .
  subsort Int < IntBag .
  subsort Int++ < IntBag++ .
  subsorts ?IntBag !IntBag FreeIntBag IntBag < IntBag++ < MathObj++ .
  subsort ?IntBag < ?MathObj .
  subsort !IntBag < !MathObj .
  subsort FreeIntBag < FreeMathObj .
  subsort IntBag < MathObj .
  op ?IntBag : Nat -> ?IntBag .
  op skolem : Nat ?IntBag -> FreeIntBag [ditto] .

--- define operations to be used symbolically, as well as desired properties
  op empty : -> IntBag .
  op _&'_ : IntBag++ IntBag++ -> IntBag++ [assoc comm id: empty] .
  op size : IntBag++ -> Int++ . 
  ops min max : IntBag++ -> Int++ .

  vars I J : Int++ .  vars A A' A'' : IntBag++ .

 ceq A &' A' === A &' A'' = A' === A'' if A =/= empty .
  eq size(empty) = 0 .
  eq size(I) = 1 .
 ceq size(A &' A') = size(A) +Int size(A') if A =/= empty /\ A' =/= empty .
  eq min(empty) +Int I >=Int 0 = true .
  eq min(I) = I .
 ceq @(min(A &' A') +Int I >=Int 0) = @(min(A) +Int I >=Int 0) /\ @(min(A') +Int I >=Int 0) if A =/= empty /\ A' =/= empty .
  eq (-Int max(empty)) +Int I >=Int 0 = true .
  eq max(I) = I .
 ceq @((-Int max(A &' A')) +Int I >=Int 0) = @((-Int max(A)) +Int I >=Int 0) /\ @((-Int max(A')) +Int I >=Int 0) if A =/= empty /\ A' =/= empty .
endm

***(
mod MATHEMATICAL-GRAPH is inc MATHEMATICAL-INT + MATHEMATICAL-INT-SEQUENCE .
--- define sorts, subsorts and skolem as below for each new mathematical object
  sorts ?Graph !Graph FreeGraph Graph Graph++ .
  subsorts ?Graph !Graph FreeGraph Graph < Graph++ < MathObj++ .
  subsort ?Graph < ?MathObj .
  subsort !Graph < !MathObj .
  subsort FreeGraph < FreeMathObj .
  subsort  Graph <  MathObj .
  op ?Graph : Nat -> ?Graph .
  op skolem : Nat ?Graph -> FreeGraph [ditto] .
--- define operations to be used symbolically, as well as desired properties
  op empty : -> Graph .
  op _[_,_,_] : Int++ Int++ IntSeq++ IntSeq++ -> Graph++ [prec 0] .
  op _#_ : Graph++ Graph++ -> Graph++ [assoc comm id: empty] .
  vars G G' G1 G2 : Graph++ .  vars P P' M M' : Int++ .  vars In In' Out Out' : IntSeq++ .
  eq P[M, In, Out] # G === P[M', In', Out'] # G' = M === M' /\ In === In' /\ Out === Out' /\ G === G' .
 ceq G # G1 === G # G2 = G1 === G2 if G =/= empty .
endm
***)

mod MATHEMATICAL-DOMAIN is
  inc MATHEMATICAL-INT + MATHEMATICAL-INT-SEQUENCE + MATHEMATICAL-INT-TREE + MATHEMATICAL-INT-TREE-SEQUENCE + MATHEMATICAL-INT-BAG .

  vars Phi Phi1 Phi2 : Formula .
  var I : Int++ .
  
  vars T TL TR : IntTree++ .  var TS TS' : IntTreeSeq++ .

  op tree2list : IntTree++ -> IntSeq++ .
  op tree-list2list : IntTreeSeq++ -> IntSeq++ .

  eq tree2list(TL [ I ] TR) = tree2list(TL) :: I :: tree2list(TR) .
  eq tree2list(upsilon) = epsilon .
  eq tree-list2list(TS ::' T ::' TS') = tree-list2list(TS) :: tree2list(T) :: tree-list2list(TS') .
  eq tree-list2list(epsilon') = epsilon .

  var A A' : IntSeq++ .

---   op list2bag : IntSeq++ -> IntBag++ .
  op list2bag : ?IntSeq -> ?IntBag .
  op list2bag : !IntSeq -> !IntBag [ditto] .
  op list2bag : FreeIntSeq -> FreeIntBag [ditto] .
  op list2bag : IntSeq -> IntBag [ditto] .
  op list2bag : IntSeq++ -> IntBag++ [ditto] .

 ceq list2bag(A :: A') = list2bag(A) &' list2bag(A') if A =/= epsilon /\ A' =/= epsilon .
  eq list2bag(I) = I .
  eq list2bag(epsilon) = empty .

  op isSorted : IntSeq++ -> Atom .

 ceq isSorted(A :: A') = @(min(list2bag(A')) >=Int max(list2bag(A)))  /\ isSorted(A) /\ isSorted(A') if A =/= epsilon /\ A' =/= epsilon .
  eq isSorted(I) = TrueFormula .
  eq isSorted(epsilon) = TrueFormula .

---
  vars B1 B2 B1' B2' : IntBag++ .
--- ceq (((B1 === B2) /\ Phi1) ===> ((B1 &' B1') === (B2 &' B2') /\ Phi2)) = (((B1 === B2) /\ Phi1) ===> ((B1' === B2') /\ Phi2))
---  if B1 =/= empty /\ B2 =/= empty /\ B1' =/= empty /\ B2' =/= empty .
  eq @(1 +Int (-Int len(A)) >=Int 0) /\ Phi1 ===> isSorted(A) /\ Phi2 = @(1 +Int (-Int len(A)) >=Int 0) /\ Phi1 ===> Phi2 .
endm

mod VAR-UTILS is inc PL-BOOL + FORMULA + PL-META-TERM .
  op get?VarSet : Formula -> Set{MathObj++} .
  op get?VarSet : TermList -> Set{MathObj++} .
  op get!VarSet : Formula -> Set{MathObj++} .
  op get!VarSet : TermList -> Set{MathObj++} .
  op getFreeVarSet : Formula -> Set{MathObj++} .
  op getFreeVarSet : TermList -> Set{MathObj++} .

  var Phi : Formula .

  eq get?VarSet(Phi) = get?VarSet(upTerm(Phi)) .
  eq get!VarSet(Phi) = get!VarSet(upTerm(Phi)) .
  eq getFreeVarSet(Phi) = getFreeVarSet(upTerm(Phi)) .

  var QC : Constant .  vars QT NT NT' : Term .  var QTList : TermList .  var QTNeList : NeTermList .  var Q : Qid .

  eq get?VarSet((QT : QTNeList)) = get?VarSet(QT) & get?VarSet(QTNeList) .
  eq get?VarSet(empty) = .emptySet .
  eq get?VarSet(QC) = if substrString(string(getType(QC)), 0, 1) ==Bool "?" then downTerm(QC, .emptySet) else .emptySet fi .
  eq get?VarSet('?Int[QT]) = downTerm('?Int[QT], .emptySet) .
  eq get?VarSet('?IntSeq[QT]) = downTerm('?IntSeq[QT], .emptySet) .
  eq get?VarSet('?IntTree[QT]) = downTerm('?IntTree[QT], .emptySet) .
  eq get?VarSet('?IntTreeSeq[QT]) = downTerm('?IntTreeSeq[QT], .emptySet) .
  eq get?VarSet('?IntBag[QT]) = downTerm('?IntBag[QT], .emptySet) .
  eq get?VarSet('?Graph[QT]) = downTerm('?Graph[QT], .emptySet) .
  eq get?VarSet(Q[QTList]) = get?VarSet(QTList) [owise] .

  eq getFreeVarSet((QT : QTNeList)) = getFreeVarSet(QT) & getFreeVarSet(QTNeList) .
  eq getFreeVarSet(empty) = .emptySet .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeMathObj .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeInt .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeIntSeq .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeIntTree .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeIntTreeSeq .
 ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeIntBag .
---  ceq getFreeVarSet(QC) = downTerm(QC, .emptySet) if getType(QC) ==Bool 'FreeGraph .
  eq getFreeVarSet(QC) = .emptySet [owise] .
  eq getFreeVarSet('skolem[NT : QT]) = downTerm('skolem[NT : QT], .emptySet) .
  eq getFreeVarSet(Q[QTList]) = getFreeVarSet(QTList) [owise] .
endm
